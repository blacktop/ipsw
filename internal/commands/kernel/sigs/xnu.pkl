amends "../pkl/Symbolicator.pkl"

signatures {
    new {
        args = 0
        anchors {
            "xnu early random"
            "ccdrbg_init() returned %d @%s:%d"
            "Early boot random cchkdf_expand %s failed with err %d @%s:%d"
            "Expected %u seed bytes from bootloader, but got %u. @%s:%d"
            "bootseed_init"
            "prngseed_init"
            "entropy_init"
        }
        symbol = "early_random_init"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "xnu entropy extract seed"
        }
        symbol = "entropy_provide"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "0123456789ABCDEF"
        }
        symbol = "utf8_decodestr"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "                                "
            "NEFilterCrypto"
            "%s:%d Signed data: datalen %lu\n"
            "%s:%d %s \t%s: %hhX %hhX %hhX %hhX %hhX %hhX %hhX %hhX %hhX %hhX %hhX %hhX %hhX %hhX %hhX %hhX %hhX %hhX %hhX %hhX %hhX %hhX %hhX %hhX %hhX %hhX %hhX %hhX %hhX %hhX %hhX %hhX\n"
            "Signature"
            "%s:%d %s NE Filter crypto data:\n"
            "cfil_crypto_print_data"
            "flow_id"
            "sock_id"
            "direction"
            "remote"
            "socketProtocol"
            "effective_pid"
            "effective_uuid"
            "byte_count_in"
            "byte_count_out"
        }
        symbol = "cfil_crypto_sign_data"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "lockf:pause"
            "lockf:np"
            "%s: spurious wakeup, retrying lock\n"
            "lf_setlock"
        }
        symbol = "lf_advlock"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "common"
            "2common"
            "system"
            "header adler %#08X != calculated_adler %#08X\n @%s:%d"
            "IONVRAMCHRPHandler.cpp"
        }
        symbol = "__ZN18IONVRAMCHRPHandler16unserializeImageEPKhy"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "dtrace: fbt: No return probe for %s, walked to next routine at 0x%016llx\n"
        }
        symbol = "fbt_provide_probe"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Kernel stack memory corruption detected @%s:%d"
            "stack_protector.c"
        }
        symbol = "__stack_chk_fail"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "kdp_packet bad len %lu\n"
            "kdp_packet bad len pkt %lu hdr %d\n"
            "kdp_packet reply recvd req %x seq %x\n"
            "kdp_packet bad request %x len %d seq %x key %x\n"
        }
        symbol = "kdp_packet"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "A trap was already set at that address, not setting new breakpoint\n"
        }
        symbol = "kdp_set_breakpoint_internal"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "kdp_remove_all_breakpoints: found extant breakpoints, removing them.\n"
        }
        symbol = "kdp_remove_all_breakpoints"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "kdp_unknown request %x len %d seq %x key %x\n"
        }
        symbol = "kdp_unknown"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "stackshot_maxsz"
            "-panic_on_exception_triage"
            "-show_pointers"
            "-no_slto_panic"
            "kernel_bootstrap: result = %08X @%s:%d"
            "kernel_bootstrap_thread"
        }
        symbol = "kernel_bootstrap"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "stackshot_tries"
        }
        symbol = "stackshot_push_duration_and_latency"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "stackshot_in_flags"
            "stackshot_in_pid"
            "system_state_flags"
            "stackshot_pagetable_mask"
            "stackshot_size_estimate"
            "stackshot_size_estimate_adj"
            "stackshot_tasks_count"
            "stackshot_threads_count"
        }
        symbol = "kdp_stackshot_kcdata_format"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "_panicd_ip"
            "_router_ip"
            "panicd_port"
            "_panicd_corename"
        }
        symbol = "kdp_register_send_receive"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "kdp_ip_addr"
        }
        symbol = "kdp_set_interface"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "octet"
            "%s%c%s%c%s%c"
            "Unable to create core header packet.\n"
            "dumpinfo does not fit into KDP packet.\n"
        }
        symbol = "create_panic_header"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "Cannot contact panic server, timing out.\n"
            "TX retry #%d "
            "Unable to get panic header.\n"
            "Protocol features: 0x%x\n"
            "Panic server returned error %d, retrying\n"
            "RX retry "
            "\nTotal number of packets transmitted: %d\n"
            "Avg. superblock transfer abstime 0x%llx\n"
            "Minimum superblock transfer abstime: 0x%llx\n"
            "Maximum superblock transfer abstime: 0x%llx\n"
        }
        symbol = "kdp_send_crashdump_pkt"
        caller = "?"
    }
    new {
        args = 3
        anchors {
            "kdp_set_dump_info: Skipping invalid panicd port %d (using %d)\n"
        }
        symbol = "kdp_set_dump_info"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "System dump aborted.\n"
            "Entering system dump routine\n"
            "Error: No transport device registered for kernel crashdump\n"
            "A dump server was not specified in the boot-args, terminating kernel core dump.\n"
            "kdp_panic_dump: unexpected pending input packet"
            "paniclog"
            "systemlog"
            "%s-%s-%d.%d.%d.%d-%x%s"
            "inet_aton() failed interpreting %s as a panic server IP\n"
            "Attempting connection to panic server configured at IP %s, port %d\n"
            "Resolved %s's (or proxy's) link level address\n"
            "inet_aton() failed interpreting %s as an IP\n"
            "Routing through specified router IP %s (%d)\n"
            "Transmitting packets to link level address: %02x:%02x:%02x:%02x:%02x:%02x\n"
            "Kernel map size is %llu\n"
            "Sending write request for %s\n"
            "Transmitting panic log, please wait: "
            "Please file a bug report on this panic, if possible.\n"
            "Transmitting system log, please wait: "
            "custom"
        }
        symbol = "kdp_panic_dump"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "; UUID="
            "; stext="
            "Serial requested, consistent debug disabled or debug boot arg not present, configuring debugging over serial\n"
            "Initializing serial KDP\n"
        }
        symbol = "kdp_init"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "kdp_poll"
            "kdp_poll: no debugger device\n"
        }
        symbol = "kdp_poll"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "kdp_raise_exception with NULL state\n"
            "%s exception (%x,%x,%x)\n"
            "kdp_raise_exception"
            "Debugger re-entry scheduled in %d milliseconds\n"
            "Using serial KDP.\n"
            "\nWaiting for remote debugger connection.\n"
            "Options.....    Type\n"
            "------------    ----\n"
            "continue....    'c'\n"
            "reboot......    'r'\n"
            "Continuing...\n"
            "Rebooting...\n"
            "Connected to remote debugger.\n"
            "kdp: exception ack timeout\n"
            "kdp_send: no input packet"
            "kdp: bad sequence %d (want %d)\n"
        }
        symbol = "kdp_raise_exception"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "kdp_reply: no input packet"
            "kdp_send: packet too large (%d > %u)"
        }
        symbol = "kdp_reply"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: cannot exclude region starting at %p with size %zu (zero or overflowing size) @%s:%d"
            "%s: cannot exclude region starting at %p with size %zu (not page aligned) @%s:%d"
        }
        symbol = "kdp_core_exclude_region"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "kdp_core_handle_new_encryption_key failed to re-initialize encryption stage. Error 0x%x\n"
            "kdp_core_handle_new_encryption_key failed to read the existing corefile header. Error 0x%x\n"
            "kdp_core_handle_new_encryption_key failed to update the existing corefile header. Error 0x%x\n"
            "kdp_core_handle_new_encryption_key failed to write the corefile header. Error 0x%x\n"
            "kdp_core_handle_new_encryption_key failed to write the next public key. Error 0x%x\n"
            "kdp_core_handle_new_encryption_key failed to zero-out the public key region. Error 0x%x\n"
        }
        symbol = "kdp_core_handle_new_encryption_key"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "kdp_core_polled_io_polled_file_available failed to read corefile header. Error 0x%x\n"
            "kdp_core_polled_io_polled_file_available failed to read the public key. Error 0x%x\n"
        }
        symbol = "kdp_core_polled_io_polled_file_available"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "KDPCoreStageInit"
            "apple_encrypted_archive interface registration callback is already set @%s:%d"
            "compression interface registration callback is already set @%s:%d"
        }
        symbol = "kdp_core_init"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "(kern_dump_update_header) outproc(KDP_SEEK, NULL, %lu, %p) foffset = 0x%llx returned 0x%x\n"
            "(kern_dump_update_header) outproc(KDP_DATA, NULL, %lu, %p) returned 0x%x\n"
            "(kern_dump_update_header) outproc data flush returned 0x%x\n"
            "(kern_dump_update_header) outproc explicit flush returned 0x%x\n"
        }
        symbol = "kern_dump_update_header"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "outproc(KDP_WRQ, NULL, 0, NULL) returned 0x%x\n"
            "(do_kern_dump write public key) returned 0x%x\n"
            "(do_kern_dump seek begin) outproc(KDP_SEEK, NULL, %lu, %p) foffset = 0x%llx returned 0x%x\n"
            "Writing local cores...\n"
            "Transmitting kernel state, please wait:\n"
            "(do_kern_dump seek logfile) outproc(KDP_SEEK, NULL, %lu, %p) foffset = 0x%llx returned 0x%x\n"
            "(do_kern_dump paniclog) outproc(KDP_DATA, NULL, %lu, %p) returned 0x%x\n"
            "(do_kern_dump coredump log) outproc(KDP_DATA, NULL, %lu, %p) returned 0x%x\n"
            "(do_kern_dump close) outproc(KDP_EOF, NULL, 0, 0) returned 0x%x\n"
            "We were in the middle of initializing LZ4 stage. Cannot write a coredump to disk\n"
            "LZ4 stage is not yet initialized. Cannot write a coredump to disk\n"
            "We were in the middle of initializing encryption. Marking it as unavailable\n"
            "We were in the middle of initializing the disk stage. Cannot write a coredump to disk\n"
            "Corefile is not yet initialized. Cannot write a coredump to disk\n"
            "Zlib stage is not initialized. Cannot write a coredump to the network\n"
            "Zlib stage is not initialized. Cannot write a coredump to shared memory\n"
            "(kern_dump_write_public_key) outproc(KDP_SEEK, NULL, %lu, %p) foffset = 0x%llx returned 0x%x\n"
            "(kern_dump_write_public_key) outproc(KDP_DATA, NULL, %llu, NULL) returned 0x%x\n"
            "(kern_dump_write_public_key) outproc data flush returned 0x%x\n"
            "(kern_dump_write_public_key) outproc explicit flush returned 0x%x\n"
            "\nBeginning dump of panic region of size 0x%zx\n"
            "Skipping panic region dump\n"
            "Failed to write panic region to file, kdp_coreoutput(outstate, %zu, %p) returned 0x%x\n"
            "Failed to flush panic region data : kdp_core_output(%p, 0, NULL) returned 0x%x\n"
            "panic_region"
            "Failed to record panic region in corefile header, kern_dump_record_file returned 0x%x\n"
            "Recorded panic region in corefile at offset 0x%llx, compressed to %llu bytes\n"
            "Failed to seek to panic region file offset 0x%llx, kern_dump_seek_to_next_file returned 0x%x\n"
        }
        symbol = "do_kern_dump"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "(kdp_core_init_encryption_stage) Failed to initialize the encryption stage. Error 0x%x\n"
        }
        symbol = "kdp_core_init_encryption_stage"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: skipping kernel because excluded regions list is locked\n"
            "kern_dump_init"
        }
        symbol = "kern_dump_init"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "save_summary: pmap traversal failed: %d\n"
        }
        symbol = "kern_dump_save_summary"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "save_seg_desc: pmap traversal failed: %d\n"
        }
        symbol = "kern_dump_save_segment_data_0"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "save_seg_data: pmap traversal failed: %d\n"
        }
        symbol = "kern_dump_save_segment_data"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: context allocation failure\n"
            "user_dump_init"
            "%s: no task is set\n"
            "%s: skipping inactive task\n"
            "%s: skipping locked task\n"
            "%s: skipping task with locked vm map\n"
        }
        symbol = "user_dump_init"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "user_dump_save_summary"
        }
        symbol = "user_dump_save_summary"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "user_dump_save_seg_descriptions"
        }
        symbol = "user_dump_save_seg_descriptions"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "user_dump_save_segment_data"
        }
        symbol = "user_dump_save_segment_data"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "panic context"
        }
        symbol = "user_dump_save_note_descriptions"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "AEA kext returned an error while calculating state size."
            "Failed to allocate memory (%zu bytes) for the AEA stage. Error 0x%x\n"
            "WARNING: Coredump encryption failed to initialize. aea_initialize_state() returned %d\n"
        }
        symbol = "aea_stage_initialize"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "(aea_stage_reset) aea_close() returned %d\n"
        }
        symbol = "aea_stage_reset"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "(aea_stage_outproc) aea_close() returned %d\n"
            "(aea_stage_outproc) aea_open() returned %d\n"
            "(aea_stage_outproc) aea_write() returned %zd\n"
        }
        symbol = "aea_stage_outproc"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "(aea_write_callback) next stage outproc returned 0x%x\n"
        }
        symbol = "aea_write_callback"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "(aea_read_callback) next stage read proc returned 0x%x\n"
        }
        symbol = "aea_read_callback"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "(aea_availability_callback) Failed to handle availability of encryption. Error 0x%x\n"
        }
        symbol = "aea_availability_callback"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "buffer_stage_initialize failed to allocate memory. Error 0x%x\n"
        }
        symbol = "buffer_stage_initialize"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "buffer_stage_outproc (during forwarding) returned 0x%x\n"
        }
        symbol = "buffer_stage_outproc"
        caller = "?"
    }
    new {
        args = 4
        anchors {
            "(disk_stage_write) disk_stage_read (during seek) returned 0x%x\n"
            "(disk_stage_write) IOPolledFileSeek(0x%llx) returned 0x%x\n"
            "(disk_stage_write) disk_stage_read (during final chunk seek) returned 0x%x\n"
            "(disk_stage_write) IOPolledFileWrite(gIOPolledCoreFileVars, %p, 0x%llx, NULL) returned 0x%x\n"
            "(disk_stage_write) IOPolledFileWrite (during final flush) returned 0x%x\n"
        }
        symbol = "disk_stage_write"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "(disk_stage_read) IOPolledFileWrite (during seek) returned 0x%x\n"
            "(disk_stage_read) IOPolledFileSeek(0x%llx) returned 0x%x\n"
            "(disk_stage_read) Kickstarting IOPolledFileRead(0) returned 0x%x\n"
        }
        symbol = "disk_stage_read"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "IOPolledFileSeek(gIOPolledCoreFileVars, 0) returned 0x%x\n"
            "IOPolledFilePollersOpen returned 0x%x\n"
            "IOPolledFileWrite (during seek) returned 0x%x\n"
            "IOPolledFileSeek(0x%llx) returned 0x%x\n"
            "IOPolledFileWrite(gIOPolledCoreFileVars, %p, 0x%llx, NULL) returned 0x%x\n"
            "IOPolledFileFlush() returned 0x%x\n"
            "IOPolledFileWrite (during EOF) returned 0x%x\n"
            "IOPolledFilePollersClose (during EOF) returned 0x%x\n"
        }
        symbol = "disk_stage_outproc"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "(%s) Failed to handle availability of LZ4. Error 0x%x\n"
            "lz4_stage_registration_callback"
        }
        symbol = "lz4_stage_registration_callback"
        caller = "?"
    }
    new {
        args = 4
        anchors {
            "kdp_send_crashdump_data returned 0x%x\n"
        }
        symbol = "net_stage_outproc"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "progress_notify_stage_initialize failed to allocate memory. Error 0x%x\n"
        }
        symbol = "progress_notify_stage_initialize"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s (during forwarding) returned 0x%x\n"
            "progress_notify_stage_outproc"
        }
        symbol = "progress_notify_stage_outproc"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "handshake structure not initialized\n"
            "Waiting for hardware shared memory debugger, handshake structure is at virt: %p, phys %p\n"
        }
        symbol = "panic_spin_shmcon"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "EOF Flush: Detected stale/invalid seq num. Expected: %d, received %d\n"
            "Setting coredump status as done!\n"
        }
        symbol = "shmem_stage_outproc"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Detected remote error, terminating...\n"
            "Detected stale/invalid seq num. Expected: %d, received %d\n"
            "Kernel timed out waiting for hardware debugger to update handshake structure."
            "No contact in %d seconds\n"
        }
        symbol = "shmem_dbg_process_buffers"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "kdp_core zlib memory 0x%lx\n"
            "zlib_stage_initialize failed to allocate memory. Error 0x%x\n"
        }
        symbol = "zlib_stage_initialize"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "ZERR %d\n"
        }
        symbol = "zlib_stage_outproc"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s failed to allocate memory. Error 0x%x\n"
            "memory_backing_aware_buffer_stage_initialize"
        }
        symbol = "memory_backing_aware_buffer_stage_initialize"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s (passing along request) returned 0x%x\n"
            "%s kvtophys() for address %p returned NULL\n"
            "%s next stage output failed\n"
        }
        symbol = "memory_backing_aware_buffer_stage_outproc"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "secure_core: Unable to seek to the start of file: %d\n"
            "Failed to dump coprocessor cores\n"
            "Failed to dump userspace process cores\n"
        }
        symbol = "kern_do_coredump"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Registered coredump handler for %s\n"
        }
        symbol = "kern_register_coredump_helper_internal"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "\nBeginning coredump of %s\n"
            "coredump_init returned KERN_NODE_DOWN, skipping this core\n"
            "(%s) : coredump_init failed with %d\n"
            "(%s) : save_note_note_summary failed with %d\n"
            "(%s) : get_summary failed with %d\n"
            "Skipping coredump\n"
            "(%s) : header size not populated after coredump_get_summary\n"
            "(%s) : save_segment_descriptions failed with %d\n"
            "(%s) : save_segment_descriptions returned without all segment descriptions written, %llu of %llu remaining\n"
            "main bin spec"
            "kern ver str"
            "(%s) : coredump_save_note_description returned %d while writing binary info LC_NOTE description"
            "(%s) : kcc_coredump_save_note_descriptions failed with %d\n"
            "(%s) : save_note_descriptions returned without all note descriptions written, %llu of %llu remaining\n"
            "(%s) : save_thread_state failed with %d\n"
            "(%s) : save_thread_state returned without all thread descriptions written, %llu of %llu remaining\n"
            "(kern_coredump_routine) : failed to write zero fill padding (%llu bytes remaining) : kdp_core_output(%p, %llu, NULL) returned 0x%x\n"
            "coredump_save_segment_data failed with %d\n"
            "(kern_coredump_routine) : save_segment_data returned without all segment data written, %llu of %llu remaining\n"
            "(%s) : kcc_coredump_save_sw_vers_detail_cb failed with 0x%x\n"
            "(%s) : kcc_coredump_save_sw_vers failed with 0x%x\n"
            "(%s) : kcc_coredump_save_note_data failed with 0x%x\n"
            "(%s) : kcc_coredump_save_note_data returned without all note data written, %llu of %llu remaining\n"
            "(kern_coredump_routine) : failed to flush final core data : kdp_core_output(%p, 0, NULL) returned 0x%x\n"
            "Done\nCoredump complete of %s, dumped %llu segments (%llu bytes), %llu threads (%llu bytes) overall uncompressed file length %llu bytes."
            "\nCore dump took %llu cycles\n"
            "\n(kern_coredump_routine) : kern_dump_record_file failed with %d\n"
            " Compressed file length is %llu bytes\n"
        }
        symbol = "kern_coredump_routine"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s(0x%llx, 0x%llx, %p) : called with invalid addresses : start 0x%llx >= end 0x%llx\n"
            "%s(0x%llx, 0x%llx, %p) : coredump_save_segment_descriptions() called too many times, %llu segment descriptions already recorded\n"
            "%s(0x%llx, 0x%llx, %p) : ran out of space to save commands with %llu of %llu remaining\n"
            "%s(0x%llx, 0x%llx, %p) : failed to write segment %llu of %llu. kdp_core_output(%p, %lu, %p) returned error %d\n"
            "%s(0x%llx, 0x%llx, %p) : called with invalid addresses for 32-bit : start 0x%llx, end 0x%llx\n"
            "%s(0x%llx, 0x%llx, %p) : failed to write segment %llu of %llu : kdp_core_output(%p, %lu, %p) returned  error 0x%x\n"
        }
        symbol = "coredump_save_segment_descriptions"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s() called with invalid data_owner\n"
            "%s() called too many times, %llu note descriptions already recorded\n"
            "%s() : failed to write note %llu of %llu : kdp_core_output() returned  error 0x%x\n"
        }
        symbol = "coredump_save_note_description"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s() : found %d expected LC_THREAD (%d)\n"
            "%s() : ran out of space to save threads with %llu of %llu remaining\n"
            "%s() : failed to write thread data : kdp_core_output() returned 0x%x\n"
        }
        symbol = "coredump_save_thread_state"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s() : failed to write main bin spec structure : coredump_save_note_data() returned 0x%x\n"
            "coredump_save_sw_vers"
        }
        symbol = "coredump_save_sw_vers"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s(%p, %llu, %p) : called with invalid length %llu\n"
            "%s() : failed to write legacy bin spec version : coredump_save_note_data() returned 0x%x\n"
            "%s() : failed to write sw_vers string : coredump_save_note_data() returned 0x%x\n"
            "%s() : failed to write zero fill padding : kdp_core_output(%p, %llu, NULL) returned 0x%x\n"
        }
        symbol = "coredump_save_sw_vers_legacy"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Skipping userspace coredump, coredump list is locked\n"
            "Failed to seek to beginning of next core\n"
        }
        symbol = "kern_do_auxiliary_coredump"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "ipc_entry_dealloc() @%s:%d"
        }
        symbol = "ipc_entry_dealloc"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "corrupt hi_mod: %d, obase: %p, ocount: %d\n @%s:%d"
        }
        symbol = "ipc_entry_grow_table"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "ipc_eventlink_wait_block @%s:%d"
            "ipc_eventlink.c"
        }
        symbol = "ipc_eventlink_signal_wait_until_trap_internal"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "BUG in process %s[%d]: attempt to acquire an additional legacy external boost assertion without holding an existing legacy external assertion. (%d total, %d external, %d legacy-external)\n"
        }
        symbol = "ipc_importance_task_hold_legacy_external_assertion"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "BUG in process %s[%d]: over-released legacy external boost assertions (%d total, %d external, %d legacy-external)\n"
        }
        symbol = "ipc_importance_task_drop_legacy_external_assertion"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "disabling imp_receiver on task with pending importance boosts! @%s:%d"
        }
        symbol = "ipc_importance_task_mark_receiver"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "disabling de-nap on task with pending de-nap boosts! @%s:%d"
        }
        symbol = "ipc_importance_task_mark_denap_receiver"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "iit unexpected zero refs: %p @%s:%d"
        }
        symbol = "iit_over_release_panic"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "Importance for "
            "pid %d"
            " (%d of %d boosts) %s from "
            "donated"
            "linked"
        }
        symbol = "ipc_importance_extract_content"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Invalid ipc_control_port_options boot-arg: pinned control port cannot be enabled without immovability enforcement. Ignoring 1p pinning boot-arg."
            "Invalid ipc_control_port_options boot-arg: pinned control port cannot be enabled without immovability enforcement. Ignoring 3p pinning boot-arg."
        }
        symbol = "ipc_init"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "size too large for the fast kmsg zone (%d) @%s:%d"
            "non-zero aux size for kmsg type IKM_TYPE_KDATA_OOL. @%s:%d"
        }
        symbol = "ipc_kmsg_alloc"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "IPC kmsg header signature mismatch: kmsg=%p, hdr=%p, id=%d, sig=0x%08x (expected 0x%08x) @%s:%d"
        }
        symbol = "__ikm_signature_check_panic"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Invalid descriptor type (%p: %d) @%s:%d"
        }
        symbol = "__ipc_kmsg_descriptor_invalid_type_panic"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "Inconsistent OOL/copyout size on %p: expected %d, got %lld @%p @%s:%d"
        }
        symbol = "ipc_kmsg_copyout_descriptors"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "ipc_mqueue_send @%s:%d"
        }
        symbol = "ipc_mqueue_send_locked"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Unknown waitq type (%p/0x%x) @%s:%d"
            "ipc_mqueue_receive_on_thread: sleep walking @%s:%d"
        }
        symbol = "ipc_mqueue_receive_on_thread_and_unlock"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "ipc_object_copyin_from_kernel: strange rights @%s:%d"
        }
        symbol = "ipc_object_copyin_from_kernel"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "ipc_object_destroy: strange rights @%s:%d"
        }
        symbol = "ipc_object_destroy"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "ipc_object_destroy_dest: strange rights @%s:%d"
        }
        symbol = "ipc_object_destroy_dest"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "ipc_object_copyout_dest: strange rights @%s:%d"
        }
        symbol = "ipc_object_copyout_dest"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "ipc object %p is neither a port or a port-set @%s:%d"
        }
        symbol = "ipc_object_validate_preflight_panic"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Using inactive port %p @%s:%d"
        }
        symbol = "__ipc_port_inactive_panic"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "send right"
            "send-once right"
            "port %p %s count overflow (delta: %d) @%s:%d"
        }
        symbol = "__ipc_right_delta_overflow_panic"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "ipc_port_destroy: invalid state @%s:%d"
        }
        symbol = "ipc_port_destroy"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Trying to free an active port. port %p @%s:%d"
        }
        symbol = "ipc_port_finalize"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "found receive right in space %p for port %p owned by space %p @%s:%d"
        }
        symbol = "__ipc_port_translate_receive_panic"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "ipc_right_terminate: strange type - 0x%x @%s:%d"
        }
        symbol = "ipc_right_terminate"
        caller = "?"
    }
    new {
        args = 3
        anchors {
            "ipc_right_destroy: strange type @%s:%d"
        }
        symbol = "ipc_right_destroy"
        caller = "?"
    }
    new {
        args = 3
        anchors {
            "ipc_right_delta: strange right %d for 0x%x (%p) in space:%p @%s:%d"
        }
        symbol = "ipc_right_delta"
        caller = "?"
    }
    new {
        args = 3
        anchors {
            "ipc_right_copyin_check: strange rights @%s:%d"
        }
        symbol = "ipc_right_copyin_check_reply"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "ipc_right_copyout: Copyout kobject/kolabel as receive right @%s:%d"
            "Service port name = 0x%x doesnt match the stored launchd port name = 0x%x @%s:%d"
            "ipc_right_copyout: strange rights @%s:%d"
        }
        symbol = "ipc_right_copyout"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "voucher recipe underfow @%s:%d"
        }
        symbol = "mach_voucher_extract_all_attr_recipes"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Cannot grow ipc space beyond IVAC_ENTRIES_MAX. Some process is leaking vouchers @%s:%d"
            "Failed to grow ivac table to size %d @%s:%d"
        }
        symbol = "ivace_reference_by_value"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "mach_port_get_refs: strange rights @%s:%d"
            "mach_port.c"
        }
        symbol = "mach_port_get_refs"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "com.apple.UNCUserNotificationAgent"
            "com.apple.syncservices.uihandler"
            "com.apple.syncservices.ConflictResolver"
            "com.apple.syncservices.SyncServer"
        }
        symbol = "mach_port_construct"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "com.apple.developer.arcade-operations"
        }
        symbol = "arcade_prepare"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "com.apple.arcade.fpsd"
            "arcade: received register request"
        }
        symbol = "arcade_register_new_upcall"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "arcade_upcall_refresh(get fairplayd) @%s:%d"
            "arcade.c"
            "arcade: subscription validation upcall returned %#x"
            "arcade: unable to make subscription upcall, error %#x"
        }
        symbol = "arcade_ast"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "ast.c"
        }
        symbol = "ast_taken_user"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "backtrace: unknown packing format %d @%s:%d"
            "backtrace.c"
        }
        symbol = "backtrace_internal"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "unable to allocate initial VA: %d @%s:%d"
        }
        symbol = "__btlib_init"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "couldn\\'t find stack %p in library %p @%s:%d"
        }
        symbol = "__btlib_remove_notfound_panic"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "clock_initialize_calendar"
            "%s WARNING: UTC time is less then sys time, (%lu s %d u) UTC (%lu s %d u) sys\n"
        }
        symbol = "clock_initialize_calendar"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "clock_alarm_deliver @%s:%d"
            "clock_oldops.c"
        }
        symbol = "alarm_done"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Per-coalition ledgers"
            "couldn\\'t create coalition ledger template @%s:%d"
            "couldn\\'t create entries for coaliton ledger template @%s:%d"
            "Coalition task ledgers"
            "couldn\\'t create coalition task ledger template @%s:%d"
        }
        symbol = "init_coalition_ledgers"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "failed to adopt task %p into default coalition: %d @%s:%d"
        }
        symbol = "coalitions_adopt_init_task"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "failed to adopt task %p into corpse coalition: %d @%s:%d"
            "created task is not a member of a resource coalition @%s:%d"
        }
        symbol = "task_create_internal"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "deallocating task %p was not a member of a resource coalition @%s:%d"
        }
        symbol = "task_release_coalitions"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: could not create init %s coalition: kr:%d @%s:%d"
            "%s: could not create corpse %s coalition: kr:%d @%s:%d"
        }
        symbol = "coalitions_init"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "unknown coalition policy: %d %d @%s:%d"
        }
        symbol = "jetsam_coalition_set_policy"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "unknown coalition policy: %d @%s:%d"
        }
        symbol = "jetsam_coalition_get_policy"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "i_coal_resource_adopt_task"
        }
        symbol = "i_coal_resource_adopt_task"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "i_coal_resource_remove_task"
        }
        symbol = "i_coal_resource_remove_task"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: task %p attempting to set role %d in coalition %p to which it does not belong! @%s:%d"
            "%s: invalid role(%d) for task @%s:%d"
        }
        symbol = "i_coal_jetsam_set_taskrole"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "WARNING: more than %d pids in coalition %llu\n"
        }
        symbol = "coalition_get_sort_list"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "table %p ran out of compact IDs @%s:%d"
            "compact_id.c"
        }
        symbol = "compact_id_get_locked"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "daemon.core-analytics-events"
        }
        symbol = "telemetry_init"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Unknown CA event type: %s. @%s:%d"
            "core_analytics.c"
        }
        symbol = "core_analytics_event_size"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s:%d Assertion failed: %s"
        }
        symbol = "Assert"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "register_additional_panic_data_buffer called with buffer already registered @%s:%d"
            "register_additional_panic_data_buffer called with invalid producer_name @%s:%d"
            "register_additional_panic_data_buffer called with invalid buffer pointer @%s:%d"
            "register_additional_panic_data_buffer called with invalid length @%s:%d"
        }
        symbol = "register_additional_panic_data_buffer"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "/var/tmp/panic.trace"
        }
        symbol = "panic_trap_to_debugger"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Kernel UUID: %s\n"
            "ECC Corrections:%u\n"
            "Compressor Info: %u%% of compressed pages limit (%s) and %u%% of segments limit (%s) with %d swapfiles and %s swap space\n"
            "Debugger message: %.1200s\n"
            "Device: %s\n"
            "Not set yet"
            "Hardware Model: %s\n"
            "ECID: %02X%02X%02X%02X%02X%02X%02X%02X\n"
            "AppleHWAccess Thread: 0x%llx\n"
            "AppleHWAccess last access: no access data, this is unexpected.\n"
            "AppleHWAccess last access: %s of size %u at address 0x%llx\n"
            "Boot args: %s\n"
            "Memory ID: 0x%x\n"
            "OS release type: %.256s\n"
            "OS version: %.256s\n"
            "Kernel version: %.512s\n"
            "Fileset Kernelcache UUID: "
            "KernelCache UUID: "
            "Boot session UUID: %s\n"
            "Boot session UUID not yet initialized\n"
            "iBoot version: %.128s\n"
            "secure boot?: %s\n"
            "roots installed: %lld\n"
            "%s data: "
            "Paniclog version: %d\n"
            "Total cpu_usage: %d\n"
            "Thread task pri cpu_usage\n"
            "task->map"
            "task->map->pmap"
            "Panicked task %p: %lld pages, %d threads: "
            "Panicked task %p: %d threads: "
            "pid %d: %s"
            "unknown task"
            "Panicked thread: %p, backtrace: 0x%llx, tid: %llu\n"
            "Could not print panicked thread backtrace:frame pointer outside kernel vm.\n"
            "%.14s (%.14s)"
            "!! debugger synchronization failed, no stackshot !!\n"
            "!! panicked during stackshot, skipping panic stackshot !!\n"
            "\n** Stackshot Succeeded ** Bytes Traced %d (Uncompressed %d) **\n"
            "\n** Stackshot Succeeded ** Bytes Traced %d **\n"
            "\n** Stackshot Incomplete ** Bytes Filled %llu **\n"
            "\n!! Stackshot Failed !! Bytes Traced %d, err %d\n"
            "\n!! Stackshot Failed !!\nkcdata_memory_static_init returned %d"
            "CORE %u is offline, skipping\n"
            "CORE %u recently retired instr at 0x%016llx\n"
            "TPIDRx_ELy = {1: 0x%016llx  0: 0x%016llx  0ro: 0x%016llx }\n"
            "CORE %u PVH locks held: "
            "None\n"
            "%u - "
            "%u, %u - "
            "First lock was acquired at PC=0x%016llx, LR=0x%016llx\n"
            "CORE %u is the one that panicked. Check the full backtrace for details.\n"
            "CORE %u: PC=0x%016llx, LR=0x%016llx, FP=0x%016llx\n"
            "%s\t  Could not read LR from frame at 0x%016llx\n"
            "%s\t  Could not read FP from frame at 0x%016llx\n"
            "%s\t  lr: 0x%016llx  fp: 0x%016llx\n"
            "Backtrace continues...\n"
        }
        symbol = "SavePanicInfo"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "KernelCache slide: 0x%016lx\n"
            "KernelCache base:  %p\n"
            "Kernel text exec slide: 0x%016lx\n"
            "Kernel text exec base:  0x%016lx\n"
        }
        symbol = "panic_display_kernel_aslr"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Couldn\\'t obtain preoslog region: result = %d, preoslog_pa = %p, preoslog_size = %d\n"
        }
        symbol = "sysctl_debug_get_preoslog"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "/arm-io/wdt"
            "awl-scratch-supported"
        }
        symbol = "set_awl_scratch_exists_flag_and_subscribe_for_pm"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Nested panic detected - entry count: %d panic_caller: 0x%016lx\n"
            "Nested panic string:\n"
            "\n<end nested panic string>\n"
            "Nested panic count exceeds limit %d, machine will reset or spin\n"
            "\nNested panic stall. Stage 1 bailout. Please go to https://panic.apple.com to report this panic\n"
            "\nIn Nested panic stall. Stage 2 bailout. Please go to https://panic.apple.com to report this panic\n"
        }
        symbol = "check_and_handle_nested_panic"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "skipping local kernel core because core file could not be opened prior to panic (mode : 0x%x, error : 0x%x)\n"
            "skipping local kernel core because the PPL is not in KERNEL state\n"
            "Original panic string:\n"
        }
        symbol = "handle_debugger_trap"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "daemon.mcc_error-events"
        }
        symbol = "mcc_logging_init"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Count of %u on ecc event is too large. @%s:%d"
            "ecc_logging.c"
        }
        symbol = "ecc_log_record_event"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "cannot translate task id token from a kernel thread @%s:%d"
            "energy_perf.c"
        }
        symbol = "task_id_token_to_energy_id"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "mach_exception_raise_identity_protected() must be code64 @%s:%d"
            "mach_exception_raise_state_identity_protected() must be code64 @%s:%d"
            "bad exception behavior! @%s:%d"
        }
        symbol = "exception_deliver"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "called exception_triage when it was forbidden by the boot environment @%s:%d"
        }
        symbol = "exception_triage_thread"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "DEBUG4K thread %p task %p map %p exception %d codes 0x%llx 0x%llx @%s:%d"
            "pac_exception_triage"
            "%s: process %s[%d] hit a pac violation\n"
        }
        symbol = "exception_triage"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "attempted to set invalid special port %d @%s:%d"
            "host.c"
        }
        symbol = "kernel_set_special_port"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "com.apple.private.xpc.launchd.event-monitor"
        }
        symbol = "host_set_special_port"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "com.apple.developer.driverkit.family.hid.eventservice"
        }
        symbol = "host_get_special_port_from_user"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "com.apple.private.set-atm-diagnostic-flag"
        }
        symbol = "host_set_atm_diagnostic_flag"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "port %p is an invalid host port @%s:%d"
        }
        symbol = "host_port_copy_send"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "trying to register kobject(%d) twice @%s:%d"
        }
        symbol = "ipc_kobject_register_startup"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "the msgh_ids in mig_e[] aren't valid! @%s:%d"
            "mig subsystem %d (%p) replies are too large (%d > %d) @%s:%d"
            "message id = %d\n"
            "multiple entries with the same msgh_id @%s:%d"
            "the mig dispatch table is too small @%s:%d"
            "kroutine must have precise size %d %d @%s:%d"
            "mig_table_max_displ = %d mach_kobj_count = %d\n"
        }
        symbol = "mig_init"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "ipc_kobject_server: strange destination rights @%s:%d"
        }
        symbol = "ipc_kobject_server"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s: unexpected kotype of port %p: want %d, got %d @%s:%d"
            "ipc_kobject_enable"
        }
        symbol = "ipc_kobject_enable"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "trying to destroy an permanent port %p @%s:%d"
        }
        symbol = "ipc_kobject_destroy"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "ipc_kobject_label_check: attempted receive right copyout for labeled kobject @%s:%d"
            "subst-once port %p was consumed twice @%s:%d"
            "unexpected label: %llx @%s:%d"
        }
        symbol = "ipc_kobject_label_check"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "port %p: invalid kobject type, got %d wanted %d @%s:%d"
            "port %p: invalid kobject, got %p wanted %p @%s:%d"
        }
        symbol = "ipc_kobject_require_panic"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "unexpected make-send count: %p[%d], %d, %d @%s:%d"
        }
        symbol = "__ipc_kobject_dealloc_bad_mscount_panic"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "unexpected send right count: %p[%d], %d @%s:%d"
        }
        symbol = "__ipc_kobject_dealloc_bad_srights_panic"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "mach_msg_rpc_from_kernel @%s:%d"
            "kernel_mach_msg_rpc @%s:%d"
        }
        symbol = "kernel_mach_msg_rpc_common"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "mach_task_self() name changed @%s:%d"
        }
        symbol = "task_self_trap"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "userspace has control access to a kernel map %p through task %p @%s:%d"
        }
        symbol = "convert_port_to_map_with_flavor"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "strange thread flavor @%s:%d"
        }
        symbol = "convert_port_to_thread_with_flavor_locked"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "com.apple.private.set-exception-port"
            "Allowing set_exception_ports from [%s] on [%s] for entitled process/debugger\n"
            "com.apple.security.only-one-exception-port"
            "Disallowing set_exception_ports from [%s] on [%s] due to only_one_exception_port policy\n"
        }
        symbol = "set_exception_ports_validation"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s.%u"
        }
        symbol = "kalloc_zone_init"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "kalloc_type_view_copy: Insufficient space in scratch buffer @%s:%d"
        }
        symbol = "kalloc_type_view_copy"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "__text"
            "kalloc_type_view_parse: couldn\\'t find kext @ offset:%lx @%s:%d"
            "kalloc_type_view_parse: No support for non-split seg KCs @%s:%d"
        }
        symbol = "kalloc_type_view_parse"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "kalloc_type_apply_policy: assigned %u zones wasted %u zones\n"
        }
        symbol = "kalloc_type_distribute_budget"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "kalloc.type%u.%zu"
            "kalloc.%zu"
        }
        symbol = "kalloc_type_create_zone_for_size"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "kt_var_heaps is too small @%s:%d"
        }
        symbol = "kalloc_type_view_init_var"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "kalloc_heap_startup_init: invalid KHEAP_ID: %d @%s:%d"
        }
        symbol = "kheap_startup_init"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "KT_NOSHARED used w/o private accounting for view %s @%s:%d"
        }
        symbol = "kalloc_type_assign_zone_fixed"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Size\ttotal_sig\tunique_signatures\tzones\tzones_sig\tzones_type\n"
            "%u\t%u\t%u\t%u\t%u\t%u\n"
        }
        symbol = "kalloc_type_create_zones_fixed"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "kalloc_data_require failed: address %p in [%s%s] @%s:%d"
            "kalloc_data_require failed: address %p in [%s%s], size too large %zd > %zd @%s:%d"
            "kalloc_data_require failed: address %p not in zone native map @%s:%d"
        }
        symbol = "kalloc_data_require_panic"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "kfree: addr %p trying to free with nonsensical size %zd @%s:%d"
        }
        symbol = "kfree_size_invalid_panic"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "kfree: addr %p, size %zd (offs:%zd) found in zone '%s%s' with elem_size %zd @%s:%d"
            "kfree: addr %p, size %zd (offs:%zd) not found in any zone @%s:%d"
        }
        symbol = "kfree_size_confusion_panic"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "kfree: addr %p found in kalloc type zone '%s'but being freed to %s heap @%s:%d"
            "kfree: addr %p, size %zd found in regular zone '%s%s' @%s:%d"
            "kfree: addr %p, size %zd found in heap %s* instead of %s* @%s:%d"
        }
        symbol = "kfree_heap_confusion_panic"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "krealloc: addr %p trying to free with nonsensical size %zd @%s:%d"
        }
        symbol = "krealloc_size_invalid_panic"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "kern_apfs_reflock_t %p was already destroyed @%s:%d"
            "kern_apfs_reflock_t %p was allocated. kern_apfs_reflock_free should be called instead of kern_apfs_reflock_destroy @%s:%d"
            "kern_apfs_reflock_t %p: destroying a reflock currently locked by ctid %d @%s:%d"
            "kern_apfs_reflock_t %p: destroying a reflock with threads currently waiting or in the process of waiting @%s:%d"
        }
        symbol = "kern_apfs_reflock_destroy"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "kern_apfs_reflock_t %p was not allocated. kern_apfs_reflock_destroy should be called instead of kern_apfs_reflock_free @%s:%d"
            "kern_apfs_reflock_t %p is already in the process of being freed @%s:%d"
            "kern_apfs_reflock_t %p: freeing a reflock currently locked by ctid %d @%s:%d"
        }
        symbol = "kern_apfs_reflock_free"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Cannot use KERN_APFS_REFLOCK_IN_FORCE and KERN_APFS_REFLOCK_IN_LOCK_IF_FIRST together @%s:%d"
            "kern_apfs_reflock: too many refs for %p thread %p @%s:%d"
        }
        symbol = "kern_apfs_reflock_try_get_ref"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Cannot use KERN_APFS_REFLOCK_IN_FORCE and KERN_APFS_REFLOCK_IN_LOCK_IF_LAST together @%s:%d"
            "kern_apfs_reflock: over releasing reflock %p thread %p @%s:%d"
        }
        symbol = "kern_apfs_reflock_try_put_ref"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Trying to lock a reflock owned by the same thread %p, reflock %p @%s:%d"
        }
        symbol = "kern_apfs_reflock_try_lock"
        caller = "?"
    }
    new {
        args = 3
        anchors {
            "kern_apfs_reflock: kern_apfs_rl_waiters are 0 when trying to wait reflock %p thread %p. Probably a try* function with a positive will_wait wasn't called before waiting. @%s:%d"
            "Trying to wait on a reflock owned by the same thread %p, reflock %p @%s:%d"
        }
        symbol = "kern_apfs_reflock_wait_for_unlock"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Unlocking swiref_t %p from thread ctid %u owned by ctid %u @%s:%d"
        }
        symbol = "kern_apfs_reflock_unlock"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "Attempt to create a ledger template with more than MAX_LEDGER_ENTRIES. MAX_LEDGER_ENTRIES=%lu, old_cnt=%u, new_cnt=%u\n @%s:%d"
        }
        symbol = "ledger_entry_add_with_flags"
        caller = "?"
    }
    new {
        args = 3
        anchors {
            "ledger_entry_check_new_balance(%p,%d): negative ledger %p credit:%lld debit:0 balance:%lld @%s:%d"
            "ledger_entry_check_new_balance(%p,%d): negative ledger %p credit:%lld debit:%lld balance:%lld @%s:%d"
        }
        symbol = "ledger_entry_check_new_balance"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Compatibility APIs"
        }
        symbol = "lck_group_init"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "lck_debug_state: feature %d imbalance @%s:%d"
            "lock_group.c"
        }
        symbol = "lck_grp_disable_feature"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "Mutex to destroy still has waiters: %p: <0x%06x 0x%02x 0x%08x 0x%08x/%p 0x%04x 0x%04x> @%s:%d"
        }
        symbol = "lck_mtx_destroy"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "lck_mtx_assert(): invalid arg (%u) @%s:%d"
        }
        symbol = "lck_mtx_assert"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Invalid/destroyed mutex %p: <0x%06x 0x%02x 0x%08x 0x%08x/%p 0x%04x 0x%04x> @%s:%d"
        }
        symbol = "__lck_mtx_invalid_panic"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Mutex interlock[%p] timeout after %llu ticks; current owner: %p, <0x%06x 0x%02x 0x%08x 0x%08x 0x%04x 0x%04x>, start time: %llu, now: %llu, timeout: %llu @%s:%d"
        }
        symbol = "lck_mtx_ilk_timeout_panic"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Mutex %p is held as a full-mutex (spin-always lock attempted) @%s:%d"
        }
        symbol = "__lck_mtx_lock_is_sleepable_panic"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Mutex %p is unexpectedly not owned by thread %p @%s:%d"
        }
        symbol = "__lck_mtx_not_owned_panic"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Mutex %p is unexpectedly owned by thread %p @%s:%d"
        }
        symbol = "__lck_mtx_owned_panic"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Invalid/destroyed ptr spinlock %p: <%p %d 0x%04x> @%s:%d"
        }
        symbol = "__hw_lck_ptr_invalid_panic"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Ptr spinlock[%p] timeout after %llu ticks; ptr_value: %p, mcs_tail: 0x%04x, start time: %llu, now: %llu, timeout: %llu @%s:%d"
        }
        symbol = "hw_lck_ptr_timeout_panic"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "Releasing non-exclusive RW lock without a reader refcount! @%s:%d"
        }
        symbol = "lck_rw_done"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "lck_rw_unlock(): Invalid RW lock type: %d @%s:%d"
        }
        symbol = "lck_rw_unlock"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s was called with an invalid blocking type @%s:%d"
            "kdp_rwlck_find_owner"
        }
        symbol = "kdp_rwlck_find_owner"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "rw lock count underflow for thread %p @%s:%d"
        }
        symbol = "__lck_rw_lock_count_dec_panic"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Invalid HW ticket lock %p <0x%08x> @%s:%d"
        }
        symbol = "__hw_lck_ticket_invalid_panic"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Invalid ticket lock %p <0x%08x 0x%08x 0x%08x 0x%08x> @%s:%d"
        }
        symbol = "__lck_ticket_invalid_panic"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Ticket spinlock[%p] timeout after %llu ticks; cticket: 0x%x, nticket: 0x%x, waiting for 0x%x, current owner: %p (on CPU %d), start time: %llu, now: %llu, timeout: %llu @%s:%d"
        }
        symbol = "lck_ticket_timeout_panic"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Ticket spinlock[%p] timeout after %llu ticks; cticket: 0x%x, nticket: 0x%x, valid: %d, start time: %llu, now: %llu, timeout: %llu @%s:%d"
            "Ticket spinlock[%p] timeout after %llu ticks; cticket: 0x%x, nticket: 0x%x, waiting for 0x%x, valid: %d, start time: %llu, now: %llu, timeout: %llu @%s:%d"
        }
        symbol = "hw_lck_ticket_timeout_panic"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Ticket lock %p is unexpectedly not owned by thread %p @%s:%d"
        }
        symbol = "__lck_ticket_not_owned_panic"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Ticket lock %p is unexpectedly owned by thread %p @%s:%d"
        }
        symbol = "__lck_ticket_owned_panic"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Spinlock[%p] timeout after %llu ticks; current owner: %p, start time: %llu, now: %llu, timeout: %llu @%s:%d"
            "Spinlock[%p] timeout after %llu ticks; current owner: %p (on cpu %d), start time: %llu, now: %llu, timeout: %llu @%s:%d"
        }
        symbol = "hw_spin_timeout_panic"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Spinlock[%p] timeout after %llu ticks; current value: 0x%08x, start time: %llu, now: %llu, timeout: %llu @%s:%d"
        }
        symbol = "hw_lock_bit_timeout_panic"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "wait_while_equals32[%p] timeout after %llu ticks; current value: 0x%08x, start time: %llu, now: %llu, timeout: %llu @%s:%d"
        }
        symbol = "hw_wait_while_equals32_panic"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "wait_while_equals64[%p] timeout after %llu ticks; current value: 0x%016llx, start time: %llu, now: %llu, timeout: %llu @%s:%d"
        }
        symbol = "hw_wait_while_equals64_panic"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "hwlock: thread %p is trying to lock %p recursively @%s:%d"
        }
        symbol = "hw_lock_lock_contended"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Attempt to take no-preempt lock %p in preemptible context @%s:%d"
        }
        symbol = "__lck_require_preemption_disabled_panic"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Gate used is invalid. gate %p data %lx turnstile %p refs %d flags %x  @%s:%d"
        }
        symbol = "gate_verify_tag_panic"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Gate used was destroyed. gate %p data %lx turnstile %p refs %d flags %x @%s:%d"
        }
        symbol = "gate_verify_destroy_panic"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Trying to destroy a gate that was allocated by gate_alloc_init(). gate_free() should be used instead, gate %p thread %p @%s:%d"
        }
        symbol = "gate_destroy_panic"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Trying to destroy a gate owned by %p. Gate %p @%s:%d"
        }
        symbol = "gate_destroy_owned_panic"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Trying to destroy a gate with waiters. Gate %p data %lx turnstile %p @%s:%d"
        }
        symbol = "gate_destroy_waiter_panic"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Trying to free a gate that was not allocated by gate_alloc_init(), gate %p thread %p @%s:%d"
        }
        symbol = "gate_free_panic"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Trying to close a gate already closed gate %p holder %p current_thread %p @%s:%d"
        }
        symbol = "gate_already_owned_panic"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Trying to open a gate %p owned by %p from current_thread %p @%s:%d"
            "Trying to handoff a gate %p owned by %p from current_thread %p @%s:%d"
        }
        symbol = "gate_not_owned_panic"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Trying to wait on a not closed gate %p from current_thread %p @%s:%d"
            "Trying to steal a not closed gate %p from current_thread %p @%s:%d"
        }
        symbol = "gate_not_closed_panic"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Too many refs taken on gate. gate %p data %lx turnstile %p refs %d flags %x @%s:%d"
        }
        symbol = "gate_too_many_refs_panic"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "invalid %s flag %d @%s:%d"
            "gate_assert"
        }
        symbol = "gate_assert"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "Invalid size %d for ml_io_read(%p) @%s:%d"
            "Read from IO vaddr 0x%lx paddr 0x%lx took %llu ns, result: 0x%llx (start: %llu, end: %llu), ceiling: %llu @%s:%d"
        }
        symbol = "ml_io_read"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "Invalid size %d for ml_io_write(%p, 0x%llx) @%s:%d"
            "Write to IO vaddr %p paddr %p val 0x%llx took %llu ns, (start: %llu, end: %llu), ceiling: %llu @%s:%d"
        }
        symbol = "ml_io_write"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "can't allocate cpu_callback_chain_elem @%s:%d"
        }
        symbol = "cpu_event_register_callback"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Unfortunately, cpu_event_unregister_callback is unimplemented. @%s:%d"
        }
        symbol = "__ZN11IOPCIBridge19setDevicePowerStateEP11IOPCIDevicem.cold.1"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "ml-timeout-"
            "/machine-timeouts"
            "/chosen/machine-timeouts"
            "%s: unexpected machine timeout data_size %u for /machine-timeouts/%s @%s:%d"
            "%s: unexpected machine timeout data_size %u for /chosen/machine-timeouts/%s @%s:%d"
            "%s: unexpected machine timeout data_size %u for /machine-timeouts/%s-scale @%s:%d"
            "%s: unexpected machine timeout data_size %u for /chosen/machine-timeouts/%s-scale @%s:%d"
            "%s: unexpected machine timeout data_size %u for /machine-timeouts/global-scale @%s:%d"
            "%s: unexpected machine timeout data_size %u for /chosen/machine-timeouts/global-scale @%s:%d"
            "ml-timeout-global-scale"
        }
        symbol = "machine_timeout_init_with_suffix"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "daemon.deferred-deallocation"
            "thread_deallocate_daemon_init: creating daemon failed (%d) @%s:%d"
        }
        symbol = "thread_deallocate_daemon_init"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "mpsc_queue[%p]: use after cancelation @%s:%d"
        }
        symbol = "_mpsc_daemon_queue_enqueue"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Waiting for DSMOS...\n"
        }
        symbol = "dsmos_page_transform"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "0123456789abcdef0123456789ABCDEF"
        }
        symbol = "__doprnt_0"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Unexpected boot pset cluster type %d @%s:%d"
        }
        symbol = "processor_bootstrap"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "processor_boot() missing for cpu %d @%s:%d"
            "cpu %d failed to %s, waited %d seconds\n @%s:%d"
            "%s>cpu %d still in shutdown @%s:%d"
            "%s>cpu %d not online @%s:%d"
        }
        symbol = "processor_wait_for_start"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "processor %d already booted @%s:%d"
        }
        symbol = "processor_boot"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "recount: unexpected rollup request from %d to %d @%s:%d"
        }
        symbol = "recount_rollup"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "sched_clutch_bucket_group_interactive_pri"
        }
        symbol = "sched_edge_init"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "Unexpected sched_bucket passed to sched_edge_cluster_cumulative_count_decr() @%s:%d"
            "sched_clutch thread count underflowed! @%s:%d"
        }
        symbol = "sched_clutch_thread_remove"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Unexpected sched_bucket passed to sched_edge_cluster_cumulative_count_incr() @%s:%d"
            "sched_clutch thread count overflowed! @%s:%d"
        }
        symbol = "sched_clutch_processor_enqueue"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Scheduler: Default of %s\n"
            "sched_pri_decay_limit"
            "kern.sched_pri_decay_limit"
            "Setting scheduler priority decay band limit %d\n"
            "sched_debug"
            "Scheduler: Debug flags 0x%08x\n"
        }
        symbol = "sched_init"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "standard timeslicing quantum is %d us\n"
            "standard background quantum is %d us\n"
            "sched_decay_penalty"
            "Overriding scheduler decay penalty %u\n"
            "sched_decay_usage_age_factor"
            "Overriding scheduler decay usage age factor %u\n"
        }
        symbol = "sched_timeshare_init"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "Invalid attempt to wait while running the idle thread @%s:%d"
        }
        symbol = "thread_mark_wait_locked"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "assert_wait"
        }
        symbol = "assert_wait"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "assert_wait_timeout"
        }
        symbol = "assert_wait_timeout"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "assert_wait_timeout_with_leeway"
        }
        symbol = "assert_wait_timeout_with_leeway"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "assert_wait_deadline"
        }
        symbol = "assert_wait_deadline"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "assert_wait_deadline_with_leeway"
        }
        symbol = "assert_wait_deadline_with_leeway"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "thread_wakeup_prim"
        }
        symbol = "thread_wakeup_prim"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "Non-monotonic time: dispatch at 0x%llx, runnable at 0x%llx @%s:%d"
        }
        symbol = "thread_dispatch"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Unrecognized scheduler IPI event type %d @%s:%d"
        }
        symbol = "sched_ipi_policy"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "idle_thread_create failed: %d @%s:%d"
            "idle #%d"
        }
        symbol = "idle_thread_create"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "sched_startup @%s:%d"
        }
        symbol = "sched_startup"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "sched_maintenance_thread"
        }
        symbol = "sched_init_thread"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "sched_cpu_init_completed called twice! %d @%s:%d"
            "failed to create sched_update_powered_cores thread @%s:%d"
            "sched_update_powered_cores"
        }
        symbol = "sched_cpu_init_completed"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Attempting to sleep before all CPUS are registered @%s:%d"
        }
        symbol = "sched_override_available_cores_for_sleep"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "unknown mode %d @%s:%d"
        }
        symbol = "sched_processor_change_mode_locked"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "shutting down the last available core! online: 0x%llx rec: 0x%llxx @%s:%d"
        }
        symbol = "sched_mark_processor_offline"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "thread_invoke: preemption_level %d, possible cause: %s @%s:%d"
            "unlocking an unlocked mutex or spinlock"
            "blocking while holding a spinlock, or within interrupt context"
            "Non-monotonic time: invoke at 0x%llx, runnable at 0x%llx @%s:%d"
            "Invalid attempt to context switch an offline processor @%s:%d"
        }
        symbol = "thread_invoke"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "no last resort cpu found! @%s:%d"
        }
        symbol = "thread_setrun"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s>calling sched_update_powered_cores to suspend powerdown\n"
            "suspend_cluster_powerdown_locked"
        }
        symbol = "suspend_cluster_powerdown_locked"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s>calling sched_update_powered_cores to resume powerdown\n"
            "resume_cluster_powerdown_locked"
            "resume_cluster_powerdown() called with pcs.pcs_powerdown_suspend_count=%d\n @%s:%d"
        }
        symbol = "resume_cluster_powerdown_locked"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "recommended core failsafe kicked in for %lld ms likely due to %s[%d] thread 0x%llx spending %lld ms on cpu at realtime priority - new recommendation: 0x%llx -> 0x%llx\n"
        }
        symbol = "sched_timeshare_maintenance_continue"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s> no last resort cpu found: 0x%llx 0x%llx @%s:%d"
            "sched_update_recommended_cores_locked"
        }
        symbol = "sched_update_recommended_cores_locked"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Invalid SFI class 0x%x @%s:%d"
            "Duplicate SFI registration for class 0x%x @%s:%d"
        }
        symbol = "sfi_class_register"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Gap in registered SFI classes @%s:%d"
        }
        symbol = "sfi_init"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Invalid queue linkage: elt:%p next:%p next->prev:%p @%s:%d"
        }
        symbol = "__smr_linkage_invalid"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Invalid queue tail (element past end): elt:%p elt->next:%p @%s:%d"
            "Invalid queue tail (early end): elt:%p tail:%p @%s:%d"
        }
        symbol = "__smr_tail_invalid"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Unable to find item %p (linkage %p) in %p (traits %p) @%s:%d"
        }
        symbol = "__smr_shash_missing_elt_panic"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "kernel_stack_pages"
            "stack_init: stack size %p not a multiple of page size %d @%s:%d"
            "stack.c"
        }
        symbol = "stack_init"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Section %s,%s missing @%s:%d"
            "Section %s,%s has invalid size @%s:%d"
        }
        symbol = "kernel_startup_bootstrap"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "chosen"
            "unexpected tunable size %u in DT entry %s/%s/%s @%s:%d"
        }
        symbol = "kernel_startup_tunable_dt_init"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s[%d, rank %d]: %p(%p)\n"
            "kernel_startup_initialize_upto"
            "%s: reached phase %d\n"
        }
        symbol = "kernel_startup_initialize_upto"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "kern.serverperfmode"
        }
        symbol = "scale_setup"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "load_context @%s:%d"
        }
        symbol = "load_context"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "NULL continuation passed to %s @%s:%d"
            "thread_handoff_parameter"
            "syscall_subr.c"
        }
        symbol = "thread_handoff_parameter"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "kern_invalid mach trap"
        }
        symbol = "kern_invalid"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Warning: max_task_pmem %d below minimum.\n"
            "Limiting task physical memory footprint to %d MB\n"
            "Limiting task physical memory warning to %d%%\n"
            "hwm_user_cores"
            "task_wakeups_monitor_rate"
            "task_wakeups_monitor_interval"
            "task_wakeups_monitor_ustackshots_trigger_pct"
            "task_iomon_limit_mb"
            "task_iomon_interval_secs"
            "io_telemetry_limit"
            "task_init @%s:%d"
        }
        symbol = "task_init"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Per-task ledger"
            "couldn\\'t create task ledger template @%s:%d"
            "tkm_private"
            "tkm_shared"
            "phys_mem"
            "wired_mem"
            "conclave_mem"
            "internal"
            "iokit_mapped"
            "mappings"
            "alternate_accounting"
            "alternate_accounting_compressed"
            "page_table"
            "phys_footprint"
            "internal_compressed"
            "reusable"
            "external"
            "purgeable_volatile"
            "purgeable_nonvolatile"
            "purgeable_volatile_compress"
            "purgeable_nonvolatile_compress"
            "tagged_nofootprint"
            "tagged_footprint"
            "tagged_nofootprint_compressed"
            "tagged_footprint_compressed"
            "network_volatile"
            "network_nonvolatile"
            "network_volatile_compressed"
            "network_nonvolatile_compressed"
            "media_nofootprint"
            "media_footprint"
            "media_nofootprint_compressed"
            "media_footprint_compressed"
            "graphics_nofootprint"
            "graphics_footprint"
            "graphics_nofootprint_compressed"
            "graphics_footprint_compressed"
            "neural_nofootprint"
            "neural_footprint"
            "neural_nofootprint_compressed"
            "neural_footprint_compressed"
            "neural_nofootprint_total"
            "platform_idle_wakeups"
            "interrupt_wakeups"
            "couldn\\'t create entries for task ledger template for SFI class 0x%x @%s:%d"
            "cpu_time_billed_to_me"
            "cpu_time_billed_to_others"
            "physical_writes"
            "logical_writes_to_external"
            "fs_metadata_writes"
            "energy_billed_to_me"
            "energy_billed_to_others"
            "memorystatus_dirty_time"
            "swapins"
            "couldn\\'t create entries for task ledger template @%s:%d"
        }
        symbol = "init_task_ledgers"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "task_deallocate(%p): volatile_objects=%d nonvolatile_objects=%d owned=%d\n @%s:%d"
        }
        symbol = "task_deallocate_internal"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "Failed to send exception EXC_CORPSE_NOTIFY. error code: %d for pid %d\n"
        }
        symbol = "task_deliver_crash_notification"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "warning: %s(%d) failed to copyout suspension token for pid %d with error: %d\n"
        }
        symbol = "task_suspend"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "warning: %s(%d) performed out-of-band resume on pid %d\n"
        }
        symbol = "task_resume"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "couldn\\'t take coredump of %s[%d]: %d\n"
            "coredump of %s[%d] taken in %d secs %d microsecs\n"
            "process %s[%d] crossed memory high watermark (%d MB); EXC_RESOURCE suppressed by a boot-arg.\n"
            "process %s [%d] crossed memory %s (%d MB); EXC_RESOURCE \n"
            "high watermark"
            "diagnostics limit"
            "process %s[%d] crossed memory high watermark (%d MB); EXC_RESOURCE suppressed due to audio playback.\n"
        }
        symbol = "PROC_CROSSED_HIGH_WATERMARK__SEND_EXC_RESOURCE_AND_SUSPEND"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "FATAL "
            "send_resource_violation(CPU wakes, ...): error %#x\n"
            "process %s[%d] caught waking the CPU %llu times over ~%llu seconds, averaging %llu wakes / second and violating a %slimit of %llu wakes over %llu seconds.\n"
        }
        symbol = "SENDING_NOTIFICATION__THIS_PROCESS_IS_CAUSING_TOO_MANY_WAKEUPS"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "send_resource_violation(disk_writes, ...): error %#x\n"
            "process [%d] caught causing excessive I/O (flavor: %d). Task I/O: %lld MB. [Limit : %lld MB per %lld secs]\n"
        }
        symbol = "SENDING_NOTIFICATION__THIS_PROCESS_IS_CAUSING_TOO_MUCH_IO"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "com.apple.private.skip.pac.exception"
            "com.apple.private.pac.exception"
        }
        symbol = "task_set_pac_exception_fatal_flag"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "com.apple.security.fatal-exceptions"
        }
        symbol = "task_set_jit_exception_fatal_flag"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "proc_ro->task backref mismatch: t=%p, ro=%p, proc_ro_task(ro)=%p @%s:%d"
        }
        symbol = "panic_proc_ro_task_backref_mismatch"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "unknown tier %d @%s:%d"
        }
        symbol = "proc_tier_to_iopol"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "max_cpumon_percentage"
            "kern.max_cpumon_percentage"
            "max_cpumon_interval"
            "kern.max_cpumon_interval"
            "task_policy_suppression_flags"
        }
        symbol = "proc_init_cpumon_params"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "Attempting to set task policy on kernel_task @%s:%d"
        }
        symbol = "task_policy_update_internal_locked"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "unknown task policy: %d %d %d %d @%s:%d"
        }
        symbol = "proc_set_task_policy_locked"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "process %s[%d] denied attempt to escape CPU monitor (missing required entitlement).\n"
        }
        symbol = "proc_set_task_ruse_cpu"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "threads"
        }
        symbol = "thread_zone_startup"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "thread_corpse_continue @%s:%d"
        }
        symbol = "thread_corpse_continue"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Thread %p terminating with vm_faults disabled. @%s:%d"
            "depress timer failed to inactivate!thread: %p depress_timer_active: %d @%s:%d"
            "wait timer failed to inactivate!thread: %p, wait_timer_active: %d, wait_timer_armed: %d @%s:%d"
        }
        symbol = "thread_terminate_self"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "daemon.thread-stack"
            "thread_daemon_init: thread_stack_daemon @%s:%d"
            "daemon.thread-exception"
            "thread_daemon_init: thread_exception_daemon @%s:%d"
            "daemon.thread-backtrace"
            "thread_daemon_init: thread_backtrace_daemon @%s:%d"
        }
        symbol = "thread_daemon_init"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "guard_exc_info %llx %llx @%s:%d"
        }
        symbol = "guard_ast"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "process %s[%d] thread %llu caught burning CPU! It used more than %d%% CPU over %u seconds\n"
            "  (actual recent usage: %d%% over ~%llu seconds)\n"
            "  Thread lifetime cpu usage %d.%06ds, (%d.%06d user, %d.%06d sys)\n"
            "  Ledger balance: %lld; mabs credit: %lld; mabs debit: %lld\n"
            "  mabs limit: %llu; mabs period: %llu ns; last refill: %llu ns%s.\n"
            " [fatal violation]"
            "send_resource_violation(CPU usage, ...): error %#x\n"
        }
        symbol = "SENDING_NOTIFICATION__THIS_THREAD_IS_CONSUMING_TOO_MUCH_CPU"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "CPU usage monitor activated, but blocking thread limit exists @%s:%d"
        }
        symbol = "thread_set_cpulimit"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "thread_terminate_continue @%s:%d"
        }
        symbol = "thread_terminate_continue"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "thread_deallocate: thread not properly terminated @%s:%d"
        }
        symbol = "thread_deallocate_complete"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Per-thread ledger"
            "couldn\\'t create thread ledger template @%s:%d"
            "couldn\\'t create cpu_time entry for thread ledger template @%s:%d"
        }
        symbol = "thread_init"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "idle thread calling thread_terminate! @%s:%d"
            "thread_terminate @%s:%d"
        }
        symbol = "thread_terminate"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "unsafe act_set_kperf operation @%s:%d"
        }
        symbol = "act_set_kperf"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "thread_call_initialize failed (%d) @%s:%d"
        }
        symbol = "thread_call_initialize"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "trying to cancel NULL func @%s:%d"
        }
        symbol = "thread_call_func_cancel"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Invalid thread call qos value: %d @%s:%d"
        }
        symbol = "thread_call_allocate_with_qos"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "(%p %p) Refcount negative: %d @%s:%d"
            "(%p %p) freeing an uninitialized call @%s:%d"
            "(%p %p) freeing a running once call @%s:%d"
        }
        symbol = "thread_call_free"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "(%p %p) thread_call_cancel_wait: can't wait on thread call whose storage I don't own @%s:%d"
            "(%p %p) unsafe thread_call_cancel_wait @%s:%d"
            "thread_call_cancel_wait: deadlock waiting on self from inside call: %p to function %p @%s:%d"
        }
        symbol = "thread_call_cancel_wait"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "invalid timer flavor: %d @%s:%d"
        }
        symbol = "thread_call_delayed_timer"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Unable to wake up idle thread for termination (%d) @%s:%d"
        }
        symbol = "thread_call_dealloc_timer"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "_internal_call_allocate: thread_call_internal_queue empty @%s:%d"
        }
        symbol = "thread_call_enter_delayed_internal"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "thread_call_daemon"
        }
        symbol = "thread_call_daemon"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "cannot create new thread call thread %d @%s:%d"
            "thread call %s #%d"
        }
        symbol = "thread_call_daemon_continue"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "thread_terminate() returned? @%s:%d"
            "(%p %p) call on pending_queue from wrong group %p @%s:%d"
            "pending call with NULL func: %p @%s:%d"
            "thread_call_thread: preemption_level %d, last callout %p(%p, %p) @%s:%d"
            "kcall worker unable to assert wait %d @%s:%d"
        }
        symbol = "thread_call_thread"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "(%p %p) call finishing from wrong group: %p @%s:%d"
            "(%p %p) thread_call_finish: detected over-released thread call @%s:%d"
        }
        symbol = "thread_call_finish"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "thread_groups"
            "io storage"
            "perf_controller"
        }
        symbol = "thread_group_init"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "thread_group.c"
            "sched_perfcontrol_thread_group_recommend() not supported on the Edge scheduler @%s:%d"
        }
        symbol = "__sigwait_nocancel.cold.2"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "unknown effective QoS: %d @%s:%d"
            "unknown requested QoS: %d @%s:%d"
        }
        symbol = "thread_update_qos_cpu_time_locked"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "Unrecognized QoS %d @%s:%d"
        }
        symbol = "thread_recompute_priority"
        caller = "?"
    }
    new {
        args = 3
        anchors {
            "unknown task policy: %d %d %d @%s:%d"
        }
        symbol = "proc_set_thread_policy_spinlocked"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "timer_longterm_update_master() on non-boot cpu @%s:%d"
            "timer_call.c"
        }
        symbol = "timer_longterm_update"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Longterm timer threshold: %llu ms\n"
        }
        symbol = "timer_call_init"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Needs implementation for turnstile_recompute_priority @%s:%d"
        }
        symbol = "turnstile_recompute_priority_locked"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "ts_htable_buckets"
            "Turnstiles hash table memory allocation failed! @%s:%d"
        }
        symbol = "turnstiles_init"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "Missing type in flags (%x) for inheritor (%p) @%s:%d"
        }
        symbol = "turnstile_update_inheritor"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Inheritor flags not passed in turnstile_update_inheritor @%s:%d"
        }
        symbol = "turnstile_update_inheritor_priority_chain"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "turnstile_is_send_turnstile() called outside of kernel debugger context @%s:%d"
        }
        symbol = "kdp_turnstile_traverse_inheritor_chain"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Couldn\\'t allocate send right for ux_handler_port! @%s:%d"
            "host_set_exception_ports failed to set ux_handler! %d @%s:%d"
        }
        symbol = "ux_handler_setup"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "wqsize"
        }
        symbol = "waitq_bootstrap"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "thread already waiting on %p @%s:%d"
            "Trying to assert_wait on a turnstile proxy that hasn't been donated one (waitq: %p) @%s:%d"
        }
        symbol = "waitq_assert_wait64_locked"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Trying to clear_wait on a turnstile proxy that hasn't been donated one (waitq: %p) @%s:%d"
        }
        symbol = "waitq_pull_thread_locked"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "waitq(%p) lock timeout after %llu ticks; cpu=%d, cticket: 0x%x, nticket: 0x%x, waiting for 0x%x, start time: %llu, now: %llu, timeout: %llu @%s:%d"
        }
        symbol = "waitq_timeout_handler"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "WI%lld (pid %d)"
        }
        symbol = "kern_work_interval_create"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "zone %p isn't in the zone_array @%s:%d"
        }
        symbol = "zone_invalid_panic"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "zone_submap_alloc_sequestered_va() of %u pages failed @%s:%d"
        }
        symbol = "zone_fill_initially"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Zone %s should be empty upon userspace reboot. Actual size: %lu. @%s:%d"
        }
        symbol = "zone_userspace_reboot_checks"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "kalloc.%d"
        }
        symbol = "mach_memory_info_sample"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "zone_create: element size too large: %zd @%s:%d"
            "ZC_NOCACHING"
            "ZC_NOGC"
            "ZC_DATA"
            "Fragmentation greater than 10%% with elem size %d zone %s%s @%s:%d"
            "ZC_PGZ_USE_GUARDS"
            "zone_create: invalid desired zone ID %d for %s @%s:%d"
            "zone_create: ID %d (%s) must be permanent @%s:%d"
            "zone_create: creating zone ID %d (%s) twice @%s:%d"
        }
        symbol = "zone_create_ext"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "zdestroy: Zone %s%s isn't empty at zdestroy() time @%s:%d"
        }
        symbol = "zdestroy"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "zc_mag_size"
        }
        symbol = "zone_bootstrap"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "vm_page"
            "ksubmap[%s]: failed to make first entry (%d) @%s:%d"
            "ksubmap[%s]: failed to make last entry (%d) @%s:%d"
        }
        symbol = "zone_submap_init"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "zsize"
            "NOTE: zonemap size reduced from 0x%lx to 0x%lx\n"
        }
        symbol = "zone_set_map_sizes"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "vm.permanent"
            "vm.permanent.percpu"
            "zcc_magazine_zone"
        }
        symbol = "zone_init"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "zone bound checks: address %p is a per-cpu allocation @%s:%d"
            "zone bound checks: buffer %p of length %zd overflows object %p of size %zd in zone %p[%s%s] @%s:%d"
        }
        symbol = "zone_element_bounds_check_panic"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "zone_require failed: address not in a zone (addr: %p) @%s:%d"
            "zone_require failed: invalid zone index %d (addr: %p, expected: %s%s) @%s:%d"
            "zone_require failed: address in unexpected zone id %d (%s%s) (addr: %p, expected: %s%s) @%s:%d"
        }
        symbol = "zone_require_panic"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "addr %p being freed to zone %s%s%s, isn't from zone map @%s:%d"
            "metadata %p corresponding to addr %p being freed to zone %s%s%s, is marked as secondary per cpu page @%s:%d"
            "metadata %p corresponding to addr %p being freed to zone %s%s%s, has chunk len greater than max @%s:%d"
            "addr %p being freed to zone %s%s%s, isn't aligned to zone element size @%s:%d"
        }
        symbol = "zone_invalid_element_panic"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%p expected in zone %s%s[%d], but metadata has invalid zidx: %d @%s:%d"
            "%p not in the expected zone %s%s[%d], but found in %s%s[%d] @%s:%d"
        }
        symbol = "zone_page_metadata_index_confusion_panic"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "zone element pointer validation failed (addr: %p, zone %s%s) @%s:%d"
        }
        symbol = "zone_invalid_element_addr_panic"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "zone bits allocator freelist is corrupt (%p <-> %p) @%s:%d"
        }
        symbol = "zba_chain_corruption_panic"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "zba_populate: out of bitmap space, likely due to memory leak in zone [%s%s] (%u%c, %d elements allocated) @%s:%d"
        }
        symbol = "zba_memory_exhausted"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "zone bits allocator head[%d:%d:%p] is corrupt @%s:%d"
        }
        symbol = "zba_head_corruption_panic"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "accounting mismatch (%s) for zone %s%s, meta %p @%s:%d"
        }
        symbol = "zone_page_meta_accounting_panic"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "metadata list corruption through element %p detected in zone %s%s @%s:%d"
        }
        symbol = "zone_page_metadata_list_corruption"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "zfree_drop"
            "%s: double free of %p to zone %s%s @%s:%d"
        }
        symbol = "zone_meta_double_free_panic"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "zm_bitmap"
        }
        symbol = "zone_meta_find_and_clear_bit"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "\n%5d: 0x%016lx"
            "[%s%s]: element modified after free (off:%d, val:0x%016lx, sz:%d, ptr:%p)%s"
        }
        symbol = "zalloc_uaf_panic"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "zalloc[%d]: zone map exhausted while allocating from zone [%s%s], likely due to memory leak in zone [%s%s] (%u%c, %d elements allocated) @%s:%d"
        }
        symbol = "zone_expand_locked"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "zone map exhaustion: waited for %dms (pages: %ld, max: %ld, wanted: %d) @%s:%d"
        }
        symbol = "__ZONE_MAP_EXHAUSTED_AND_WAITING_FOR_GC__"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "zalloc(Z_NOFAIL) can't be satisfied for zone %s%s (potential leak) @%s:%d"
        }
        symbol = "zone_nofail_panic"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "zalloc_ro_mut failed: source (%p) not from same zone as dst (%p) (expected: %s, actual: %s @%s:%d"
            "zalloc_ro_mut failed: source (%p, phys %p) not from RO zone map (%p - %p), current stack (%p - %p) or const memory (phys %p - %p) @%s:%d"
        }
        symbol = "zalloc_ro_mut_validation_panic"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "zone_require_ro failed: address not in a ro zone (addr: %p) @%s:%d"
            "zone_require_ro failed: element improperly aligned (addr: %p) @%s:%d"
            "zone_require_ro failed: invalid zone index %d (addr: %p, expected: %s%s) @%s:%d"
            "zone_require_ro failed: address in unexpected zone id %d (%s%s) (addr: %p, expected: %s%s) @%s:%d"
        }
        symbol = "zone_id_require_ro_panic"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "zdestroy: Zone %s%s isn't destructible @%s:%d"
            "zdestroy: Zone %s%s in an invalid state for destruction @%s:%d"
            "alloc_size"
            "page_count"
            "z_elems_avail wrap-around"
            "z_wired_cur wrap-around"
        }
        symbol = "zone_reclaim"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "zone metadata corruption: %s (meta %p, zone %s%s) @%s:%d"
        }
        symbol = "zone_metadata_corruption"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "zone_map_exhaustion: Zone mapped %lld of %lld, used %lld, capacity %lld [jetsam limit %d%%]\n"
            "zone_map_exhaustion: Largest zone %s%s, size %lu\n"
            "zone_map_exhaustion: Picking VM map entries as the zone to target, size %lu\n"
            "zone_map_exhaustion: Nothing to do for the largest zone [%s%s]. Waking up memorystatus thread.\n"
            "zone_map_exhaustion: Call to memorystatus failed, victim pid: %d\n"
        }
        symbol = "zone_gc"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Zone info:\n"
            "  Zone map: %p - %p\n"
            "  Metadata: %p - %p\n  Bitmaps : %p - %p\n  Extra   : %p - %p\n\n"
            "Probabilistic GZAlloc Report:\n"
            "  Zone    : <unknown>\n"
            "wild deref, missing or invalid metadata"
            "  Zone    : %s%s\n"
            "out-of-bounds (high confidence)"
            "use-after-free (medium confidence)"
            "  Element : [%p, %p) of size %d\n"
            "  Access  : %d byte(s) past\n"
            "  Metadata: zid:%d inl:%d cl:0x%x 0x%04x 0x%08x 0x%08x 0x%08x\n"
            "%-20s %10lu\n"
            "Kernel Stacks"
            "%-20s %10llu\n"
            "Kalloc.Large"
            "\n%-5s %10s\n"
            "%-5lld %10lld\n"
            "addr belongs to"
            "addr is being freed to"
        }
        symbol = "panic_display_zalloc"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Largest zones:\n%-28s %10s %10s\n"
            "Zone Name"
            "Cur Size"
            "Free Size"
            "%-8s%-20s %9u%c %9u%c\n"
        }
        symbol = "panic_display_largest_zones"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "kalloc %s in zone, %s (%s):\n"
            "type arrays"
            "types"
            "\t%-50s\n"
        }
        symbol = "panic_print_types_in_zone"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "zone_create: creating zone %s: flag %s and %s are incompatible @%s:%d"
        }
        symbol = "zone_create_panic"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "accounting mismatch (%s) for zone %s%s @%s:%d"
        }
        symbol = "zone_accounting_panic"
        caller = "?"
    }
    new {
        args = 3
        anchors {
            "swap_task_map @%s:%d"
        }
        symbol = "swap_task_map"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "tro %p points back to %p instead of %p @%s:%d"
        }
        symbol = "__thread_ro_circularity_panic"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "mach_bridge_add_timestamp: thread_timestamp_calibration @%s:%d"
            "remote_time.c"
        }
        symbol = "bt_calibration_thread_start"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "rt_ini_count"
        }
        symbol = "bt_calibration_thread"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "socd buffer size is too small @%s:%d"
            "socd_client.c"
        }
        symbol = "socd_client_init"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Too many lightweight corpse in flight: %d\n"
            "Lightweight corpse enqueued for %s\n"
            "Full corpse enqueued for %s\n"
        }
        symbol = "task_enqueue_exception_with_corpse"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "kcd_c_type"
            "kcd_c_totalout"
            "kcd_c_totalin"
            "kcdata_init_compress_state: invalid compression type: %d @%s:%d"
        }
        symbol = "kcdata_init_compress"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "invalid compression type 0x%llx in kcdata_do_compress @%s:%d"
            "zlib kcdata compression ret = %d @%s:%d"
        }
        symbol = "kcdata_do_compress"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "invalid compression type 0x%llxin kcdata_finish_compression @%s:%d"
        }
        symbol = "kcdata_finish"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "BANK subsystem is initialized\n"
            "Bank ledger"
            "couldn\\'t create bank ledger template @%s:%d"
            "couldn\\'t create cpu_time entry for bank ledger template @%s:%d"
            "energy"
            "couldn\\'t create energy entry for bank ledger template @%s:%d"
        }
        symbol = "bank_init"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            " Bank Context for a pid %d\n"
            " Bank Account linking holder pid %d with merchant pid %d, originator PID/persona: %d, %u and proximate PID/persona: %d, %u\n"
        }
        symbol = "bank_extract_content"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Bogus bank type: %d passed in voucher_command @%s:%d"
        }
        symbol = "bank_command"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "Bogus bank type: %d passed in bank_get_preadopt_thread_group @%s:%d"
        }
        symbol = "bank_get_preadopt_thread_group"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "com.apple.private.persona.modify"
        }
        symbol = "bank_get_value"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "com.apple.private.personas.no.propagate"
            "com.apple.private.persona.adopt.any"
        }
        symbol = "bank_task_initialize"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Releasing a non zero ref bank account %p @%s:%d"
        }
        symbol = "bank_release_value"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "Bogus bank type: %d passed in bank_get_voucher_bank_account @%s:%d"
        }
        symbol = "bank_get_voucher_bank_account"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "kern.disable_atm"
            "-disable_atm"
            "atm_diagnostic_config"
            "kern.atm_diagnostic_config"
            "ATM subsystem is initialized\n"
        }
        symbol = "atm_init"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "IPC_PTHREAD_PRIORITY subsystem is initialized\n"
        }
        symbol = "ipc_pthread_priority_init"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "ipc_pthread_priority_release_value called for a persistent PTHPRIORITY value %x with sync value %d @%s:%d"
            "ipc_pthread_priority.c"
        }
        symbol = "ipc_pthread_priority_release_value"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "vnode_pager_init: memory_object_change_attributes() failed @%s:%d"
        }
        symbol = "vnode_pager_init"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "vnode_pager_data_initialize @%s:%d"
        }
        symbol = "pmap_cs_core_entitlements_abort_0"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "compressor_segment"
            "vm_compressor_swap_trigger_thread: create failed @%s:%d"
        }
        symbol = "vm_compressor_init"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "c_seg %p has bad c_state = %d @%s:%d"
            "c_seg %p requesting bad c_state = %d @%s:%d"
        }
        symbol = "c_seg_switch_state"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "hibernate_write_image encountered error 0x%x - %u, %u, %d, %d, %d, %d, %d, %d, %d, %d, %llu, %d, %d, %d\n @%s:%d"
        }
        symbol = "vm_panic_hibernate_write_image_failed"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "csegbufsz_experiment_property: Failed to wait for IONVRAM."
            "csegbufsize_experiment_property: Failed to remove %s from NVRAM."
        }
        symbol = "erase_csegbufsz_experiment_property"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "vm_compressor_segment_buffer_size"
            "kern.compressor_pool_multiplier"
        }
        symbol = "vm_compressor_set_size"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: moved %d/%d segments from MAJORQ to AGEQ in %lu.%09u seconds and %d breaks\n"
            "vm_compressor_process_major_segments"
        }
        symbol = "vm_compressor_process_major_segments"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "VM_cswap_trigger"
        }
        symbol = "vm_compressor_swap_trigger_thread"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "C_KDP passed to decompress page from outside of debugger context @%s:%d"
            "c_decompress_page: c_segno %d >= c_segments_available %d, slot_ptr(%p), slot_data(%x) @%s:%d"
            "c_decompress_page: c_segno %d is free, slot_ptr(%p), slot_data(%x) @%s:%d"
            "c_decompress_page: c_indx %d >= c_nextslot %d, c_seg(%p), slot_ptr(%p), slot_data(%x) @%s:%d"
            "c_decompress_page: c_size == 0, c_seg(%p), slot_ptr(%p), slot_data(%x) @%s:%d"
            "decompression failure from physical region %llx+%05x: popcount mismatch (%d != %d)\n"
        }
        symbol = "c_decompress_page"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "compressor_memory_object_init: bad request @%s:%d"
        }
        symbol = "compressor_memory_object_init"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "compressor_memory_object_map @%s:%d"
        }
        symbol = "os_reason_set_description_data.cold.3"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "compressor_memory_object_last_unmap @%s:%d"
        }
        symbol = "fourk_pager_data_return"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "compressor_memory_object_deallocate(): bad request @%s:%d"
        }
        symbol = "compressor_memory_object_deallocate"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "compressor_memory_object_data_request(): bad alignment @%s:%d"
            "compressor_memory_object_data_request"
            "compressor: data_request @%s:%d"
        }
        symbol = "compressor_memory_object_data_request"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "do a data_return() if slot for this page is empty @%s:%d"
        }
        symbol = "compressor_memory_object_data_initialize"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "compressor: data_return @%s:%d"
        }
        symbol = "__ZN24AppleUSBXHCITransferRing21refreshDequeuePointerEv.cold.1"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: size 0x%llx overflow @%s:%d"
            "compressor_memory_object_create"
        }
        symbol = "compressor_memory_object_create"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "vm_compressor_pager_put"
            "vm_compressor_pager_put: out of range @%s:%d"
        }
        symbol = "vm_compressor_pager_put"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "vm_compressor_pager_get"
        }
        symbol = "vm_compressor_pager_get"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "vm_compressor_pager_state_clr"
        }
        symbol = "vm_compressor_pager_state_clr"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "vm_compressor_pager_state_get"
        }
        symbol = "vm_compressor_pager_state_get"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "vm_swapout_thread: create failed @%s:%d"
            "VM_swapout"
            "vm_swapfile_create_thread: create failed @%s:%d"
            "VM_swapfile_create"
            "vm_swapfile_gc_thread: create failed @%s:%d"
            "VM_swapfile_gc"
            "VM Swap Subsystem is ON\n"
        }
        symbol = "vm_compressor_swap_init"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "vm_swap_get: vnode_getwithref on swapfile failed with %d\n"
        }
        symbol = "vm_swap_get"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "vm_swap_put: vnode_getwithref on swapfile failed with %d\n"
        }
        symbol = "vm_swap_put"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "vm_swap_reclaim: vnode_getwithref on swapfile failed.\n"
        }
        symbol = "vm_swap_reclaim"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "vm_swap_do_delayed_trim: vnode_getwithref on swapfile failed with %d\n"
        }
        symbol = "vm_swap_do_delayed_trim"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "vm_compressor_codec"
            "-vm_compressor_wk_sw"
            "-vm_compressor_wk_barriers"
            "-vm_compressor_wk"
            "-vm_compressor_hybrid"
        }
        symbol = "vm_compressor_algorithm_init"
        caller = "?"
    }
    new {
        args = 4
        anchors {
            "WKDMC(%p, %p) error, code: 0x%x @%s:%d"
            "vm_compressor_algorithms.c"
        }
        symbol = "metacompressor"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "device_pager_populate_object: list_req failed @%s:%d"
        }
        symbol = "device_pager_populate_object"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "device_pager_init: memory_object_change_attributes() failed @%s:%d"
        }
        symbol = "device_pager_init"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "device_pager_data_initialize @%s:%d"
        }
        symbol = "persona_lookup_and_invalidate.cold.1"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "vm_object_update: unexpected error 0x%x from vm_fault_page()\n @%s:%d"
        }
        symbol = "vm_object_update"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Ignoring \"vm_compressor\" boot arg %d\n"
            "kern.vm_compressor"
            "\"vm_compressor_mode\" is %d\n"
            "vm_protect_privileged_from_untrusted"
        }
        symbol = "vm_fault_init"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "vm_fault_page(): unexpected error %d from vm_compressor_pager_get()\n @%s:%d"
        }
        symbol = "vm_fault_page"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "vm_fault_unwire: failure @%s:%d"
        }
        symbol = "vm_fault_unwire"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "vm_fault_copy: unexpected error 0x%x from vm_fault_page()\n @%s:%d"
            "vm_fault_copy(2): unexpected error 0x%x from vm_fault_page()\n @%s:%d"
        }
        symbol = "vm_fault_copy"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "kdp_lightweight_fault called from outside of debugger context @%s:%d"
        }
        symbol = "kdp_lightweight_fault"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Text page corruption detected for pid %d\n"
        }
        symbol = "revalidate_text_page"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: pmap %p vaddr 0x%llx prot 0x%x options 0x%x !cs_bypass @%s:%d"
            "page marked to be NX, not letting it be mapped EXEC\n"
            "vm_fault: signed: %s validate: %s tainted: %s wpmapped: %s prot: 0x%x\n"
            "CODE SIGNING: process %d[%s]: rejecting invalid page at address 0x%llx from offset 0x%llx in file \"%s%s%s\" (cs_mtime:%lu.%ld %s mtime:%lu.%ld) (signed:%d validated:%d tainted:%d nx:%d wpmapped:%d dirty:%d depth:%d)\n"
            "<nil>"
            "/.../"
            "vm_fault_enter: failed to allocate codesigning exit reason\n"
            "vm_fault_enter: failed to allocate buffer for codesigning exit reason\n"
            "vm_fault_enter: failed to allocate kcdata for codesigning exit reason\n"
            "CODE SIGNING: tainted page %p phys 0x%x phystokv 0x%llx copied to %p\n"
            "CODE SIGNING: process %d[%s]: rejecting invalid page (phys#0x%x) at address 0x%llx from offset 0x%llx in file \"%s%s%s\" (cs_mtime:%lu.%ld %s mtime:%lu.%ld) (signed:%d validated:%d tainted:%d nx:%dwpmapped:%d dirty:%d depth:%d)\n @%s:%d"
            "CODESIGNING: vm_fault_enter(0x%llx): *** INVALID PAGE ***\n"
            "CODESIGNING: panicking on invalid page @%s:%d"
        }
        symbol = "vm_fault_enter_prepare"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Write fault on compressor map, va: %p type: %u bounds: %p->%p @%s:%d"
            "%s:%d should not zero-fill page at offset 0x%llx in external object %p @%s:%d"
            "%s: map %p va 0x%llx obj %p,%u saved %p,%u: unexpected CoW @%s:%d"
            "object_is_contended @%s:%d"
            "vm_fault: unexpected error 0x%x from vm_fault_page()\n @%s:%d"
            "%s: pmap %p vaddr 0x%llx prot 0x%x options 0x%x m%p obj %p copyobj %p @%s:%d"
        }
        symbol = "vm_fault_internal"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "CODESIGNING: %s: page %p obj %p off 0x%llx was modified\n"
            "vm_page_validate_cs_fast"
        }
        symbol = "vm_page_validate_cs_fast"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Bad compare and swap in setup! @%s:%d"
        }
        symbol = "vmtc_text_page_diagnose_setup"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Bad compare and swap in diagnose! @%s:%d"
        }
        symbol = "vmtc_text_page_diagnose"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "vm_page_bootstrap"
            "zone_bootstrap"
            "vm_object_bootstrap"
            "vm_map_init"
            "kmem_init"
            "vm_fault_init"
            "IOKit IOMD setownership ENABLED\n"
            "IOKit IOMD setownership DISABLED\n"
        }
        symbol = "vm_mem_bootstrap"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "kmem_suballoc(map=%p, size=%zd) failed with %d @%s:%d"
        }
        symbol = "kmem_suballoc"
        caller = "?"
    }
    new {
        args = 3
        anchors {
            "%s: page_list too short @%s:%d"
            "%s: page_list too long @%s:%d"
        }
        symbol = "kernel_memory_populate_object_and_unlock"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "realloc"
            "kmem_%s(map=%p, addr=%p, size=%zd, flags=0x%x): invalid arguments passed @%s:%d"
        }
        symbol = "__kmem_invalid_arguments_panic"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "kmem_range_init: Can't scramble with multiple constraints @%s:%d"
        }
        symbol = "kmem_readjust_ranges"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "kmem_ptr_range"
            "kmem_ptr_range_meta"
        }
        symbol = "kmem_add_ptr_claims"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "kmem_sprayqtn_range"
            "kmem_data_range"
        }
        symbol = "kmem_add_extra_claims"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "kmem_range_init: vm_map_locate_space failing for claim %s @%s:%d"
            "kmem_range_init: vm_map_find_space failing for claim %s @%s:%d"
        }
        symbol = "kmem_scramble_ranges"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "kmem_init(0x%llx,0x%llx): vm_map_enter(0x%llx,0x%llx) error 0x%x @%s:%d"
        }
        symbol = "kmem_init"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "%s: %s range invalid min:%p <= base:%p @%s:%d"
            "%s: %s range invalid max:%p >= max packable:%p @%s:%d"
        }
        symbol = "vm_packing_verify_range"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "invalid vm range: [0x%llx, 0x%llx) wraps around @%s:%d"
        }
        symbol = "__mach_vm_range_invalid"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "addr %p + size %llu overflows %p @%s:%d"
            "addr %p + size %llu doesnt fit in one range (id: %u min: %p max: %p) @%s:%d"
        }
        symbol = "kmem_range_invalid_panic"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Can't overwrite mappings (addr: %p) in kmem ptr ranges @%s:%d"
        }
        symbol = "kmem_range_invalid_for_overwrite"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "atomicity"
            "objectness"
            "left bound"
            "right bound"
            "guard"
            "kmem(map=%p, addr=%p, size=%zd, flags=0x%x): entry:%p %s mismatch guard(0x%08x) @%s:%d"
        }
        symbol = "__kmem_entry_validate_panic"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "kmem(map=%p) no entry found at %p @%s:%d"
        }
        symbol = "__kmem_entry_not_found_panic"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "alloc"
            "kmem_%s(%p, %zd, 0x%x): failed with %d @%s:%d"
        }
        symbol = "__kmem_failed_panic"
        caller = "?"
    }
    new {
        args = 3
        anchors {
            "VM page %p should not have an error @%s:%d"
        }
        symbol = "kernel_memory_populate_pmap_enter"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "kmem(map=%p, flags=0x%x): invalid size %zd @%s:%d"
        }
        symbol = "__kmem_invalid_size_panic"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "kmem(map=%p) entry %p is a submap @%s:%d"
            "is unexpectedly"
            "kmem(map=%p, flags=0x%x): entry %p %s for the %s object @%s:%d"
        }
        symbol = "__kmem_entry_validate_object_panic"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "kmem_realloc(map=%p, addr=%p, size=%zd, entry=%p): object %p has unexpected pager %p (%d,%d,%d) @%s:%d"
        }
        symbol = "__kmem_realloc_invalid_pager_panic"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "kmem_realloc(map=%p, addr=%p, size=%zd, entry=%p): object %p has unexpected size %ld @%s:%d"
        }
        symbol = "__kmem_realloc_invalid_object_size_panic"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Invalid sizeclass idx %u @%s:%d"
        }
        symbol = "kmem_invalid_size_idx"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Metadata (%p) for addr (%p) not primary @%s:%d"
            "Metadata's (%p) sizeclass (%u != %u) changed during deletion @%s:%d"
            "Double free detected: Slot (%u) in meta (%p) for addr %p marked free @%s:%d"
        }
        symbol = "kmem_validate_slot_panic"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Invalid kmem ptr slot [%p:%p] for allocation [%p:%p] @%s:%d"
        }
        symbol = "kmem_invalid_slot_for_addr"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%uth free slot not found for meta %p bitmap %u @%s:%d"
        }
        symbol = "kmem_slot_not_found"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Invalid slot idx %u [0:%u] for meta %p @%s:%d"
            "Invalid size_idx (%u != %u) in meta %p @%s:%d"
            "page_marker %u not primary in meta %p @%s:%d"
        }
        symbol = "kmem_invalid_meta_panic"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Entry (%p) already exists for addr (%p) being returned @%s:%d"
        }
        symbol = "kmem_slot_has_entry_panic"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Reading free chunks for meta %p where marker != KMEM_META_FREE @%s:%d"
        }
        symbol = "kmem_invalid_free_chunk_len"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Invalid number of chunks %u\n @%s:%d"
        }
        symbol = "kmem_invalid_chunk_num"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "No more VA to allocate %u chunks in range %u @%s:%d"
        }
        symbol = "kmem_range_out_of_va"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Reading free chunks for meta %p where marker != KMEM_META_PRIMARY @%s:%d"
        }
        symbol = "kmem_invalid_chunk_len"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "cambria_pagesize"
            "VM map entries"
            "VM map holes"
            "VM map copies"
            "VM boostrap: %d maps, %d entries and %d holes available\n"
            "vm_memory_malloc_no_cow_mask"
        }
        symbol = "vm_map_init"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "VM bootstrap done: %d maps, %d entries and %d holes left\n"
        }
        symbol = "vm_kernel_boostraped"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Unexpected zone ID %d @%s:%d"
        }
        symbol = "vm_map_relocate_early_elem"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "zone_map_exhaustion: victim pid %d, vm region count: %d\n"
        }
        symbol = "find_largest_process_vm_map_entries"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "failing"
            "turning off execute"
            "vm_map_enter: pmap_nest(0x%llx,0x%llx) error 0x%x\n"
            "%d[%s] %s: map size 0x%llx over RLIMIT_AS 0x%llx\n"
            "%d[%s] %s: map size 0x%llx over RLIMIT_DATA 0x%llx\n"
        }
        symbol = "vm_map_enter"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "VM_FLAGS_RETURN_DATA_ADDR not expected for submap. @%s:%d"
            "vm_map_enter_mem_object: memory_entry->backing.copy unsupported type 0x%x\n"
            "invalid VM named entry %p @%s:%d"
            "VM_FLAGS_RETURN_DATA_ADDR not expected for raw memory object. @%s:%d"
        }
        symbol = "vm_map_enter_mem_object"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "vm_map_protect(%p,0x%llx,0x%llx) new=0x%x wired=%x @%s:%d"
        }
        symbol = "vm_map_protect"
        caller = "?"
    }
    new {
        args = 5
        anchors {
            "%s:%d WindowServer VM Debugging panic: dst_addr 0x%llx copy %p head_addr 0x%llx head_copy %p\n @%s:%d"
            "vm_map_copy_overwrite"
        }
        symbol = "vm_map_copy_overwrite"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Aborting corpse map due to system shutdown\n"
            "vm_map_fork"
            "vm_map_fork_share: pmap_nest failed! @%s:%d"
            "vm_map_fork_share"
        }
        symbol = "vm_map_fork"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "shared_region: task %p: vm_map_exec(%p,%p,%p,0x%x,0x%x): ->\n"
            "shared_region: task %p: vm_map_exec(%p,%p,%p,0x%x,0x%x): <-\n"
            "Failed to reserve %s region in user map %p %d @%s:%d"
        }
        symbol = "vm_map_exec"
        caller = "?"
    }
    new {
        args = 3
        anchors {
            "%s:%d(start=0x%llx, size=0x%llx) pgmask 0x%x: wraparound\n"
        }
        symbol = "vm_map_range_physical_size"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "%d[%s] vm_remap(0x%llx,0x%llx) VM_PROT_COPY denied on permanent mapping prot 0x%x/0x%x developer %d\n"
        }
        symbol = "vm_map_remap"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "userspace has access to a kernel map %p @%s:%d"
        }
        symbol = "convert_port_entry_to_map"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%d[%s] vm_map_range_overflows addr 0x%llx size 0x%llx pgmask 0x%llx\n"
        }
        symbol = "vm_map_range_overflows"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "invalid range ID (%u) for map %p @%s:%d"
        }
        symbol = "vm_map_range_invalid_panic"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "vm_map_clip_unnest(0x%llx,0x%llx): bad nested entry: start=0x%llx end=0x%llx\n @%s:%d"
        }
        symbol = "vm_map_clip_unnest"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "vm_map_clip(%p): Attempting to clip an atomic VM map entry %p [0x%llx:0x%llx] at 0x%llx @%s:%d"
        }
        symbol = "__vm_map_clip_atomic_entry_panic"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "mapHdr %p entry %p start 0x%llx end 0x%llx new start 0x%llx @%s:%d"
        }
        symbol = "_vm_map_clip_start"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "mapHdr %p entry %p start 0x%llx end 0x%llx new end 0x%llx @%s:%d"
        }
        symbol = "_vm_map_clip_end"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "vm_map_wire: re-lookup failed @%s:%d"
        }
        symbol = "vm_map_wire_nested"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "vm_map_wire: too many wirings @%s:%d"
        }
        symbol = "add_wire_counts"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "vm_map_unwire: start not found @%s:%d"
            "vm_map_unwire: in_transition entry @%s:%d"
            "vm_map_unwire: entry is unwired @%s:%d"
            "vm_map_unwire: non-contiguous region @%s:%d"
            "vm_map_unwire: re-lookup failed @%s:%d"
        }
        symbol = "vm_map_unwire_nested"
        caller = "?"
    }
    new {
        args = 3
        anchors {
            "%d[%s] removing permanent submap entry %p [0x%llx:0x%llx] prot 0x%x/0x%x -> KERN_PROT_FAILURE\n"
            "%d[%s] %s(0x%llx,0x%llx): code signing monitor disabled, allowing for permanent executable entry [0x%llx:0x%llx] prot 0x%x/0x%x\n"
            "%s:%d %d[%s] map %p entry %p [ 0x%llx - 0x%llx ] submap %d prot 0x%x/0x%x -> 0/0\n"
        }
        symbol = "vm_map_delete"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "vm_map_delete(%p,0x%llx,0x%llx): no map entry at 0x%llx @%s:%d"
        }
        symbol = "__vm_map_delete_gap_panic"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "vm_map_delete(%p,0x%llx,0x%llx): Attempting to remove permanent VM map entry %p [0x%llx:0x%llx] @%s:%d"
        }
        symbol = "__vm_map_delete_permanent_panic"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "vm_map_delete(%p,0x%llx,0x%llx): failed unexpected with %d @%s:%d"
        }
        symbol = "__vm_map_delete_failed_panic"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s:%d WindowServer VM Debugging panic: address 0x%llx copy ptr %p\n"
            "%s:%d WindowServer VM Debugging panic: start 0x%llx end 0x%llx entry %p copy ptr %p\n"
            "%s:%d WindowServer VM Debugging panic: next %p entry %p copy ptr %p\n"
        }
        symbol = "vm_map_copy_overwrite_nested"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "vm_map_entry_copy_code_signing"
            "removing execute access"
        }
        symbol = "vm_map_entry_copy"
        caller = "?"
    }
    new {
        args = 5
        anchors {
            "vm_map_copyout: wiring %p @%s:%d"
        }
        symbol = "vm_map_copyout_internal"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "vm_map_remap_extract"
        }
        symbol = "vm_map_remap_extract"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Found an existing entry %p [0x%llx, 0x%llx) in map %p instead of potential hole at address: 0x%llx. @%s:%d"
        }
        symbol = "__vm_map_store_find_space_holelist_corruption"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "VMSEL: INSERT FAILED: 0x%lx, 0x%lx, 0x%lx, 0x%lx @%s:%d"
        }
        symbol = "vm_map_store_entry_link_rb"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "NO ENTRY TO DELETE @%s:%d"
        }
        symbol = "vm_map_store_entry_unlink_rb"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Hole hint failed: Hole entry start: 0x%llx, entry start: 0x%llx, map hole start: 0x%llx, map hint start: 0x%llx @%s:%d"
            "Hole hint failed: Hole entry end: 0x%llx, entry start: 0x%llx, map hole start: 0x%llx, map hint start: 0x%llx @%s:%d"
        }
        symbol = "update_holes_on_entry_deletion"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Illegal action: h1: %p, s:0x%llx, e:0x%llx...h2:%p, s:0x%llx, e:0x%llx...h3:0x%p, s:0x%llx, e:0x%llx @%s:%d"
        }
        symbol = "update_holes_on_entry_creation"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "com.apple.private.memory.ownership_transfer"
            "com.apple.developer.memory.transfer-send"
            "com.apple.developer.memory.transfer-accept"
        }
        symbol = "mach_memory_entry_ownership"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "unsupported type of mem_entry %p @%s:%d"
        }
        symbol = "mach_memory_entry_map_size"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "Shouldn't be using data address with a parent entry that is a submap. @%s:%d"
        }
        symbol = "mach_make_memory_entry_internal"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "vm objects"
        }
        symbol = "vm_object_bootstrap"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "VM_io_reprioritize_thread"
            "Could not create io_reprioritize_thread @%s:%d"
        }
        symbol = "vm_io_reprioritize_init"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "failed to launch vm_object_reaper_thread kr=0x%x @%s:%d"
            "VM_object_reaper_thread"
        }
        symbol = "vm_object_reaper_init"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "vm_object_deallocate: losing a kernel_object @%s:%d"
            "vm_object_deallocate: losing retired_pages_object @%s:%d"
            "vm_object_deallocate: losing compressor_object @%s:%d"
        }
        symbol = "vm_object_deallocate"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "object %p all_reusable: can't update pmap stats @%s:%d"
        }
        symbol = "vm_object_reuse_pages"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "vm_object_copy_slowly: unexpected error 0x%x from vm_fault_page()\n @%s:%d"
        }
        symbol = "vm_object_copy_slowly"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "copy_strategically: bad strategy %d for object %p @%s:%d"
        }
        symbol = "vm_object_copy_strategically"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "vm_object_compressor_pager_create(): no pager for object %p size 0x%llx\n @%s:%d"
            "vm_object_compressor_pager_create: mismatch (pager: %p, pager_object: %p, orig_object: %p, orig_object size: 0x%llx) @%s:%d"
        }
        symbol = "vm_object_compressor_pager_create"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "vm_object_collapse() attempting to collapse purgeable object: %p(%d) %p(%d)\n @%s:%d"
        }
        symbol = "vm_object_collapse"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "vm_object_populate_with_private - %p not private @%s:%d"
        }
        symbol = "vm_object_populate_with_private"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: external object %p has unsupported ledger_tag %d @%s:%d"
            "%s: object %p has unsupported ledger_tag %d @%s:%d"
        }
        symbol = "vm_object_ledger_tag_ledgers"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s(%p): volatile=%d nonvolatile=%d owned=%d q=%p q_first=%p q_last=%p @%s:%d"
            "vm_owned_objects_disown"
        }
        symbol = "vm_owned_objects_disown"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "reservation without pageout? @%s:%d"
            "missing pager for copy object @%s:%d"
        }
        symbol = "vm_pageout_initialize_page"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "vm_pageout: no victim @%s:%d"
        }
        symbol = "vm_pageout_scan"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "VM_pressure"
        }
        symbol = "vm_pressure_thread"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "vm_restricted_to_single_processor"
            "Overriding vm_restricted_to_single_processor to %d\n"
        }
        symbol = "vm_set_restrictions"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "mapping deprecated VM_PAGER_DEFAULT to VM_PAGER_COMPRESSOR_WITH_SWAP\n"
            "mapping deprecated VM_PAGER_FREEZER_DEFAULT to VM_PAGER_FREEZER_COMPRESSOR_NO_SWAP\n"
            "unknown compressor mode - %x\n"
        }
        symbol = "vm_config_init"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "vm_pageout_garbage_collect: create failed @%s:%d"
            "VM_pageout_garbage_collect"
        }
        symbol = "vm_pageout_create_gc_thread"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "vmpgo_pcluster"
            "vmpgo_protect_realtime"
            "VM_pageout_scan"
            "vm_pageout: Unable to create external thread (%d)\n @%s:%d"
            "VM_pageout_external_iothread"
            "vm_pressure_thread: create failed @%s:%d"
        }
        symbol = "vm_pageout"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "vmcomp_threads"
            "vmpgoi_maxlaundry"
            "vm_pageout: Unable to create compressor thread no. %d (%d)\n @%s:%d"
        }
        symbol = "vm_pageout_internal_start"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "vm_object_upl_request: external object with non-zero paging offset @%s:%d"
            "vm_object_upl_request: contiguous object specified @%s:%d"
            "need corner case for fictitious page @%s:%d"
        }
        symbol = "vm_object_upl_request"
        caller = "?"
    }
    new {
        args = 3
        anchors {
            "Only %d of the %d sub-upls within the Vector UPL are alread mapped @%s:%d"
            "TODO4K: vector UPL not implemented @%s:%d"
            "vm_upl_map: page missing @%s:%d"
            "vm_map_enter failed for a Vector UPL @%s:%d"
            "vector_upl_get_submap was passed a NULL UPL @%s:%d"
            "getting sub-upl iostate when none exists @%s:%d"
        }
        symbol = "vm_map_enter_upl_range"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "%d of the %d sub-upls within the Vector UPL is/are not mapped @%s:%d"
            "vector_upl_get_submap was passed a null UPL @%s:%d"
        }
        symbol = "vm_map_remove_upl_range"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "iopl_valid_data: NULL upl @%s:%d"
            "iopl_valid_data: vector upl @%s:%d"
            "iopl_valid_data: unsupported upl, flags = %x @%s:%d"
            "iopl_valid_data: object == kernel or compressor @%s:%d"
            "iopl_valid_data: object %p purgable %d @%s:%d"
            "iopl_valid_data: missing expected page at offset %lx @%s:%d"
            "iopl_valid_data: busy page w/o absent @%s:%d"
            "iopl_valid_data: busy+absent page on page queue @%s:%d"
            "iopl_valid_data: %p is reusable @%s:%d"
            "iopl_valid_data: %p already wired @%s:%d"
        }
        symbol = "iopl_valid_data"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "vm_object_iopl_request: external object with non-zero paging offset @%s:%d"
            "vm_object_iopl_request: missing/bad page in kernel object @%s:%d"
            "vm_object_iopl_request: missing/bad page in compressor object @%s:%d"
            "vm_object_iopl_request: unexpected error 0x%x from vm_fault_page()\n @%s:%d"
            "vm_object_iopl_request: Wired page missing. @%s:%d"
        }
        symbol = "vm_object_iopl_request"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "Deallocating non-empty Vectored UPL @%s:%d"
        }
        symbol = "upl_deallocate"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Trying to remove sub-upl when none exists @%s:%d"
            "vector_upl_set_subupl was passed a NULL upl element @%s:%d"
            "vector_upl_set_subupl was passed a NULL upl @%s:%d"
        }
        symbol = "vector_upl_set_subupl"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "vector_upl_set_pagelist was passed a NULL upl @%s:%d"
        }
        symbol = "vector_upl_set_pagelist"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Vector UPL offset miscalculation @%s:%d"
        }
        symbol = "vector_upl_subupl_byoffset"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "setting sub-upl iostate when none exists @%s:%d"
            "vector_upl_set_iostate was passed a NULL UPL @%s:%d"
        }
        symbol = "vector_upl_set_iostate"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "upl_set_referenced not %p @%s:%d"
        }
        symbol = "upl_set_referenced"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "IN Q: %d : %d : %d\n"
            "AC Q: %d : %d : %d\n"
        }
        symbol = "vm_countdirtypages"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "VM_compressor"
        }
        symbol = "vm_pageout_iothread_internal"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "upl(%p) ext_ref_count @%s:%d"
        }
        symbol = "upl_destroy"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: Unrecognized page list type %hhu @%s:%d"
            "unified_page_list_iterator_init"
            "vm_pmap.c"
        }
        symbol = "pmap_batch_set_cache_attributes"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "unmarked object on purgeable q @%s:%d"
            "marked object not on purgeable q @%s:%d"
        }
        symbol = "vm_purgeable_object_remove"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "vm_purgeable_accounting(%p): unexpected old_state=%d\n @%s:%d"
        }
        symbol = "vm_purgeable_accounting"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Unexpected reclaim action %d @%s:%d"
        }
        symbol = "vm_deferred_reclamation_reclaim_memory"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "vm_reclaim"
        }
        symbol = "vm_deferred_reclamation_init"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "vm_reclaim: About to kill %p due to %d with subcode %lld\n @%s:%d"
            "vm_reclaim: Unable to deliver guard exception because task [%d] is already dead.\n"
            "vm_reclaim: Skipping non fatal guard exception.\n"
            "vm_reclaim: Unable to deliver guard exception because proc is gone & pid rolled over.\n"
            "vm_reclaim: Unable to deliver guard exception because task does not have a proc.\n"
            "vm_reclaim: Unable to deliver guard exception to %p: %d\n"
        }
        symbol = "reclaim_kill_with_reason"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "VM_reclaim"
        }
        symbol = "reclaim_thread"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "vm_page_bg_mode"
            "vm_page_bg_exclude_external"
            "vm_page_bg_target"
            "vm_page_bootstrap: WARNING -- strange page hash\n"
            "vm_page_buckets"
            "vm_page_bucket_locks"
            "pmap_startup"
            "vm_page_bootstrap: %d free pages, %d wired pages, (up to %d of which are delayed free)\n"
            "vm_page_bootstrap complete"
            "colors"
        }
        symbol = "vm_page_bootstrap"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Filling vm_pages with pattern: 0x%x\n"
            "page_frame_init"
            "pmap_startup(): too many pages to support vm_page packing @%s:%d"
            "pmap_startup() init/release time: %lld microsec\n"
            "pmap_startup() delayed init/release of %d pages\n"
            "VM_PAGE_PACK_PTR failed on &vm_pages[0] - %p @%s:%d"
            "VM_PAGE_PACK_PTR failed on &vm_pages[vm_pages_count-1] - %p @%s:%d"
        }
        symbol = "pmap_startup"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "vm pages"
        }
        symbol = "vm_page_module_init"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "vm_page_insert_internal: (page=%p,obj=%p,off=0x%llx,size=0x%llx) inserted at offset past object bounds @%s:%d"
        }
        symbol = "vm_page_insert_internal"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "panic: kdp_vm_page_lookup done outside of kernel debugger @%s:%d"
        }
        symbol = "kdp_vm_page_lookup"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s:%d should not modify cpu->free_pages while hibernating @%s:%d"
            "vm_page_grab_options"
            "%s: page 0x%llx is referenced @%s:%d"
        }
        symbol = "vm_page_grab_options"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "vm_page_wire(%p): wire_count overflow @%s:%d"
        }
        symbol = "vm_page_wire"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "vm_page_reactivate_local: found vm_page_t(%p) with wrong cpuid @%s:%d"
            "vm_page_reactivate_local: count = %d, vm_page_local_count = %d @%s:%d"
        }
        symbol = "vm_page_reactivate_local"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "could"
        }
        symbol = "hibernate_page_list_setall"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "hibernate_lookup_paddr of %d failed @%s:%d"
        }
        symbol = "hibernate_free_range"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "vm_page_queues_remove - bad page q_state (%p, %d) @%s:%d"
        }
        symbol = "vm_page_queues_remove"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "pmap_steal_memory() size: 0x%llx @%s:%d"
            "pmap_steal_memory() pmap_enter failed, map_addr=%#lx, phys_page=%u @%s:%d"
        }
        symbol = "pmap_steal_memory_internal"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "vm pages array"
        }
        symbol = "vm_free_delayed_pages"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s(num=%d,low=%d): found %d pages at 0x%llx...scanned %d pages...  yielded %d times...  dumped run %d times... stole %d pages... stole %d compressed pages... wired count is %d\n"
            "vm_page_find_contiguous"
            "vm_page_find_contiguous: zone_gc called... wired count is %d\n"
        }
        symbol = "cpm_allocate"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "vm_page_alloc_list(%zd, 0x%x) failed unexpectedly with %d @%s:%d"
        }
        symbol = "__vm_page_alloc_list_failed_panic"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "hibernate_consider_discard: private @%s:%d"
        }
        symbol = "hibernate_consider_discard"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "hibernate_discard_page(%p) laundry @%s:%d"
            "hibernate_discard_page(%p) private @%s:%d"
            "hibernate_discard_page(%p) fictitious @%s:%d"
        }
        symbol = "hibernate_discard_page"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "shared_region: -> get(%p)\n"
            "shared_region: get(%p) <- %p\n"
        }
        symbol = "vm_shared_region_get"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "shared_region: -> vm_map(%p)\n"
            "shared_region: vm_map(%p) <- %p\n"
        }
        symbol = "vm_shared_region_vm_map"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "shared_region: -> set(%p, %p)\n"
            "shared_region: set(%p) <- old=%p new=%p\n"
        }
        symbol = "vm_shared_region_set"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "shared_region: -> lookup(root=%p,cpu=<%d,%d>,64bit=%d,pgshift=%d,reslide=%d,driverkit=%d)\n"
            "shared_region: vm_shared_region_lastid wrapped @%s:%d"
            "shared_region: lookup(root=%p,cpu=<%d,%d>,64bit=%d,pgshift=%d,reslide=%d,driverkit=%d) <- %p\n"
            "shared_region: -> create(root=%p,cpu=<%d,%d>,64bit=%d,pgshift=%d,reslide=%d,driverkit=%d)\n"
            "shared_region: create: couldn\\'t allocate map\n"
            "shared_region: create(root=%p,cpu=<%d,%d>,64bit=%d,reslide=%d,driverkit=%d,base=0x%llx,size=0x%llx) <- %p mem=(%p,%p) map=%p pmap=%p\n"
            "shared_region: create(root=%p,cpu=<%d,%d>,64bit=%d,driverkit=%d,base=0x%llx,size=0x%llx) <- NULL"
        }
        symbol = "vm_shared_region_lookup"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "shared_region: -> reference(%p)\n"
            "shared_region: reference(%p) <- %d\n"
        }
        symbol = "vm_shared_region_reference"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "shared_region: -> deallocate(%p)\n"
            "shared_region: deallocate(%p): ref now %d\n"
            "shared_region: deallocate(%p): armed timer\n"
            "shared_region: deallocate(%p) <-\n"
        }
        symbol = "vm_shared_region_deallocate"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "shared_region: -> start_address(%p)\n"
            "shared_region: start_address(%p) <- 0x%llx\n"
        }
        symbol = "vm_shared_region_start_address"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s(): shared_region_pager_match() failed\n"
            "%s(): find_mapping_to_slide() failed\n"
            "%s(): doesn't fully cover\n"
            "%s(): mach_vm_map_kernel() failed\n"
        }
        symbol = "vm_shared_region_auth_remap"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Failed to undo mappings because of NULL shared region.\n"
            "shared_region: mapping[%d]: address:0x%016llx size:0x%016llx offset:0x%016llx maxprot:0x%x prot:0x%x: undoing...\n"
        }
        symbol = "vm_shared_region_undo_mappings"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "shared_region: region_slide(slide:0x%x start:0x%016llx size:0x%016llx) failed 0x%x\n"
            "shared_region: map(%p) <- 0x%x \n"
        }
        symbol = "vm_shared_region_map_file"
        caller = "?"
    }
    new {
        args = 6
        anchors {
            "shared_region: -> enter(map=%p,task=%p,root=%p,cpu=<%d,%d>,64bit=%d,driverkit=%d)\n"
            "shared_region: -> enter(map=%p,task=%p,root=%p,cpu=<%d,%d>,64bit=%d,reslide=%d,driverkit=%d): lookup failed !\n"
            "shared_region: enter(%p,%p,%p,%d,%d,%d,%d,%d): nested vm_map_enter(0x%llx,0x%llx,%p) error 0x%x\n"
            "shared_region: enter(%p,%p,%p,%d,%d,%d,%d,%d) <- 0x%x\n"
        }
        symbol = "vm_shared_region_enter"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s:%d vm_map(0x%llx, 0x%llx) error %d\n"
            "vm_shared_region_remove"
        }
        symbol = "vm_shared_region_remove"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "commpage text: ->init()\n"
            "commpage text: init() <-\n"
            "ARM comm page text section %s,%s missing @%s:%d"
            "__commpage_text"
        }
        symbol = "vm_commpage_text_init"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "commpage: -> init()\n"
            "commpage: init() <-\n"
        }
        symbol = "vm_commpage_init"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "vm_shared_region_slide: -> slide %#x, entry_start %#llx, entry_size %#llx, slide_start %#llx, slide_size %#llx\n"
            "%s: no shared region?\n"
            "vm_shared_region_slide"
            "vm_shared_region_slide: <- %d (no shared region)\n"
            "slide_info initialization failed with kr=%d\n"
            "vm_shared_region_slide: <- %d\n"
            "Slide_info_size too small: %lx\n"
            "Slide_info_size too large: %lx\n"
            "copyin of slide_info failed\n"
            "Too many auth/private sections for shared region!!\n"
            "No sliding bitmap entry for pageIndex: %d at entryIndex: %d amongst %d entries\n"
            "%s bad slide_info_size: %lx\n"
            "vm_shared_region_slide_sanity_check_v2"
            "vm_shared_region_slide_sanity_check_v3: s_info->page_size != PAGE_SIZE_FOR_SR_SL 0x%llx != 0x%llx\n"
            "vm_shared_region_slide_sanity_check_v3: required_size != slide_info_size 0x%llx != 0x%llx\n"
            "vm_shared_region_slide_sanity_check_v4"
            "vm_shared_region_slide_sanity_check_v5: s_info->page_size != PAGE_SIZE_FOR_SR_SL 0x%llx != 0x%llx\n"
            "vm_shared_region_slide_sanity_check_v5: required_size != slide_info_size 0x%llx != 0x%llx\n"
        }
        symbol = "vm_shared_region_slide"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "shared_region: pivot(%p): armed timer\n"
        }
        symbol = "vm_shared_region_pivot"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "shared_region: -> reference_locked(%p)\n"
            "shared_region: reference_locked(%p) <- %d\n"
        }
        symbol = "vm_shared_region_reference_locked"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "shared_region: -> destroy(%p) (root=%p,cpu=<%d,%d>,64bit=%d,driverkit=%d)\n"
            "shared_region: destroy(%p) <-\n"
        }
        symbol = "vm_shared_region_destroy"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "shared_region: -> map(%p)\n"
            "shared_region: more than 1 non-zero slide value amount slide 1:0x%x slide 2:0x%x\n "
            "shared_region: mapping[0]: address:0x%016llx size:0x%016llx offset/addr:0x%016llx maxprot:0x%x prot:0x%x fd==-1\n"
            "%s(): for fd==-1 vm_map_enter() in kernel failed\n"
            "%s(): for fd==-1 copyin() failed, errno=%d\n"
            "%s(): for fd==-1 vm_map_enter() in SR failed\n"
            "shared_region: mapping[%d]: address:0x%016llx size:0x%016llx offset:0x%016llx maxprot:0x%x prot:0x%x\n"
            "shared_region: mapping[%d]: address:0x%016llx size:0x%016llx offset:0x%016llx maxprot:0x%x prot:0x%x too many mappings to slide...\n"
            "shared_region: mapping[%d]: address:0x%016llx size:0x%016llx offset:0x%016llx maxprot:0x%x prot:0x%x already mapped...\n"
            "shared_region: mapping[%d]: address:0x%016llx size:0x%016llx offset:0x%016llx maxprot:0x%x prot:0x%x failed 0x%x\n"
        }
        symbol = "vm_shared_region_map_file_setup"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "shared_region: sr_cache_header.imagesTextCount >= UINT32_MAX @%s:%d"
        }
        symbol = "vm_shared_region_map_file_final"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "No slide entry for this page in toc. PageIndex: %d Toc Count: %d\n"
            "No sliding bitmap entry for entryIndex: %d amongst %d entries\n"
            "vm_shared_region_slide() carry over: i=%d j=%d b=0x%x slide=0x%x old=0x%x new=0x%x\n"
            "vm_shared_region_slide_page() did not find page start in slide info: pageIndex=%u, count=%u\n"
            "vm_shared_region_slide_page() out-of-bounds extras index: index=%u, count=%u\n"
        }
        symbol = "vm_shared_region_slide_page"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "vm_shared_region_slide_page() offset overflow: pageIndex=%u, start_offset=%u, slide_amount=%u\n"
        }
        symbol = "rebase_chain"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "shared_region_find_key() no key for region '%s' @%s:%d"
        }
        symbol = "shared_region_find_key"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "shared_region_key_alloc() inherited key mismatch @%s:%d"
        }
        symbol = "shared_region_key_alloc"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "shared_region_key_dealloc() Shared region ID '%s' not found @%s:%d"
        }
        symbol = "shared_region_key_dealloc"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "shared_region_pager_init: memory_object_change_attributes() failed @%s:%d"
        }
        symbol = "shared_region_pager_init"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "shared_region_pager_data_return: should never get called @%s:%d"
        }
        symbol = "__ZN31IOAppleConvergedIPCRTIInterface21createRingSourceGatedE25AppleConvergedIPCRingTypejP18IOACIPCRingOptionsPP23IOAppleConvergedIPCRing.cold.1"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "shared_region_pager_data_initialize: should never get called @%s:%d"
        }
        symbol = "msgctl.cold.1"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "shared_region_pager_data_request: vm_fault_page() unexpected error 0x%x\n @%s:%d"
            "shared_region_data_request(%p,0x%llx+0x%llx+0x%04llx): 0x%llx in sliding range [0x%llx:0x%llx]: SLIDE offset 0x%llx=(0x%llx+0x%llx+0x%llx+0x%04llx)[0x%016llx 0x%016llx] code_signed=%d cs_validated=%d cs_tainted=%d cs_nx=%d kr=0x%x\n"
        }
        symbol = "shared_region_pager_data_request"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s no object for file_control\n"
            "vm_map_with_linking"
        }
        symbol = "vm_map_with_linking"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s(): control NULL\n"
            "dyld_pager_init"
            "dyld_pager_init: memory_object_change_attributes() failed @%s:%d"
        }
        symbol = "dyld_pager_init"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "dyld_pager_data_return: should never happen! @%s:%d"
        }
        symbol = "compressor_memory_object_init.cold.1"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "dyld_pager_data_initialize: should never happen @%s:%d"
        }
        symbol = "vn_open_auth.cold.6"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "dyld_pager_data_request: vm_fault_page() unexpected error 0x%x\n @%s:%d"
            "%s(): Range not found for offset 0x%llx\n"
            "dyld_pager_data_request"
            "%s(): seg_info out of bounds\n"
            "%s(): seg->size out of bounds\n"
            "%s(): seg->size too small\n"
            "%s(): seg->page_count out of bounds\n"
            "%s(): seg->page_count too small\n"
            "%s(): No segment for user VA 0x%llx\n"
            "%s(): unknown pointer_format %d\n"
            "%s(): out of range segInfo->page_start[overflowIndex]"
            "fixupPage32"
        }
        symbol = "dyld_pager_data_request"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s(): Invalid ptr auth key %d\n"
            "signPointer"
        }
        symbol = "signPointer"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s out of range bind ordinal %u (max %u)\n"
        }
        symbol = "fixupPage64"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "swapfile_pager_init: memory_object_change_attributes() failed @%s:%d"
        }
        symbol = "swapfile_pager_init"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "swapfile_pager_data_return: should never get called @%s:%d"
        }
        symbol = "sysctl_register_oid.cold.2"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "swapfile_pager_data_initialize: should never get called @%s:%d"
        }
        symbol = "__ZN30AppleBCMWLANPCIeCompletionRing6commitEv"
        caller = "?"
    }
    new {
        args = 4
        anchors {
            "upl_abort_range: kernel_object being DUMPED @%s:%d"
        }
        symbol = "upl_abort_range"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "wire_count == 0, m = %p, obj = %p @%s:%d"
        }
        symbol = "upl_commit_range"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "vm_allocate failed - %d\n"
        }
        symbol = "kext_alloc"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "__RECEIPT_INFO"
            "__aux_kc_receipt"
        }
        symbol = "kext_receipt"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s is not supported on this kernel architecture (called from %s)\n"
            "kmod_get_info"
        }
        symbol = "kmod_get_info"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "__memmove_chk object size check failed: dst %p, src %p, (%zu < %zu) @%s:%d"
        }
        symbol = "__memmove_chk"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "__memset_chk object size check failed: dst %p, c %c, (%zu < %zu) @%s:%d"
        }
        symbol = "__memset_chk"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "__strlcat_chk object size check failed: dst %p, src %p, (%zu < %zu) @%s:%d"
        }
        symbol = "__strlcat_chk"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "__strlcpy_chk object size check failed: dst %p, src %p, (%zu < %zu) @%s:%d"
        }
        symbol = "__strlcpy_chk"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "__strncpy_chk object size check failed: dst %p, src %p, (%zu < %zu) @%s:%d"
        }
        symbol = "__strncpy_chk"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "__strncat_chk object size check failed: dst %p, src %p, (%zu < %zu + %zu + 1) @%s:%d"
        }
        symbol = "__strncat_chk"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "__strcpy_chk object size check failed: dst %p, src %p, (%zu < %zu + 1) @%s:%d"
        }
        symbol = "__strcpy_chk"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "__strcat_chk object size check failed: dst %p, src %p, (%zu < %zu + %zu + 1) @%s:%d"
        }
        symbol = "__strcat_chk"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "kperf: unable to parse '%s' as action sampler\n"
            "kperf: missing timer period in config\n"
            "kperf: unable to parse '%s' as timer period\n"
            "kperf: cannot enable sampling at boot: %d\n"
        }
        symbol = "kperf_kernel_configure"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "kperf: pending AST to non-current thread @%s:%d"
            "action.c"
        }
        symbol = "kperf_ast_pend"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "HUH @%s:%d"
            "callstack.c"
        }
        symbol = "kperf_ucallstack_pend"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "kperf: failed to create PET thread %d @%s:%d"
            "pet.c"
            "kperf-pet-sampling"
        }
        symbol = "kppet_config"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "kperf: timer fired at %llu, but sampling is disabled @%s:%d"
            "kperf: unknown sampling state 0x%x @%s:%d"
        }
        symbol = "kptimer_expire"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "kptimer"
        }
        symbol = "kptimer_set_count"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "kpc_percpu_alloc failed @%s:%d"
            "kpc_common.c"
        }
        symbol = "kpc_register_cpu"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "setting period %u\n"
        }
        symbol = "kpc_set_period"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "kpc: pm released counters\n"
        }
        symbol = "kpc_release_pm_counters"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Serial keyboard started\n"
            "serial_keyboard_init @%s:%d"
        }
        symbol = "serial_keyboard_init"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "serial_keyboard_poll: Shouldn't never ever get here... @%s:%d"
        }
        symbol = "serial_keyboard_poll"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "switch_to_old_console: unknown ops %d\n"
            "kPEDisableScreen %d\n"
            "kPEEnableScreen %d\n"
        }
        symbol = "PE_initialize_console"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Automatic NMI"
        }
        symbol = "_serial_getc_0"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "initialize_screen: b=%08llX, w=%08X, h=%08X, r=%08X, d=%08X\n"
            "initialize_screen: No video - forcing serial mode\n"
        }
        symbol = "initialize_screen"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "meter"
        }
        symbol = "vcattach"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "telemetry_buffer_size"
            "Telemetry: Allocation failed: %d\n"
            "telemetry_notification_leeway"
            "telemetry: nonsensical telemetry_notification_leeway boot-arg %d changed to %d\n"
            "telemetry_sample_rate"
            "telemetry_sample_all_tasks"
            "Telemetry: Sampling %stasks once per %u second%s\n"
        }
        symbol = "telemetry_init_0"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "telemetry: disabling ustackshot on PMI\n"
            "instructions"
            "cycles"
            "telemetry: ustackshot every %llu %s\n"
        }
        symbol = "telemetry_pmi_setup"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "bootprofile_buffer_size"
            "bootprofile_interval_ms"
            "bootprofile_stackshot_flags"
            "bootprofile_proc_name"
            "bootprofile_type"
            "Boot profile: Allocation failed: %d\n"
            "Boot profile: Sampling %s once per %u ms at %s\n"
            "all procs"
        }
        symbol = "bootprofile_init"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Telemetry (MACF): Allocation failed: %d\n"
        }
        symbol = "telemetry_macf_init_locked"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "cc_abort.c"
        }
        symbol = "cc_abort"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "random_cpu_init: kernel prng has not been installed @%s:%d"
            "ml_processor_register"
            "[%d]%s>pset_create(cluster_id=%d) returned pset %d\n"
            "[%d]%s>cpu_id %p cluster_id %d cpu_number %d is type %d\n"
        }
        symbol = "ml_processor_register"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "read_erandom ccdrbg error %d @%s:%d"
        }
        symbol = "read_erandom_generate"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "entropy-data"
        }
        symbol = "entropy_init"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "apple_protect_pager_init: memory_object_change_attributes() failed @%s:%d"
        }
        symbol = "apple_protect_pager_init"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "apple_protect_pager_data_return: should never get called @%s:%d"
        }
        symbol = "__ZN21AppleGPIOICController5startEP9IOService.cold.9"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "apple_protect_pager_data_initialize: should never get called @%s:%d"
        }
        symbol = "__Z18IOPCIRangeOptimizeP10IOPCIRange.cold.1_0"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "apple_protect_pager_data_request: vm_fault_page() unexpected error 0x%x\n @%s:%d"
            "apple_protect_data_request(%p,0x%llx+0x%llx+0x%04llx): out of crypto range [0x%llx:0x%llx]: COPY [0x%016llx 0x%016llx] code_signed=%d cs_validated=%d cs_tainted=%d cs_nx=%d\n"
            "apple_protect_data_request(%p,0x%llx+0x%llx+0x%04llx): in crypto range [0x%llx:0x%llx]: DECRYPT offset 0x%llx=(0x%llx-0x%llx+0x%llx+0x%llx+0x%04llx)[0x%016llx 0x%016llx] code_signed=%d cs_validated=%d cs_tainted=%d cs_nx=%d ret=0x%x\n"
        }
        symbol = "apple_protect_pager_data_request"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: failed pmap_enter, virt=%p, start_addr=%p, end_addr=%p, prot=%#x, flags=%#x @%s:%d"
            "pmap_map"
        }
        symbol = "pmap_map"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "pmap_map_bd @%s:%d"
        }
        symbol = "pmap_map_bd_with_options"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: area too large, pa_start=%p, len=%p, prot=0x%x @%s:%d"
            "%s: insufficient pages, pa_start=%p, len=%p, prot=0x%x @%s:%d"
        }
        symbol = "pmap_map_high_window_bd"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "pmap_asid_plru"
            "arm_maxoffset"
            "pmap_panic_dev_wimg_on_managed"
            "pmap-max-asids"
            "pmap-max-asids property is not a 32-bit integer @%s:%d"
            "pmap-max-asids 0x%x too large @%s:%d"
            "pmap-max-asids cannot be zero @%s:%d"
        }
        symbol = "pmap_bootstrap"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Panic occurred while attempting to lock PAI %u (%p):\n"
            "PAI is of type PVH_TYPE_NULL.\n"
            "PAI is of type PVH_TYPE_PTDP.\n"
            "PAI contains an IOMMU mapping, but the IOMMU state is invalid\n"
            "<No Driver Supplied Name>"
            "PTEP (%p) is an IOMMU mapping (state: %p) mapped by %s (on behalf of %s)\n"
            "Kernel"
            "PTEP (%p) is a %s CPU mapping (pmap: %p)\n"
            "\nTotal number of PTEPs: %u\n"
        }
        symbol = "pmap_panic_inspect_pai"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s: Passed in pmap doesn't own the page table to be deleted ptd=%p ptd->pmap=%p pmap=%p @%s:%d"
            "pmap_tte_deallocate"
        }
        symbol = "pmap_tte_deallocate"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "pmap_set_ptov_ap"
        }
        symbol = "pmap_set_ptov_ap"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "pmap_protect_options() pmap %p start 0x%llx end 0x%llx @%s:%d"
        }
        symbol = "pmap_protect_options"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: failed pmap_enter_addr, pmap=%p, va=%#llx, pa=%llu, size=%u, prot=%#x, flags=%#x @%s:%d"
            "pmap_map_block_addr"
        }
        symbol = "pmap_map_block_addr"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: failed with return code %d; pmap: 0x%016llx, v: 0x%016llx, wired: %s @%s:%d"
            "pmap_change_wiring"
        }
        symbol = "pmap_change_wiring"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s: failed to make forward progress from 0x%llx to 0x%llx at 0x%llx @%s:%d"
            "pmap_nest"
        }
        symbol = "pmap_nest"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: failed to insert the shared page, kr=%d, pmap=%p @%s:%d"
            "pmap_insert_commpage"
        }
        symbol = "pmap_insert_commpage"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s(%p): attempt to pin static mapping for page 0x%llx @%s:%d"
            "%s(%p): physical page 0x%llx belongs to PPL @%s:%d"
            "%s(%p): VA no longer mapped to physical page 0x%llx @%s:%d"
        }
        symbol = "pmap_pin_kernel_pages"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s(%p): physical page 0x%llx not pinned @%s:%d"
        }
        symbol = "pmap_unpin_kernel_pages"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: addr 0x%016llx doesn't have a valid kernel mapping @%s:%d"
            "%s: I/O filter entry found at 0x%016llx for %llu-byte wide register at va: 0x%016llx and pa: 0x%016llx, but I/O filter refused to write it. @%s:%d"
            "%s: width %llu not supported @%s:%d"
        }
        symbol = "pmap_iofilter_protected_write"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "initialized PPL provisioning profile data\n"
        }
        symbol = "pmap_initialize_provisioning_profiles"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "PMAP_CS: underflow on the max_profile_blob_size: %lu @%s:%d"
            "PMAP_CS: overflow on the profile_blob_size: %lu @%s:%d"
            "PMAP_CS: profile does not validate through CoreTrust: %d @%s:%d"
            "PMAP_CS: profile does not have any content: %p | %lu @%s:%d"
            "PMAP_CS: unable to create a CoreEntitlements context for the profile @%s:%d"
            "PMAP_CS: fatal error while setting up profile entitlements: %d @%s:%d"
            "PMAP_CS: Anomaly, profile already exists in the tree: %p @%s:%d"
        }
        symbol = "pmap_register_provisioning_profile_internal"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "PMAP_CS: unregistering an unknown profile: %p @%s:%d"
        }
        symbol = "pmap_unregister_provisioning_profile_internal"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "PMAP_CS: associating an unknown profile: %p @%s:%d"
            "PMAP_CS: attempted association with unverified profile: %p @%s:%d"
            "PMAP_CS: overflow on reference count for profile: %p @%s:%d"
        }
        symbol = "pmap_associate_provisioning_profile_internal"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "PMAP_CS: attempted to associate NULL kernel entitlements: %p @%s:%d"
        }
        symbol = "pmap_associate_kernel_entitlements_internal"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "pmap_resolve_kernel_entitlements_internal"
        }
        symbol = "pmap_resolve_kernel_entitlements_internal"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "PMAP_CS: unable to gauge index size for entitlements acceleration: %p | %s @%s:%d"
            "PMAP_CS: unable to accelerate entitlements: %p | %s @%s:%d"
            "PMAP_CS: entitlements not marked as accelerated: %p @%s:%d"
        }
        symbol = "pmap_accelerate_entitlements_internal"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "PMAP_CS [CoreEntitlements]: encountered an unrecoverable error @%s:%d"
        }
        symbol = "kernel_mach_msg_rpc.cold.3"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "PMAP_CS: CoreEntitlements allocating index without buffer @%s:%d"
            "PMAP_CS: CoreEntitlements allocating index with mismatched size: %lu | %u @%s:%d"
        }
        symbol = "pmap_cs_alloc_index"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "PMAP_CS: magic number mismatch on acceleration buffer: %u @%s:%d"
        }
        symbol = "pmap_cs_free_index"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "pai %d already locked down @%s:%d"
        }
        symbol = "pmap_static_allocations_done"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: L%d TTE is already empty. Potential double unmap or memory stomper? pmap=%p ttep=%p @%s:%d"
            "%s: Found inconsistent state in soon to be deleted L%d table: %d valid, %d compressed, %d non-empty, refcnt=%d, L%d tte=%#llx, pmap=%p, bpte=%p @%s:%d"
        }
        symbol = "pmap_tte_remove"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "pmap_tt_deallocate(): ptdp %p, count %d @%s:%d"
        }
        symbol = "pmap_tt_deallocate"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: no ptep? @%s:%d"
            "pmap_update_tt3e"
        }
        symbol = "pmap_update_tt3e"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "PMAP_CS: PNX bit not set for PTE: %p @%s:%d"
        }
        symbol = "validate_debug_pte"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "PMAP_CS: cannot query for entitlements as pmap_cs is disabled @%s:%d"
            "PMAP_CS: attempted to query kernel_pmap for entitlements @%s:%d"
            "check_entitlement_pmap"
        }
        symbol = "check_entitlement_pmap"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "PMAP_CS: compilation service binary signed as a main binary @%s:%d"
        }
        symbol = "code_signature_validate_constraints"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "LOCALSPKEY"
            "PMAP_CS: failed to validate serialized local signing entitlements constraint: %s @%s:%d"
            "PMAP_CS: failed acquiring unmanaged context for local signing entitlements: %s @%s:%d"
        }
        symbol = "validate_constraints_local_signing"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "PMAP_CS: AppleInternalProfile field not a boolean type in provisioning profile @%s:%d"
        }
        symbol = "validate_constraints_profile_preflight"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "PMAP_CS: passed in a NULL address @%s:%d"
            "PMAP_CS: address not within kernel memory: %p @%s:%d"
            "PMAP_CS: length causes an address overflow: %p + %lu @%s:%d"
            "PMAP_CS: address end not within kernel memory: %p @%s:%d"
            "PMAP_CS: address range spans through the read-only zone: %p through %p @%s:%d"
            "PMAP_CS: zero length data not allowed for: %p @%s:%d"
        }
        symbol = "pmap_cs_assert_addr"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "free blob to add unaligned: (%p,%p)/%zu @%s:%d"
            "blob free count overflow (bin %d, %d/%d) @%s:%d"
            "blob page count overflow (bin %d, %d/%d) @%s:%d"
        }
        symbol = "pmap_cs_blob_add_to_free_list"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: physical address is 0 @%s:%d"
            "pmap_alloc_page_for_kern"
        }
        symbol = "pmap_alloc_page_for_kern"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "%s: PVH entry at pai %d is locked down (%#lx), cannot remove @%s:%d"
            "%s: ptep=%p does not match pvh=%p (%p), pai=0x%x @%s:%d"
            "%s: ptep=%p (pai=0x%x) not in pvh=%p @%s:%d"
            "%s: unexpected PV head %p, ptep=%p pmap=%p pvh=%p pai=0x%x @%s:%d"
        }
        symbol = "pmap_remove_pv"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: %u addr 0x%llx is not page-aligned @%s:%d"
            "%s: %u length 0x%llx is not page-aligned @%s:%d"
            "%s: %u addr 0x%llx length 0x%llx wraps around @%s:%d"
            "%s: %u addr 0x%llx length 0x%llx overlaps physical memory @%s:%d"
        }
        symbol = "pmap_compute_io_rgns"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: io filter entry %u offset 0x%hx length 0x%hx crosses page boundary @%s:%d"
            "pmap_compute_io_filters"
        }
        symbol = "pmap_compute_io_filters"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: io filter entry %u and %u overlap. @%s:%d"
            "pmap_load_io_filters"
        }
        symbol = "pmap_load_io_filters"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: pmap array index %lu >= limit %lu @%s:%d"
            "%s: pmap %p does not match array element %p at index %lu @%s:%d"
            "%s: pmap %p is not in use @%s:%d"
        }
        symbol = "validate_user_pmap"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: failed, no pages available? kr=%d @%s:%d"
            "pmap_ppl_interface.c"
        }
        symbol = "mapping_free_prime"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Returned from exception_triage()? @%s:%d"
            "Trap with %d words of args? We only support 9. @%s:%d"
        }
        symbol = "mach_syscall"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "CTRR (MMU) Begin: %p End: %p, setting lockdown\n"
        }
        symbol = "rorgn_lockdown"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "/chosen/lock-regs"
            "lock-regs: /chosen/lock-regs not found (your iBoot or EDT may be too old) @%s:%d"
            "amcc-ctrr-a"
            "ioa-ctrr-a"
        }
        symbol = "amcc_find_lock_group_data"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "map aperture_phys_addr[%u]/%#x failed @%s:%d"
            "Inconsistent memory config @%s:%d"
        }
        symbol = "rorgn_stash_range"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "lock-regs: /chosen/lock-regs/%s not found @%s:%d"
            "aperture-count"
            "%s: %s %u exceeds maximum %u @%s:%d"
            "aperture-size"
            "%s: have %u apertures, but 0 size @%s:%d"
            "plane-count"
            "plane-stride"
            "%s: plane-count (%u) > 1, but stride is 0/missing @%s:%d"
            "%s: aperture-size (%#x) is insufficent to cover plane-count (%#x) of plane-stride (%#x) bytes @%s:%d"
            "aperture-phys-addr"
            "%s: missing required %s @%s:%d"
            "%s: aperture-phys-addr size (%#x) != (aperture-count (%#x) * PA size (%#zx) = %#lx) @%s:%d"
            "cache-status"
            "master-lock"
        }
        symbol = "_dt_get_lock_group"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s-reg-offset"
            "%s: missing property '%s' @%s:%d"
            "%s-reg-mask"
            "%s-reg-value"
        }
        symbol = "_dt_get_lock_reg"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "lock-regs: /chosen/lock-regs/%s/%s not found @%s:%d"
            "page-size-shift"
            "lower-limit"
            "upper-limit"
            "write-disable"
        }
        symbol = "_dt_get_lock_type"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Unknown CPU subtype... @%s:%d"
        }
        symbol = "cpu_init"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "cpu_start() cpu: %d\n"
        }
        symbol = "cpu_start"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "can't shutdown: PE_halt_restart returned %d @%s:%d"
        }
        symbol = "ml_arm_sleep"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "effective-production-status-ap"
        }
        symbol = "cpu_machine_idle_init"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "cpu_control(%d,%p,%d) not implemented\n"
        }
        symbol = "_Xprocessor_control"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "CPU%d failed to shut down @%s:%d"
            "CPU %d failed to reach ARM_CPU_ON_SLEEP_PATH: %d @%s:%d"
        }
        symbol = "cpu_exit_wait"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "cpu_xcall_internal: invalid cpu_number %d @%s:%d"
            "cpu_xcall_internal: cannot have null func/param: %p %p @%s:%d"
            "cpu_xcall_internal: cpu %d not initialized @%s:%d"
        }
        symbol = "cpu_xcall_internal"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "CPU%u has failed to respond to cross-call after %llu nanoseconds (timeout = %llu ns) @%s:%d"
            "cpu_signal of self while signals are disabled @%s:%d"
        }
        symbol = "cpu_signal_internal"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            " vm_cache_geometry_colors: %d\n"
            "%s() - %u bytes %s cache (I:%u D:%u (%s)), %u-way assoc, %u bytes/line\n"
            "do_cacheid"
            "unified"
            "separate"
        }
        symbol = "do_cacheid"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "user_ts_jop"
            "diversify_user_jop"
            "kernel_startup_bootstrap"
            "maxmem"
            "bpret"
            "immediate_NMI"
            "%s: Unable to find 'chosen' DT node @%s:%d"
            "dram-base"
            "%s: Unable to find 'dram-base' entry in the 'chosen' DT node @%s:%d"
            "dram-size"
            "%s: Unable to find 'dram-size' entry in the 'chosen' DT node @%s:%d"
            "kprintf initialized\n"
            "Serial mode specified: %08X\n"
            "drain_uart_sync"
            "WARNING: Forcing uart driver to output synchronously.printf()s/IOLogs will impact kernel performance.\nYou are advised to avoid using 'drain_uart_sync' boot-arg.\n"
            "WARNING: invalid serial boot-args : ON_DEMAND (0x%x) flag requires INPUT(0x%x). Ignoring ON_DEMAND.\n"
            "The cpumask=N boot arg cannot be used together with cpus=N, and the boot CPU must be enabled @%s:%d"
            "aprr_jit"
            "icdsb"
        }
        symbol = "arm_init"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "unexpected preemption count %u on boot cpu thread (should be %u) @%s:%d"
            "arm_cpu_init(): cpu %d online\n"
        }
        symbol = "arm_init_cpu"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "phystokv_range"
        }
        symbol = "phystokv_range"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: illegal VA: %p; virt base 0x%llx, size 0x%llx @%s:%d"
            "ml_static_vtop"
        }
        symbol = "ml_static_vtop"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Unexpected /chosen/memory-map/TrustCache property size %u != %zu @%s:%d"
            "Unexpected location of TrustCache region: %#lx != %#lx @%s:%d"
            "TrustCache region is in an unexpected place: %#lx > %#lx @%s:%d"
            "EXTRADATA is in an unexpected place: %#lx > %#lx @%s:%d"
            "AuxKC"
            "AuxKC-mach_header"
            "auxkc_base (%p) not below segLOWEST (%p) @%s:%d"
        }
        symbol = "arm_vm_prot_init"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Unsupported memory configuration %lx @%s:%d"
            "__PPLTEXT"
            "__PPLTRAMP"
            "__PPLDATA_CONST"
            "__PPLDATA"
            "__LAST"
            "__LASTDATA_CONST"
            "__hib_text"
            "__hib_const"
            "__HIBDATA"
            "use_contiguous_hint"
            "segLOWESTAuxKC (%p) not equal to segLOWEST (%p). auxkc_mh: %p, auxkc_base: %p @%s:%d"
        }
        symbol = "arm_vm_init"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s: PTOV table limit exceeded; segment va = 0x%llx, size = 0x%llx @%s:%d"
            "arm_vm_physmap_slide"
        }
        symbol = "arm_vm_physmap_slide"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: cpte=%#llx is not empty, vaddr=%#lx, pte=%#llx @%s:%d"
            "arm_vm_map"
        }
        symbol = "arm_vm_map"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "ml_probe_read() unimplemented @%s:%d"
        }
        symbol = "__ZL31IOShutdownNotificationsTimedOutPvS__0"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Not yet implemented. @%s:%d"
        }
        symbol = "__ZN30AppleT8101PlatformErrorHandler16_handleDCSErrorsEv.cold.1"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s address error: passed in address (%#llx) not a kernel managed address @%s:%d"
            "%s alignment error: tried accessing addresses spanning more than one page %#llx %#lx @%s:%d"
        }
        symbol = "apply_func_phys"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "ml_phys_read_data"
            "Invalid size %d for ml_phys_read_data @%s:%d"
            "Read from physical addr 0x%llx took %llu ns, result: 0x%016llx%016llx (start: %llu, end: %llu), ceiling: %llu @%s:%d"
        }
        symbol = "ml_phys_read_data"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "ml_phys_write_data"
            "Invalid size %d for ml_phys_write_data @%s:%d"
            "Write from physical addr 0x%llx took %llu ns, data: 0x%016llx%016llx (start: %llu, end: %llu), ceiling: %llu @%s:%d"
        }
        symbol = "ml_phys_write_data"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Invalid spinlock %p @%s:%d"
            "Lock not owned %p = %p @%s:%d"
            "Lock not owned by current thread %p = %p @%s:%d"
            "Lock owned by current thread %p = %p @%s:%d"
            "lck_spin_assert(): invalid arg (%u) @%s:%d"
        }
        symbol = "lck_spin_assert"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s at pc 0x%016llx, lr 0x%016llx (saved state: %p%s)\n\t  x0:  0x%016llx x1:  0x%016llx  x2:  0x%016llx  x3:  0x%016llx\n\t  x4:  0x%016llx x5:  0x%016llx  x6:  0x%016llx  x7:  0x%016llx\n\t  x8:  0x%016llx x9:  0x%016llx  x10: 0x%016llx  x11: 0x%016llx\n\t  x12: 0x%016llx x13: 0x%016llx  x14: 0x%016llx  x15: 0x%016llx\n\t  x16: 0x%016llx x17: 0x%016llx  x18: 0x%016llx  x19: 0x%016llx\n\t  x20: 0x%016llx x21: 0x%016llx  x22: 0x%016llx  x23: 0x%016llx\n\t  x24: 0x%016llx x25: 0x%016llx  x26: 0x%016llx  x27: 0x%016llx\n\t  x28: 0x%016llx fp:  0x%016llx  lr:  0x%016llx  sp:  0x%016llx\n\t  pc:  0x%016llx cpsr: 0x%08x         esr: 0x%016llx  far: 0x%016llx\n"
            " INVALID"
        }
        symbol = "panic_with_thread_kernel_state"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "Unexpected debugger trap while SP1 selected"
            "Synchronous exception taken while SP1 selected"
        }
        symbol = "sleh_synchronous_sp1"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Exception on 2-byte instruction, context=%p, esr=%#llx, far=%p @%s:%d"
            "Exception on 2-byte instruction"
            "Invalid SVC_64 context @%s:%d"
            "Kernel instruction fetch abort"
            "Unsupported Class %u event code. state=%p class=%u esr=%llu far=%p @%s:%d"
            "Hardware Breakpoint Debug exception from kernel. Panic (by design)"
            "Software Step Debug exception from kernel. Panic (by design)"
            "Illegal instruction set exception. state=%p class=%u esr=%llu far=%p spsr=0x%x @%s:%d"
            "Unexpected jitbox fault in the kernel, state=%p, esr=%#llx @%s:%d"
            "UC access exception from kernel, state=%p, esr=%#llx @%s:%d"
            "Unrecognized private exception, state=%p, esr=%#llx @%s:%d"
            "AMX exception from kernel, state=%p, esr=%#llx @%s:%d"
            "Unrecognized AMX exception, state=%p, esr=%#llx @%s:%d"
            "MSR/MRS trap (ESR 0x%llx) from 32-bit state @%s:%d"
            "MSR/MRS trap (ESR 0x%llx) from kernel @%s:%d"
        }
        symbol = "sleh_synchronous"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "attempt to set invalid recovery handler %p on kernel saved-state %p @%s:%d"
        }
        symbol = "panic_on_invalid_recovery_handler"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "Invalid kernel stack pointer (probable overflow)."
            "Invalid kernel stack pointer (probable corruption)."
        }
        symbol = "sleh_invalid_stack"
        caller = "?"
    }
    new {
        args = 3
        anchors {
            "Unexpected host abort from guest context"
        }
        symbol = "sleh_guest_synchronous"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "Undefined kernel instruction: pc=%p instr=%x @%s:%d"
        }
        symbol = "handle_uncategorized"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Break 0x%04X instruction exception from kernel. Ptrauth failure with %s key resulted in 0x%016llx"
            "0x%016llx"
            "0xFFFFFFFFFFFFFFFF"
        }
        symbol = "ptrauth_handle_brk_trap"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "panic: corrupt list around element %p"
            "panic: string operation caused an overflow"
        }
        symbol = "xnu_hard_trap_handle_breakpoint"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "PC alignment exception from kernel."
        }
        symbol = "handle_pc_align"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "SP alignment exception from kernel."
        }
        symbol = "handle_sp_align"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "Floating point exception from kernel"
            "Unrecognized floating point exception, state=%p, esr=%#llx @%s:%d"
        }
        symbol = "handle_fp_trap"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "SW_STEP_DEBUG exception from kernel."
            "SW_STEP_DEBUG exception thread DebugData is NULL."
        }
        symbol = "handle_sw_step_debug"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "User abort from non-interruptible context"
            "vm_fault() KERN_FAILURE from user fault on thread %p @%s:%d"
        }
        symbol = "handle_user_abort"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Unexpected residue @%s:%d"
            "Unexpected atomic LDST size %llu @%s:%d"
            "Unexpected SWP encoding, opc=%llu @%s:%d"
        }
        symbol = "handle_alignment_fault_from_user"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "Unexpected page fault under dtrace_probe"
            "Unexpected fault in kernel static region\n"
            "Unaligned kernel data abort."
            "Unclassified kernel abort (fault_code=0x%x)\n"
            "Kernel data abort."
        }
        symbol = "handle_kernel_abort"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "PAC failure (ESR 0x%llx) from 32-bit state @%s:%d"
            "PAC failure from kernel with %s key while authing %s"
            "PAC failure from kernel with %s key while returning"
            "PAC failure from kernel with %s key"
        }
        symbol = "handle_pac_fail"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "ESR (0x%llx) for instruction trapped from U32, but saved state is 64-bit. @%s:%d"
            "ESR (0x%llx) for instruction trapped from U32, actually came from kernel? @%s:%d"
        }
        symbol = "handle_user_trapped_instruction32"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "ESR (0x%llx) for SIMD trap from userland, actually came from kernel? @%s:%d"
        }
        symbol = "handle_simd_trap"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "vm_fault() KERN_FAILURE from guest fault on state %p @%s:%d"
        }
        symbol = "handle_guest_abort"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Unrecognized guest trap exception, state=%p, esr=%#llx @%s:%d"
        }
        symbol = "handle_guest_trap"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: Invalid required state size %lu @%s:%d"
            "sched_perfcontrol_register_callbacks"
        }
        symbol = "sched_perfcontrol_register_callbacks"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "siq_realtime_thread_mode"
            "Invalid siq_realtime_thread_mode %u @%s:%d"
        }
        symbol = "siq_init"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Invalidate HMAC function already set @%s:%d"
        }
        symbol = "set_invalidate_hmac_function"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Invalidate HMAC function wasn't set when needed @%s:%d"
        }
        symbol = "machine_lockdown"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "certificate-production-status"
        }
        symbol = "spr_lockdown"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "slto_us"
            "tlto_us"
            "mtxspin"
            "max_wfe_us"
        }
        symbol = "ml_init_lock_timeout"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "ml_cpu_down: cpu_signal of cpu %d failure %d @%s:%d"
            "boot cpu powering down with nowhere for its timers to go @%s:%d"
        }
        symbol = "ml_cpu_down"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "MACH Reboot\n"
            "CPU halted\n"
        }
        symbol = "halt_all_cpus"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "cpumask"
            "die-cluster-id"
            "cluster-core-id"
            "unable to retrieve state for cpu @%s:%d"
            "Wrong property size for %s @%s:%d"
            "chip-revision"
            "enable_skstb"
            "enable_skstsct"
            "cluster_power"
        }
        symbol = "ml_parse_cpu_topology"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "ml_static_protect(): %p < %p @%s:%d"
            "ml_static_protect(): WX request on %p @%s:%d"
            "ml_static_protect(): attempt to inject executable mapping on %p @%s:%d"
        }
        symbol = "ml_static_protect"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "Failed ml_static_mfree on %p @%s:%d"
        }
        symbol = "ml_static_mfree"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "wfe_events_sec"
        }
        symbol = "wfe_timeout_configure"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "invalid CPSR in user saved-state %p @%s:%d"
        }
        symbol = "ml_panic_on_invalid_old_cpsr"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "attempt to set non-user CPSR %#010x on user saved-state %p @%s:%d"
        }
        symbol = "ml_panic_on_invalid_new_cpsr"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Missing mandatory property '%s' @%s:%d"
        }
        symbol = "ml_readprop"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "com.apple.private.custom-x18-abi"
        }
        symbol = "machine_task_process_signature"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Unknown AMX feature ID bit has been set @%s:%d"
            "AMXIDR_EL1 doesn't advertise any known version of AMX @%s:%d"
        }
        symbol = "configure_misc_apple_regs"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Preemption count underflow @%s:%d"
            "preemption_disable.c"
        }
        symbol = "_enable_preemption_underflow"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Warning: clock is locked.  Can't get time\n"
            "mach_absolute_time: 0x%llx\n"
            "Epoch Time:        sec       usec\n"
            "  Boot    : 0x%08x 0x%08x\n"
            "  Sleep   : 0x%08x 0x%08x\n"
            "  Wake    : 0x%08x 0x%08x\n"
            "  Calendar: 0x%08x 0x%08x\n\n"
        }
        symbol = "panic_display_times"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "cpu_signal failed in DebuggerXCallEnter\n"
            "%s>found CPU %d offline, debugger_sync=%d\n"
            "%s>Debugger synch pending on cpu %d\n @%s:%d"
            "Attempting to forcibly halt cpu %d\n"
            "cpu %d failed to halt with error %d: %s\n"
            "cpu %d halted with warning %d: %s\n"
            "Unable to obtain state for cpu %d with status %d: %s\n"
            "cpu %d successfully halted\n"
            "Immediate halt requested on all cores\n"
            "Debugger synchronization timed out; timeout %llu nanoseconds\n"
        }
        symbol = "DebuggerXCallEnter"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Resuming from debugger synchronization failed: waited %llu nanoseconds\n @%s:%d"
        }
        symbol = "DebuggerXCallReturn"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s>found_mp_kdp_trap=true found_SIGPdebug=%s\n"
            "wait_while_mp_kdp_trap"
        }
        symbol = "wait_while_mp_kdp_trap"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "context switch with PAN disabled @%s:%d"
            "machine_switch_context @%s:%d"
        }
        symbol = "machine_switch_context"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "thread %p already has AMX saved state %p @%s:%d"
        }
        symbol = "machine_thread_amx_state_alloc"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "stack handoff with PAN disabled @%s:%d"
        }
        symbol = "machine_stack_handoff"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "arm_debug_set @%s:%d"
        }
        symbol = "arm_debug_set"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "rtclock timebase_callback: invalid constant %ld / %ld @%s:%d"
            "rtclock.c"
        }
        symbol = "timebase_callback"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "kdp panic: %s"
        }
        symbol = "kdp_panic"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: should not have been invoked. @%s:%d"
            "_was_in_userspace"
            "kdp_machdep.c"
        }
        symbol = "_was_in_userspace"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "hib bank[%d]: 0x%llx (%d) end 0x%llx (%d)\n"
        }
        symbol = "hibernate_page_list_allocate"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "monotonic: invalid core counter read: %u @%s:%d"
        }
        symbol = "mt_core_snap"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "mach_bridge_recv_timestamps"
        }
        symbol = "mach_bridge_recv_timestamps"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "mach_bridge_set_params"
        }
        symbol = "mach_bridge_set_params"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "sart %p: Invalid config for region %d size 0 @%s:%d"
        }
        symbol = "sart_set_registers"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "UAT PPL: Failed to acquire %p's lock because it has already been acquired by another thread. The IOUAT mutex should have prevented this scenario. @%s:%d"
        }
        symbol = "uat_lock"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "UAT PPL %p (%s): ttbr_index <--> state_object mismatch: vaddr(%#llx) @%s:%d"
            "UAT PPL %p (%s): address not page-aligned: vaddr(%#llx) PAGE_SIZE(%#llx) @%s:%d"
            "UAT PPL %p (%s): size not a multiple of PAGE_SIZE: vaddr(%#llx) size(%#llx) PAGE_SIZE(%#llx) @%s:%d"
            "UAT PPL %p (%s): region wraps round: vaddr(%#llx) size(%#llx) last_vaddr(%#llx) @%s:%d"
            "UAT PPL %p (%s): region not wholly within permitted inclusive range: vaddr(%#llx) min_vaddr(%#llx) size(%#llx) last_vaddr(%#llx) max_vaddr(%#llx) @%s:%d"
        }
        symbol = "uat_validate_vaddr"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "hmac-reg-base"
            "%s: hmac register base is zero @%s:%d"
        }
        symbol = "secure_hmac_get_reg_base"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "pmgr-reg-base"
            "%s: pmgr register base is zero @%s:%d"
        }
        symbol = "secure_hmac_get_aes_reg_base"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "secure_hmac_get_aes_offset"
            "pmgr-aes-offset"
        }
        symbol = "secure_hmac_get_aes_offset"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: failed to initialize PPL state object: 0x%x @%s:%d"
            "secure_hmac_init"
        }
        symbol = "secure_hmac_init"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: pmap_iommu_map failed: 0x%x @%s:%d"
            "secure_hmac_hibernate_begin"
        }
        symbol = "secure_hmac_hibernate_begin"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: Only non-wired memory should be getting hashed during hibernation restore @%s:%d"
        }
        symbol = "secure_hmac_reset"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: output_len should be %d but is %zu @%s:%d"
            "%s: PPL ioctl PPL_HIB_IOCTL_FINAL failed: 0x%x @%s:%d"
        }
        symbol = "secure_hmac_final"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: PPL ioctl PPL_HIB_IOCTL_FETCH_HIBSEG failed: 0x%x @%s:%d"
            "%s: PPL ioctl PPL_HIB_IOCTL_FETCH_HIBSEG_INFO failed: 0x%x @%s:%d"
        }
        symbol = "secure_hmac_fetch_hibseg_and_info"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: PPL ioctl PPL_HIB_IOCTL_COMPUTE_RORGN_HMAC failed: 0x%x @%s:%d"
            "secure_hmac_compute_rorgn_hmac"
        }
        symbol = "secure_hmac_compute_rorgn_hmac"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: PPL ioctl PPL_HIB_IOCTL_FETCH_RORGN_SHA failed: 0x%x\n @%s:%d"
        }
        symbol = "secure_hmac_fetch_rorgn_sha"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: PPL ioctl PPL_HIB_IOCTL_FETCH_RORGN_HMAC failed: 0x%x\n @%s:%d"
        }
        symbol = "secure_hmac_fetch_rorgn_hmac"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: hmac_len should be %d but is %zu @%s:%d"
            "%s: PPL ioctl PPL_HIB_IOCTL_FINALIZE_IMAGE failed: 0x%x @%s:%d"
        }
        symbol = "secure_hmac_finalize_image"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: PPL ioctl PPL_HIB_IOCTL_GET_IO_RANGES failed: 0x%x @%s:%d"
            "secure_hmac_get_io_ranges"
        }
        symbol = "secure_hmac_get_io_ranges"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "apple-isa-vm-quota"
            "hv_apple_isa_vm_quota"
            "hv_vm"
        }
        symbol = "hv_init"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "3B878185-AA62-4E1F-9DC9-D6799CBB6EBB"
        }
        symbol = "hv_trap_vcpu_run"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Unexpected failure to free VA space we just allocated: %d! @%s:%d"
        }
        symbol = "mmap_jitbox_region"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "LLC_ERR_STS/ADR/INF=%#llx/%#llx/%#llx LSU_ERR_STS=%#llx FED_ERR_STS=%#llx MMU_ERR_STS=%#llx DPC_ERR_STS=%#llx"
            "LLC dup tag multi-hit error by CPU %d: FAR=%#lx way_mask=%#x err_sts: (%s) @%s:%d"
            "way predictor"
            "LLC %s multi-hit error: FAR=%#lx way_mask=%#x err_sts: (%s) @%s:%d"
            "L2 RAM addr out of range"
            "LLC %s error: FAR=%#lx err_sts: (%s) @%s:%d"
            "Unhandled %c-core error: %s @%s:%d"
            "%s err (%s) %son %c-core: FAR=%#llx %s_ERR_STS=%#llx err_sts: (%s) @%s:%d"
            " (UNKNOWN)"
            " (Normal completion)"
            " (Decode error)"
            " (Slave error)"
            " (Bus error)"
            " (Non-recoverable Uncorrected)"
            " (AMX Uncorrected)"
            " (Recoverable Uncorrected)"
            " (Unavailable)"
            " (Reserved)"
            "cpu%d"
            "cpu%d: LLC %s error%s from %s: FAR=%#lx addr=%#llx cmd=%#x(%s) err_sts: (%s) @%s:%d"
            "single-bit ECC counter overflow"
            "single-bit ECC"
            "LLC %s error: FAR=%#lx way=%#x syndrome=%#x err_sts: (%s) @%s:%d"
            "double-bit cache ECC overflow"
            "double-bit cache ECC"
            "LLC %s error: FAR=%#lx way=0x%x syndrome=%#x cmd=%#x(%s) err_sts: (%s) @%s:%d"
            "Uncontained LLC AMX %s error: FAR=%#lx way=0x%x syndrome=%#x cmd=%#x(%s) err_sts: (%s) @%s:%d"
            "Unhandled recoverable LLC %s error: FAR=%#lx way=0x%x syndrome=%#x cmd=%#x(%s) err_sts: (%s) @%s:%d"
        }
        symbol = "generic_platform_error_handler"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "l2-ecc-correctable-panic"
        }
        symbol = "init_generic_platform_error_handler"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "(va=0x%#llx) "
        }
        symbol = "format_va"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "(va=%#llx) "
        }
        symbol = "format_va_or_tlb_set_way"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "(PIO offset from this cluster: %#llx, info=%#llx AFID=%#llx%s)"
        }
        symbol = "format_multiple_err_and_pio_addr"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "(multiple errors) "
        }
        symbol = "format_multiple_err"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "(info=%#llx%s) "
        }
        symbol = "format_multiple_err_and_raw_info"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "[bti_telemetry] bti_telemetry_init\n"
        }
        symbol = "bti_telemetry_init"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Unexpectedly found multiple concurrent drains! @%s:%d"
            "Unexpected duplicate splay entry! @%s:%d"
            "Unexpectedly could not acquire telemetry lock (nested acquire will deadlock) @%s:%d"
            "[bti_telemetry] Unexpected BTI exception (pc=0x%08lx, BTYPE=%d)\n[bti_telemetry] \t<UUID: %s, offset: 0x%08lx>\n"
        }
        symbol = "drain_record_submission_buffer_thread_call"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "nfsvc_addsock:: nfsrv_check_exports_allow_address(myname) returned %d\n"
            "nfssvc_addsock: socket buffer setting SO_SNDBUF to %llu error(s) %d\n"
            "nfssvc_addsock: socket buffer setting SO_RCVBUF to %llu error(s) %d\n"
            "nfssvc_addsock: socket timeout setting SO_RCVTIMEO error(s) %d\n"
            "nfssvc_addsock: socket timeout setting SO_SNDTIMEO error(s) %d\n"
        }
        symbol = "nfssvc_addsock"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "NFS server: NULL reply from proc = %d error = %d\n"
            "mbuf siz=%d\n"
            "Bad nfs svc reply @%s:%d"
            "nfs_syscalls.c"
        }
        symbol = "nfssvc_nfsd"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "Server header: gss_krb5_verify_mic_mbuf failed %d\n"
            "Server args: gss_krb5_verify_mic_mbuf failed %d\n"
            "%s: gss_krb5_unwrap_mbuf failes %d\n"
            "%s: Sequence number mismatch seqnum = %d nd->nd_gss_seqnum = %d\n"
            "reply_mbuf"
            "reply_mbuf %p nmc_head %p\n"
        }
        symbol = "nfs_gss_svc_cred_get"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: %d: is running\n"
            "%s: %d: Removing contex for %d\n"
        }
        symbol = "nfs_gss_svc_ctx_timer"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "gss_krb5_get_mic_mbuf failed %d\n"
        }
        symbol = "nfs_gss_svc_protect_reply"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "nfs_gss_svc_gssd_upcall: can't get gssd port, status %x (%d)\n"
            "nfs_gss_svc_gssd_upcall: gssd port not valid\n"
            "Calling mach_gss_accept_sec_context\n"
            "mach_gss_accept_sec_context returned %d\n"
            "nfs_gss_svc_gssd_upcall failed: %x (%d)\n"
            "nfs_gss_svc_gssd_upcall: bad context length (%d)\n"
            "Failed to make context from lucid_ctx_buffer\n"
            "nfs_gss_svc_gssd_upcall: could not allocate %d bytes\n"
        }
        symbol = "nfs_gss_svc_ctx_init"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "nfs_gss_mach_alloc_buffer: vm_map_round_page failed\n"
            "nfs_gss_mach_alloc_buffer: vm_allocate failed\n"
            "nfs_gss_mach_alloc_buffer: vm_map_unwire failed\n"
            "nfs_gss_mach_alloc_buffer: vm_map_copyin failed\n"
        }
        symbol = "nfs_gss_mach_alloc_buffer"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "nfsrv_send"
            "nfsrv_send\n"
        }
        symbol = "nfsrv_send"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "nfsrv_rcv: mbuf_setnext failed %d @%s:%d"
            "nfsrv_rcv: mbuf_setnext failed\n"
        }
        symbol = "nfsrv_rcv_locked"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "nfs getstream @%s:%d"
            "nfsrv_getstream: nfsrv_unprocessed_rpc_current (%u) has reached the max allowed consumption (%u)\n"
            "nfsrv_getstream: mbuf_setnext failed\n"
            "nfsrv_getstream: mbuf_setnext failed 3, %d @%s:%d"
        }
        symbol = "nfsrv_getstream"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "nfsrv cache @%s:%d"
            "nfs_srvcache.c"
            "nfsrv cache: reply alloc failed for nonidem request hit\n"
            "nfsrv cache: reply copym failed for nonidem request hit\n"
            "nfsrv cache: nam copym failed\n"
        }
        symbol = "nfsrv_getcache"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s:%d %s\n"
            "%2.2x "
            "%s    "
        }
        symbol = "nfs_dump_mbuf"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "got NULL mbuf? @%s:%d"
            "nfs_subs.c"
        }
        symbol = "nfsm_chain_new_mbuf"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "nfsrv_free_addrlist: invalid socket address (%u)\n"
            "nfsrv_free_addrlist: address not found (0)\n"
            "nfsrv_free_addrlist: address not found (1)\n"
        }
        symbol = "_nfsrv_free_addrlist"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "nfsrv_export: warning: nested exports: %s/%s\n"
        }
        symbol = "nfsrv_export"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "nfsrv_uc_dequeue_wait"
            "nfsrv_uc_dequeue remove %p\n"
        }
        symbol = "nfsrv_uc_dequeue"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "nfsd_upcall_shutdown_stop"
        }
        symbol = "nfsrv_uc_cleanup"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "nfsd_upcall_shutdown_wait"
            "nfsd: Could not start nfsd proxy up-call service. Falling back\n"
        }
        symbol = "nfsrv_uc_addsock"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "nfsd_upcall_handler"
        }
        symbol = "nfsrv_uc_thread"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "nfsd up-call queue limit exceeded @%s:%d"
            "nfs_upcall.c"
        }
        symbol = "nfsrv_uc_proxy"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s mbuf = %p offset = %d len = %d:\n"
            "Count chars %d\n"
        }
        symbol = "printmbuf"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "buffer"
        }
        symbol = "printgbuf"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Token id does not match\n"
            "Bad flags %x\n"
            "krb5_cfx_crypt_mbuf %d\n"
            "Encrypted token mismach\n"
        }
        symbol = "gss_krb5_cfx_unwrap_mbuf"
        caller = "?"
    }
    new {
        args = 4
        anchors {
            "Bad mic TOK_ID %x %x\n"
            "Bad flags received %x exptect %x\n"
            "Bad mic filler %x @ %d\n"
        }
        symbol = "gss_krb5_cfx_verify_mic_mbuf"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: bad framing\n"
            "%s: invalid length\n"
            "%s: token to short"
            "toklen = %d, length = %d\n"
            "%s: Invalid mechanism\n"
            "%s: Invalid body\n"
            "%s: Invalid des mac\n"
        }
        symbol = "gss_krb5_3des_token_get"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: invalid version %d\n"
            "%s: Could not decode initiate\n"
            "%s: Could not decode endtime\n"
            "%s: Could not decode send_seq\n"
            "%s: Could not decode recv_seq\n"
            "%s: Could not decode mech protocol\n"
            "%s: Could not decode rfc1964 sign and seal\n"
            "%s: Could not decode rfc4121 acceptor_subkey"
            "%s: Invalid mech protocol %d\n"
            "%s: Could not decode key enctype\n"
            "%s: could not decode key length\n"
            "%s: etype = %d keylen = %d expected keylen = %d\n"
            "%s: could not get memory for key\n"
            "%s: could get key value\n"
        }
        symbol = "gss_krb5_make_context"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "netboot: no suitable interface\n"
            "netboot: using network interface '%s'\n"
            "netboot: socreate, error=%d\n"
            "netboot: SIFFLAGS, error=%d\n"
            "netboot: can't retrieve IP parameters\n"
            "netboot: IP address %d.%d.%d.%d"
            " netmask %d.%d.%d.%d"
            " router %d.%d.%d.%d"
            "netboot: inet_aifaddr failed, %d\n"
            "netboot: adding default route %d.%d.%d.%d\n"
            "netboot: default_route_add failed %d\n"
            "dhcp-response"
            "netboot: retrieving IP information from DHCP response\n"
            "netboot: retrieving IP information from BOOTP response\n"
            "rootpath"
            "netboot_info_init: rp0='%s' isn't a network path, ignoring\n"
            "netboot: NFS boot is deprecated\n"
            "http:"
            "netboot: HTTP URL %s\n"
            "netboot: root path uses unrecognized format\n"
            "netboot: nested image %s\n"
            "bsdp-response"
            "netboot: retrieving root path from BSDP response\n"
            "netboot: retrieving root path from BOOTP response\n"
        }
        symbol = "netboot_mountroot"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "netboot_setup: calling imageboot_mount_image\n"
        }
        symbol = "netboot_setup"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "failed to register provider '%s': invalid arguments"
            "<NULL>"
            "failed to register provider '%s': invalid provider name"
            "failed to register provider '%s': invalid provider ops"
            "failed to register provider '%s': invalid provider attributes"
            "failed to register provider '%s': invalid privilege attributes"
            "failed to register provider '%s': need dtps_usermode() op for given privilege attributes"
        }
        symbol = "dtrace_register"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "attempt to unregister non-existent dtrace provider %p\n @%s:%d"
        }
        symbol = "dtrace_unregister"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "failed to register meta-provider: invalid name"
            "failed to register meta-register %s: invalid ops"
            "failed to register meta-register %s: user-land meta-provider exists"
        }
        symbol = "dtrace_meta_register"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "helper_init before dtrace_init @%s:%d"
            "helper_init: failed to allocate a major number!\n"
            "dtracehelper"
            "dtrace_init: failed to devfs_make_node for helper!\n"
            "helper_init: called twice! @%s:%d"
        }
        symbol = "helper_init"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "dtrace_kernel_symbol_mode"
        }
        symbol = "kernel_bootstrap_thread"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "dtrace_init: failed to retrieve the hw.memsize, defaulted to %lld bytes\n"
            "dtrace_init: failed to allocate a major number!\n"
            "dtrace_init: failed to devfs_make_node_clone for dtrace!\n"
            "dtrace_dof_mode"
            "dtrace_init: called twice! @%s:%d"
        }
        symbol = "dtrace_init"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "dtrace_postinit: Could not register mach_kernel modctl\n"
            "illegal value (%lu) for dtrace_retain_max; setting to 1"
            "BEGIN"
            "dof-data-%d"
            "failed to create anonymous state"
            "unreadable DOF"
            "truncated header"
            "truncated DOF"
            "invalid DOF size"
            "oversized DOF"
            "enabling probe %d (%s:%s:%s:%s)"
        }
        symbol = "dtrace_postinit"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "(scope == DIFV_SCOPE_GLOBAL && size <= maxglobalsize) || (scope == DIFV_SCOPE_LOCAL && size <= maxlocalsize)"
        }
        symbol = "dtrace_canstore_remains"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "inprobe == 0 || id == dtrace_probeid_error"
        }
        symbol = "dtrace_probe"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "id < (uint_t)vstate->dtvs_nglobals"
            "id < (uint_t)vstate->dtvs_nlocals"
            "id < (uint_t)vstate->dtvs_ntlocals"
        }
        symbol = "dtrace_dif_emulate"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "dtrace: panic action at probe %s:%s:%s:%s (ecb %p) @%s:%d"
        }
        symbol = "dtrace_action_panic"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "attempt to unref non-existent string %s @%s:%d"
        }
        symbol = "dtrace_strunref"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "state->dts_formats[ndx]->dtf_refcount < UINT64_MAX"
        }
        symbol = "dtrace_ecb_create_enable"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "fmt->dtf_refcount > 0"
        }
        symbol = "dtrace_ecb_destroy"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "returned value did not match expected generation"
        }
        symbol = "dtrace_lazy_dofs_process"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "helper"
            "ustack"
            "unmatched helpers"
            "misaligned section offset"
            "provider section too small"
            "invalid provider name"
            "invalid entry size"
            "misaligned entry size"
            "invalid function name"
            "function name too long"
            "invalid probe name"
            "invalid probe offset"
            "is-enabled offsets with null section"
            "invalid is-enabled offset"
            "zero probe and is-enabled offsets"
            "zero probe offsets"
            "invalid args"
            "bad native argument type"
            "native argument type too long"
            "bad native argument index"
            "bad translated argument type"
            "translated argument type too long"
        }
        symbol = "dtrace_helper_slurp"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "DOF magic string mismatch"
            "DOF has invalid data model"
            "DOF encoding mismatch"
            "DOF version mismatch"
            "DOF uses unsupported instruction set"
            "DOF uses too many integer registers"
            "DOF uses too many tuple registers"
            "DOF has invalid ident byte set"
            "DOF has invalid flag bits set"
            "invalid section header size"
            "truncated section headers"
            "misaligned section headers"
            "misaligned section size"
            "illegal sections for enabling"
            "bad section alignment"
            "misaligned section"
            "corrupt section header"
            "non-terminating string table"
        }
        symbol = "dtrace_dof_slurp"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Non loadable section with ECB description"
            "truncated ECB description"
            "bad alignment in ECB description"
            "invalid probe section"
            "bad alignment in probe description"
            "truncated probe description"
            "corrupt probe provider"
            "corrupt probe module"
            "corrupt probe function"
            "corrupt probe name"
        }
        symbol = "dtrace_dof_ecbdesc"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "invalid DIFO header section"
            "bad alignment in DIFO header"
            "bad size in DIFO header"
            "exceeds maximum size"
            "bad alignment"
            "entry size mismatch"
            "corrupt entry size"
            "unrecognized DIFO subsection"
            "missing DIF text"
            "cannot write to 0 address\n"
            "invalid branch target %u\n"
            "backward branch to %u\n"
            "invalid integer ref %u\n"
            "invalid string ref %u\n"
            "invalid ref type %u\n"
            "invalid val type %u\n"
            "invalid key\n"
            "expected 'ret' as last DIF instruction\n"
            "bad return size\n"
            "unrecognized variable scope %d\n"
            "unrecognized variable type %d\n"
            "%d exceeds variable id limit\n"
            "zero-sized variable\n"
            "oversized by-ref static\n"
            "%d changed variable kind\n"
            "%d changed variable type flags\n"
            "%d changed variable type size\n"
        }
        symbol = "dtrace_dof_difo"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "dtrace DIF object error: [%u]: "
        }
        symbol = "dtrace_difo_err"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "invalid action section"
            "truncated action description"
            "bad alignment in action description"
            "section entry size exceeds total size"
            "bad entry size in action description"
            "actions exceed dtrace_actions_max"
            "bogus format string"
            "empty format string"
        }
        symbol = "dtrace_dof_actdesc"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "illegal variable %u\n"
            "illegal dynamic variable load\n"
            "illegal dynamic variable store\n"
        }
        symbol = "dtrace_difo_validate_helper"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "dtrace_open: couldn\\'t acquire minor number %d. This usually means that too many DTrace clients are in use at the moment"
            "dtrace_aggid_%d"
        }
        symbol = "dtrace_state_create"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "unloaded module '%s' had enabled probes"
        }
        symbol = "dtrace_module_unloaded"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "security restrictions disallow DTRACEIOC_MODUUIDSLIST"
            "dtrace_kernel_symbol_mode of %u disallows DTRACEIOC_MODUUIDSLIST"
            "failed to copyin dtmul_count"
            "dtmul_count is not valid"
            "failed copyin of dtrace_module_uuids_list_t"
            "failed copyout of dtrace_symbolsdesc_list_t"
            "dtrace_kernel_symbol_mode of %u disallows DTRACEIOC_PROVMODSYMS"
            "failed to copyin dtmodsyms_count"
            "Invalid dtmodsyms_count value"
            "Invalid module_symbols_size %ld"
            "failed copyin of dtrace_module_symbols_t"
        }
        symbol = "_dtrace_ioctl"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Non loadable option section"
            "bad alignment in option description"
            "zeroed option entry size"
            "bad option entry size"
            "non-zero option string"
            "unset option"
            "rejected option"
        }
        symbol = "dtrace_dof_options"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "dstate->dtds_chunksize < (LONG_MAX - sizeof (dtrace_dynhash_t))"
            "(uintptr_t)start < limit"
            "(uintptr_t)start >= (uintptr_t)base"
            "limit <= (uintptr_t)base + size"
            "(uintptr_t)dvar >= (uintptr_t)base && (uintptr_t)dvar <= (uintptr_t)base + size"
        }
        symbol = "dtrace_state_go"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "failed to copyin dofiod_count"
            "dofiod_count is not valid"
            "failed copyin of dof_ioctl_data_t"
            "failed copyout of dof_ioctl_data_t"
            "lazy_dofs_add merged_dofs_count out of range"
        }
        symbol = "helper_ioctl"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "dtrace load module already exists '%s %u' is failing against '%s %u'"
            "dtrace module load '%s %u' is failing "
        }
        symbol = "dtrace_module_loaded"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "lockstat_init: failed to allocate a major number!\n"
        }
        symbol = "lockstat_init"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "dtrace_proc_waitfor"
        }
        symbol = "dtrace_proc_waitfor"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "attempt to remove non-existent invop handler @%s:%d"
            "dtrace_subr.c"
        }
        symbol = "dtrace_invop_remove"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "timer_call_cancel() failed to cancel a timer call: %p @%s:%d"
        }
        symbol = "dtrace_cpu_state_changed"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "vmem_alloc: failure after blist_resize! @%s:%d"
        }
        symbol = "vmem_alloc"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "blist_meta_alloc: allocation too large @%s:%d"
        }
        symbol = "blst_meta_alloc"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "blst_meta_free: freeing already free blocks (%d) %d/%d @%s:%d"
            "blst_meta_free: freeing unexpected range @%s:%d"
        }
        symbol = "blst_meta_free"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "fbt_init: failed to allocate a major number!\n"
            "IgnoreFBTBlacklist"
        }
        symbol = "fbt_init"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "SDT: unable to find prelink info\n"
        }
        symbol = "sdt_early_init"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "SDT: No kernel symbols for %s\n"
            "__sdt"
        }
        symbol = "sdt_load_machsect"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "sdt_init: failed to allocate a major number!\n"
            "/dev/sdt couldn\\'t create minor node"
            "failed to register sdt provider %s"
        }
        symbol = "sdt_init"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Ignoring probes from unsupported provider %s\n"
            "Ignoring probe %s (no symbol name)\n"
        }
        symbol = "__sdt_provide_module"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "systrace_init: failed to allocate a major number!\n"
            "systrace"
            "machtrace"
            "mach_trap"
        }
        symbol = "systrace_init"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "profile_init: failed to allocate a major number!\n"
        }
        symbol = "profile_init"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "hrtime_t"
        }
        symbol = "profile_getargdesc"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "fasttrap_init: failed to allocate a major number!\n"
            "Could not create fasttrap_cleanup_thread @%s:%d"
            "fasttrap.c"
            "dtrace_fasttrap_cleanup_thread"
            "dtrace.fasttrap_probe_t[1]"
            "dtrace.fasttrap_probe_t[2]"
            "dtrace.fasttrap_probe_t[3]"
        }
        symbol = "fasttrap_init"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Failed to install fasttrap probe for pid %d: Process does not allow invalid code pages\n"
            "Failed to install fasttrap probe for pid %d: Failed to re-acquire process\n"
        }
        symbol = "fasttrap_pid_enable"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "fasttrap_fork: sprlock(%d) returned a different proc\n"
            "fasttrap_fork: failed to re-acquire proc\n"
        }
        symbol = "fasttrap_fork"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "failed to instantiate provider %s: name too long to accomodate pid"
            "failed to instantiate provider %s: %s is an invalid name"
            "failed to instantiate provider %s for process %u"
        }
        symbol = "fasttrap_meta_provide"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "userland struct sigvec *"
            "userland struct sigaltstack *"
            "userland struct rusage *"
            "userland unsigned char *"
            "userland struct statfs *"
            "userland fhandle_t *"
            "userland void **"
            "userland struct rlimit *"
            "userland const struct fhandle *"
            "userland sem_t *"
            "userland struct statfs64 *"
            "userland au_id_t *"
            "userland struct auditinfo_addr *"
            "au_asid_t"
            "userland struct nxctl_init *"
            "userland struct ch_init *"
            "userland struct net_qos_param *"
            "userland struct timex *"
            "userland struct ntptimeval *"
        }
        symbol = "systrace_entry_setargdesc"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "random_init: failed to allocate a major number! @%s:%d"
            "randomdev.c"
            "random"
            "urandom"
        }
        symbol = "random_init"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "mdevadd: attempt to add overlapping memory device at %016llX-%016llX @%s:%d"
            "mdevadd: attempt to add more than %d memory devices @%s:%d"
            "mdevadd: attempt to explicitly add a bogus memory device: %08X @%s:%d"
            "mdevadd: attempt to explicitly add a previously defined memory device: %08X @%s:%d"
            "mdevadd: error - bdevsw_add() returned %d\n"
            "ramdevice_init: error - cdevsw_add() returned %d\n"
            "mdevadd: devfs_make_node for block failed!\n"
            "rmd%d"
            "mdevadd: devfs_make_node for character failed!\n"
            "Added memory device md%x/rmd%x (%08X/%08X) at %016llX for %016llX\n"
        }
        symbol = "mdevadd"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "ramstrategy: buf_map failed @%s:%d"
            "mdevstrategy: sink address %016llX not mapped @%s:%d"
            "mdevstrategy: source address %016llX not mapped @%s:%d"
        }
        symbol = "mdevstrategy"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "kern.maxvnodes"
        }
        symbol = "bsd_startupearly"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "mbuf_pool"
        }
        symbol = "bsd_mbuf_cluster_reserve"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "monotonic: cdevsw_add failed: %d @%s:%d"
            "monotonic: devfs_make_node failed for '%s' @%s:%d"
        }
        symbol = "mt_dev_init"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Directory expected to have fg_vn_data @%s:%d"
        }
        symbol = "getattrlistbulk"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "buf_strategy: b_vp == NULL || vtype == VCHR | VBLK @%s:%d"
        }
        symbol = "buf_strategy"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "vnode_flushdirtyblks"
        }
        symbol = "buf_flushdirtyblks_skipinfo"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "using %d buffer headers and %d cluster IO buffer headers\n"
            "Couldn\\'t register buffer cache callout for vm pressure! @%s:%d"
        }
        symbol = "bufinit"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "buf_bdwrite"
        }
        symbol = "bdwrite_internal"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "buf_brelse: bad buffer = %p @%s:%d"
            "brelse: bp @ %p has NULL b_iodone! @%s:%d"
            "brelse: Failed to create UPL @%s:%d"
            "ubc_upl_unmap failed @%s:%d"
            "brelse: UPL set for non VREG; vp=%p @%s:%d"
            "buf_brelse_shadow: bp_head on freelist %d @%s:%d"
            "buf_brelse_shadow: bp not on list %p @%s:%d"
            "buf_relse_shadow: b_shadow != NULL && b_shadow_ref == 0  bp(%p) @%s:%d"
            "buf_relse_shadow: b_shadow == NULL && b_shadow_ref != 0  bp(%p) @%s:%d"
        }
        symbol = "buf_brelse"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "buf_getblk"
            "getblk: paging or unknown operation for incore busy buffer - %x @%s:%d"
            "buffer has UPL, but not marked BUSY: %p @%s:%d"
            "getblk: paging or unknown operation for incore buffer- %d @%s:%d"
            "bp already has UPL: %p @%s:%d"
            "getblk: VNOP_BLOCKMAP failed @%s:%d"
            "getblk: paging or unknown operation - %x @%s:%d"
            "bgetvp_locked: not free @%s:%d"
        }
        symbol = "buf_getblk"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "allocbuf: buffer larger than MAXBSIZE requested @%s:%d"
        }
        symbol = "allocbuf"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "buf_invalblkno"
        }
        symbol = "buf_invalblkno"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "buf_biowait"
        }
        symbol = "buf_biowait"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "biodone already @%s:%d"
            "biodone: bp @ %p has NULL b_iodone! @%s:%d"
        }
        symbol = "buf_biodone"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "alloc_io_buf (1)"
            "alloc_io_buf (2)"
        }
        symbol = "alloc_io_buf"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "free_io_buf: bp(%p) - bufstats.bufs_iobufinuse < 0 @%s:%d"
        }
        symbol = "free_io_buf"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "buf_reassign: NULL"
        }
        symbol = "buf_reassign"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "bremfree_locked: %p not on freelist @%s:%d"
            "bremfree: lost tail @%s:%d"
        }
        symbol = "bremfree_locked"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "getnewbuf: bp @ %p is LOCKED or BUSY! (flags 0x%x) @%s:%d"
        }
        symbol = "getnewbuf"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "buf_acquire"
        }
        symbol = "buf_acquire_locked"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "blaundry"
        }
        symbol = "bcleanbuf_thread"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%c(%u, %u)"
        }
        symbol = "vnode_getname_printable"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "firmlink target for vnode %p does not have flag set @%s:%d"
        }
        symbol = "vnode_getfirmlink"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "Incorrect state for old nc_counter(%d), should be even @%s:%d"
        }
        symbol = "cache_enter_locked"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "Incorrect state for old nc_counter(%d), should be odd @%s:%d"
        }
        symbol = "cache_delete"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "failed to resize the hash table.\n"
        }
        symbol = "add_name_internal"
        caller = "?"
    }
    new {
        args = 6
        anchors {
            "cluster_pagein: NULL upl passed in @%s:%d"
        }
        symbol = "cluster_pagein_ext"
        caller = "?"
    }
    new {
        args = 5
        anchors {
            "cluster_push"
        }
        symbol = "cluster_push_err"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s(): Called with real buffer of size %d bytes which is greater than the maximum allowed size of %d bytes (the system PAGE_SIZE).\n @%s:%d"
            "%s(): Called with real buffer and needs verification  @%s:%d"
            "%s:%d pageout of unaligned first page offset = %lld, size = %d  returned %d,\n"
            "%s:%d pageout of unaligned last page offset = %lld, size = %d  returned %d,\n"
            "Vector UPLs should not take this code-path @%s:%d"
            "BUSY bp found in cluster_io @%s:%d"
            "buf_setupl failed @%s:%d"
            "%s(): cbp_head is not NULL. @%s:%d"
        }
        symbol = "cluster_io"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "cluster_wait_IO"
        }
        symbol = "cluster_wait_IO"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s length = %zu, verify_block_size = %zu @%s:%d"
            "cluster_EOT"
        }
        symbol = "cluster_EOT"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "ubc_upl_map_range returned error %d upl = %p, upl_offset = %d, size = %d"
        }
        symbol = "cluster_iodone"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "ecount >= DRT_BITVECTOR_PAGES, cmap = %p, index = %d, bit = %d @%s:%d"
            "ecount <= 0, cmap = %p, index = %d, bit = %d @%s:%d"
        }
        symbol = "vfs_drt_do_mark_pages"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "vfs_drt: new cluster map mysteriously too small @%s:%d"
        }
        symbol = "vfs_drt_alloc_map"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "cluster_write_copy: failed to get pagelist @%s:%d"
        }
        symbol = "cluster_write_copy"
        caller = "?"
    }
    new {
        args = 3
        anchors {
            "cluster_push: failed to get pagelist @%s:%d"
        }
        symbol = "cluster_push_now"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "encrypted blocks will hit UBC! @%s:%d"
            "cluster_read_copy: failed to get pagelist @%s:%d"
        }
        symbol = "cluster_read_copy"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "Failed to restore dirty state on failure @%s:%d"
            "vfs_drt: entry summary count > 0 but no bits set in map, cmap = %p, index = %d, count = %lld @%s:%d"
        }
        symbol = "sparse_cluster_push"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "operation %s not listed in %s.\n"
            "vfs_opv_init: bad operation @%s:%d"
            "vfs_opv_init: operation vector without default routine. @%s:%d"
        }
        symbol = "vfs_opv_init"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "We need to keep going on a continued lookup, but for vp type %d (tag %d) @%s:%d"
            "NAMEI_ROOTDIR is set but ni_rootdir is not\n @%s:%d"
            "p->p_fd.fd_rdir is not set\n"
            "rootvnode is not set\n"
            "(1) invalid pre-increment usecount (%d) for rootdir vnode %p @%s:%d"
            "(1) usecount overflow for vnode %p @%s:%d"
            "(2) invalid pre-increment usecount (%d) for vnode %p @%s:%d"
            "(2) usecount overflow for vnode %p @%s:%d"
            "(3) Unexpected pre-decrement value (%d) of usecount for rootvnode %p @%s:%d"
            "(4) Unexpected pre-decrement value (%d) of usecount for rootvnode %p @%s:%d"
        }
        symbol = "namei"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "leaf should be empty @%s:%d"
        }
        symbol = "lookup"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "lookup_traverse_union: null parent name: .%s\n"
        }
        symbol = "lookup_traverse_union"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "NULL vp with error == 0. @%s:%d"
        }
        symbol = "lookup_compound_vnop_post_hook"
        caller = "?"
    }
    new {
        args = 4
        anchors {
            "NULL ni_vp in %s @%s:%d"
            "lookup_handle_found_vnode"
            "Incorrect termination of path in %s @%s:%d"
            "lookup_handle_rsrc_fork"
        }
        symbol = "lookup_handle_found_vnode"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "dquot"
            "dqlookup: error %d looking up id %u at index %d\n"
            "dqlookup: error looking up id %u at index %d\n"
        }
        symbol = "dqget"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "dqsync_orphans: dquot in use @%s:%d"
        }
        symbol = "dqsync_orphans"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "dqflush: stray dquot @%s:%d"
        }
        symbol = "dqflush"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "dqsync: NULL dq_qfile @%s:%d"
            "dqsync: NULL qf_vp @%s:%d"
        }
        symbol = "dqsync_locked"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "vnode_writedone: numoutput < 0 @%s:%d"
        }
        symbol = "vnode_writedone"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "vnode_drain_network"
        }
        symbol = "vnode_umount_preflight"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "mount_iterdrain"
        }
        symbol = "mount_iterdrain"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "already in drain @%s:%d"
            "mount_drain"
            "mount_refdrain: dangling vnode @%s:%d"
        }
        symbol = "mount_refdrain"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "vfsbusy"
        }
        symbol = "vfs_busy"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "vfs_mountroot: can't setup bdevvp\n"
            "root_device"
            "%s() VFS_ROOT() returned %d\n"
            "vfs_mountroot"
            "%s_mountroot failed: %d\n"
        }
        symbol = "vfs_mountroot"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s : shuffling mount points : %s <-> / <-> %s\n"
            "Do not use a leading slash in outgoing_vol_new_path\n"
            "Incoming rootfs root vnode not found\n"
            "Outgoing rootfs path not found, abandoning / switch, error = %d\n"
            "Outgoing rootfs path is not a directory, abandoning / switch\n"
            "skipping preserved mountpoint because not found or error: %d: %s\n"
            "skipping preserved mountpoint because not a mountpoint: %s\n"
            "preserved new mount directory not found or error: %d: %s\n"
            "preserved new mount directory not directory: %s\n"
            "will preserve mountpoint across pivot: /%s\n"
            "%s : done shuffling mount points with error: %d\n"
            "Incoming rootfs path not a directory\n"
            "Incoming rootfs root vnode does not have associated mount\n"
            "Incoming rootfs root vnode mount is busy\n"
            "Could not get rootvnode of incoming rootfs\n"
            "Incoming rootfs root vnode mount is is not a mountpoint\n"
            "Incoming rootfs is backed by a virtual device; cannot switch to it"
        }
        symbol = "vfs_switch_root"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "vnode_get(rootvnode) failed with error %d\n"
            "attempting kernel mount for recovery volume... \n"
            "Failed to mount recovery volume (%d)\n"
            "mounted recovery volume\n"
        }
        symbol = "vfs_mount_recovery"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "bdevvp"
            "bdevvp failed: vnode_ref @%s:%d"
            "bdevvp failed: fsync @%s:%d"
            "bdevvp failed: invalidateblks @%s:%d"
            "bdevvp failed: open @%s:%d"
        }
        symbol = "bdevvp"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "vnode_ref_ext: vp %p has no valid reference %d, %d @%s:%d"
            "vnode_ref_ext: v_writecount @%s:%d"
            "vnode_ref_ext: v_kusecount @%s:%d"
        }
        symbol = "vnode_ref_ext"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "vnode_rele_ext: vp %p usecount -ve : %d.  v_tag = %d, v_type = %d, v_flag = %x. @%s:%d"
            "vnode_rele_ext: vp %p writecount -ve : %d.  v_tag = %d, v_type = %d, v_flag = %x. @%s:%d"
            "vnode_rele_ext: vp %p kusecount -ve : %d.  v_tag = %d, v_type = %d, v_flag = %x. @%s:%d"
            "vnode_rele_ext: vp %p kusecount(%d) out of balance with usecount(%d).  v_tag = %d, v_type = %d, v_flag = %x. @%s:%d"
        }
        symbol = "vnode_rele_internal"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "vflush"
        }
        symbol = "vflush"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "vfs: bad selector 0x%.8x for old-style sysctl().  use the sysctl-by-fsid interface instead\n"
            "smbfs"
        }
        symbol = "vfs_sysctl_node"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "vfs_unmountall(%ssystem) start\n"
            "Unmounting timed out\n"
            "missed mount"
            "vfs_unmountall(%ssystem) end\n"
        }
        symbol = "vfs_unmountall"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "ioqueue_depth = %d,   ioscale = %d\n"
        }
        symbol = "vfs_init_io_attributes"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "vnode getiocount"
            "vnode_getiocount"
        }
        symbol = "vnode_getiocount"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "NULL vnode passed to vnode_initialize @%s:%d"
        }
        symbol = "vnode_initialize"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "add_fsref: vp already has named reference @%s:%d"
            "addfsref: vp on the free list @%s:%d"
        }
        symbol = "vnode_addfsref"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "remove_fsref: no named reference @%s:%d"
        }
        symbol = "vnode_removefsref"
        caller = "?"
    }
    new {
        args = 3
        anchors {
            "Open parameters, but not a regular file. @%s:%d"
            "Mode for open, but not trying to open... @%s:%d"
            "vnode_create: unknown vtype %d @%s:%d"
        }
        symbol = "vn_create"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "com.apple.kauth.vnode"
        }
        symbol = "vfsinit"
        caller = "?"
    }
    new {
        args = 3
        anchors {
            "NULL ndp @%s:%d"
        }
        symbol = "vn_authorize_open_existing"
        caller = "?"
    }
    new {
        args = 4
        anchors {
            "NULL cn_ndp @%s:%d"
        }
        symbol = "vn_authorize_create"
        caller = "?"
    }
    new {
        args = 5
        anchors {
            "Passed something other than NULL as reserved field! @%s:%d"
        }
        symbol = "vn_authorize_renamex_with_paths"
        caller = "?"
    }
    new {
        args = 4
        anchors {
            "reserved not NULL in vn_authorize_mkdir() @%s:%d"
        }
        symbol = "vn_authorize_mkdir"
        caller = "?"
    }
    new {
        args = 4
        anchors {
            "Non-NULL reserved argument to vn_authorize_rmdir() @%s:%d"
        }
        symbol = "vn_authorize_rmdir"
        caller = "?"
    }
    new {
        args = 3
        anchors {
            "(1) vnode attrs not complete for vnode_attr_authorize @%s:%d"
            "(2) vnode attrs not complete for vnode_attr_authorize (2) vap->va_active = 0x%llx , vap->va_supported = 0x%llx @%s:%d"
        }
        symbol = "vnode_attr_authorize"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "vclean: cannot reclaim @%s:%d"
        }
        symbol = "vclean"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "insmntque: vp not in mount vnode list @%s:%d"
            "vp already in mount list @%s:%d"
            "insmntque: vp already in mount vnode list @%s:%d"
        }
        symbol = "insmntque"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "vnode_reload with no iocount %d @%s:%d"
        }
        symbol = "vnode_iterate"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "unmount(%d) %s skipped\n"
            "unmount(%d) %s\n"
            "Unmount of %s failed (%d)\n"
        }
        symbol = "unmount_callback"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "new_vnode(%p): the vnode is VL_DEAD but not VBAD @%s:%d"
            "new_vnode(%p): vp on list @%s:%d"
            "new_vnode(%p): free vnode still referenced @%s:%d"
            "new_vnode(%p): vnode seems to be on mount list @%s:%d"
            "new_vnode(%p): vnode still hooked into the name cache @%s:%d"
        }
        symbol = "process_vp"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s : vp %p holdcount -ve: %d.  v_tag = %d, v_type = %d, v_flag = %x. @%s:%d"
            "vnode_drop_internal"
        }
        symbol = "vnode_drop_internal"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "vnode_put(%p): iocount < 1 @%s:%d"
        }
        symbol = "vnode_put_internal_locked"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "vnode reclaim in progress @%s:%d"
            "vnode_reclaim_internal: cleaned vnode isn't @%s:%d"
            "vnode_reclaim_internal: clean vnode has pending I/O's @%s:%d"
            "vnode_reclaim_internal: vparent not removed @%s:%d"
            "vnode_reclaim_internal: vname not removed @%s:%d"
            "vnode_reclaim_internal: vleases NOT empty @%s:%d"
            "missing bdev @%s:%d"
            "missing alias @%s:%d"
        }
        symbol = "vnode_reclaim_internal"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "vnode_drain: recursive drain @%s:%d"
            "vnode_drain_with_timeout"
            "vnode_drain"
        }
        symbol = "vnode_drain"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "vnode_create: vnode_resolver_create() err %d\n"
            "%s: alias vnode (vid = %u) is in state of change (start) v_flags = 0x%x v_numoutput = %d\n"
            "%s: alias vnode (vid = %u), is in state of change (end) v_flags = 0x%x v_numoutput = %d\n"
            "insmntque: vp on the free list @%s:%d"
            "new_vnode: vp (%p) on RAGE list not marked VLIST_RAGE @%s:%d"
            "vnode"
            "%d desired, %ld numvnodes, %ld free, %ld dead, %ld async, %d rage\n"
            "checkalias with VT_NON vp that shouldn't: %p @%s:%d"
        }
        symbol = "vnode_create_internal"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "trigger_unmount_callback: unexpected match '%s'\n"
            "trigger_unmount_callback: trigger mnt changed! (%p != %p)\n"
            "unresolving: '%s', err %d\n"
        }
        symbol = "trigger_unmount_callback"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "vnode_trigger_unresolve: not currently resolved\n"
        }
        symbol = "vnode_trigger_unresolve"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "VNODE_REF_FORCE didn't help... @%s:%d"
        }
        symbol = "vnode_resolver_create"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "com.apple.private.vfs.file-leases"
        }
        symbol = "vnode_setlease"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "wait_for_lease_break"
        }
        symbol = "wait_for_lease_break"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "failed to locate mount-on path: %s "
        }
        symbol = "kernel_mount"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s: mount on %s failed, error %d\n"
            "vfs_mount_at_path"
        }
        symbol = "vfs_mount_at_path"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            ".quota.ops"
            "group"
        }
        symbol = "enablequotas"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "attempt to unmount a system mount (%s), will return EBUSY\n"
        }
        symbol = "safedounmount"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "dounmount: no coveredvp @%s:%d"
        }
        symbol = "dounmount"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "sync_thread failed\n"
            "sync_thread"
            "sync timed out: %d sec\n"
        }
        symbol = "sync_internal"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "com.apple.private.vfs.pivot-root"
        }
        symbol = "pivot_root"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "safe_getpath: failed to get the path for vp %p (%s) : err %d\n"
            "no-name"
        }
        symbol = "safe_getpath_new"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: %s: Bad dirent recived from directory %s\n"
            "vnode_readdir64"
        }
        symbol = "vnode_readdir64"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "com.apple.private.vfs.snapshot.user"
            "com.apple.private.vfs.snapshot"
            "com.apple.developer.vfs.snapshot"
            "com.apple.private.apfs.arv.limited.snapshot"
        }
        symbol = "fs_snapshot"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "/System/Library/AssetsV2/manifests/"
        }
        symbol = "graftdmg"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Volume mounted on a device with invalid major number. @%s:%d"
            "%s() VFS_ROOT returned %d\n"
            "mount_common"
            "webdav"
            "mount_common(): mount of %s filesystem failed with %d, but vnode list is not empty. @%s:%d"
        }
        symbol = "mount_common"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "com.apple.private.vfs.open-by-id"
        }
        symbol = "openbyid_np"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "No vp, but no compound remove? @%s:%d"
            "EKEEPLOOKING, but not a filesystem that supports compound VNOPs? @%s:%d"
        }
        symbol = "unlinkat_internal"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "EKEEPLOOKING without NAMEI_CONTLOOKUP on either ndp? @%s:%d"
            "rename retry limit due to ERECYCLE reached\n"
        }
        symbol = "renameat_internal"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "No error, but no compound rmdir? @%s:%d"
            "rm AD"
        }
        symbol = "rmdirat_internal"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "nspace.complete: gencount changed! (orig %llu cur %llu)\n"
            "nspace.complete: syncroot changed! (orig %llu cur %llu)\n"
        }
        symbol = "sysctl_nspace_complete"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "nspacerq"
        }
        symbol = "nspace_resolver_req_add"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "com.apple.private.kernel.set-package-extensions"
        }
        symbol = "fsctl_internal"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "EKEEPLOOKING from a filesystem that doesn't support compound VNOPs? @%s:%d"
            "Haven't cleaned up adequately in vn_open_auth() @%s:%d"
            "Why am I trying to use VNOP_OPEN() on anything other than the root or a named stream? @%s:%d"
            "com.apple.private.security.file-unencrypt-access"
            "vn_open_auth_retry"
            "EKEEPLOOKING, but we did a create? @%s:%d"
            "EKEEPLOOKING from filesystem that doesn't support compound vnops? @%s:%d"
        }
        symbol = "vn_open_auth"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "Invalid knote filter on a vnode! @%s:%d"
            "Should never have an EVFILT_READ except for reg or fifo. @%s:%d"
        }
        symbol = "filt_vnode_common"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "vnode_flushnamedstream: err %d opening file\n"
        }
        symbol = "vnode_flushnamedstream"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "getnamedstream"
        }
        symbol = "vnode_getnamedstream"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "/var/run/.vfs_rsrc_streams_%p%x"
            "/var/run"
            ".vfs_rsrc_streams_%p%x"
        }
        symbol = "get_shadow_dir"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "get_xattrinfo: resource fork not last entry\n"
        }
        symbol = "get_xattrinfo"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "setxattr: VNOP_WRITE error %d\n"
            "setxattr: write_xattrinfo error %d\n"
            "setxattr: VNOP_TRUNCATE error %d\n"
            "setxattr: uiomove error %d\n"
        }
        symbol = "default_setxattr_vfs"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "removexattr: write_xattrinfo error %d\n"
        }
        symbol = "default_removexattr"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "vfs_fsadd: operation %s not listed in %s.\n"
            "vfs_fsadd: bad operation @%s:%d"
            "vfs_fsadd: operation vector without default routine. @%s:%d"
        }
        symbol = "vfs_fsadd"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "vnode_lookup_continue_needed(): cnp->cn_ndp is NULL @%s:%d"
        }
        symbol = "vnode_lookup_continue_needed"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "No dvp? @%s:%d"
            "Want create, but no vap? @%s:%d"
            "Don't want create, but have a vap? @%s:%d"
            "Filesystem did a create, even though none was requested? @%s:%d"
        }
        symbol = "VNOP_COMPOUND_OPEN"
        caller = "?"
    }
    new {
        args = 5
        anchors {
            "Not batched, and no fvp? @%s:%d"
            "VNOP_COMPOUND_RENAME() returned %d\n"
        }
        symbol = "vn_rename"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "No fvpp after compound rename? @%s:%d"
        }
        symbol = "VNOP_COMPOUND_RENAME"
        caller = "?"
    }
    new {
        args = 4
        anchors {
            "Non-CREATE nameiop in vn_mkdir()? @%s:%d"
        }
        symbol = "vn_mkdir"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "NULL vp, but not a compound VNOP? @%s:%d"
            "Non-NULL vap, but not a compound VNOP? @%s:%d"
        }
        symbol = "vn_rmdir"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "add_fsevent: event queue is full! dropping events (num dropped events: %d; num events outstanding: %d).\n"
            "add_fsevent: kfse_list head %p ; num_pending_rename %d\n"
            "add_fsevent: zalloc sez: %p\n"
            "add_fsevent: event_zone info: %d 0x%x\n"
            "add_fsevent: line %d: kfse recount %d but should be at least 1 @%s:%d"
            "add_fsevent: you can't pass me a NULL vnode ptr (type %d)! @%s:%d"
            "add_fsevent: was not able to add path %s to event %p. @%s:%d"
            "add_fsevent: funny looking string length: %d\n"
            "add_fsevent: bogus looking string (len %d)\n"
            "add_fsevent: unknown type %d\n"
            "fsevents: watcher falling behind: %s (pid: %d) rd: %4d wr: %4d q_size: %4d flags: 0x%x\n"
        }
        symbol = "add_fsevent"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "release_event_ref: bogus kfse refcount %d @%s:%d"
        }
        symbol = "release_event_ref"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "fsevents: watcher %s (pid: %d) - Using /dev/fsevents directly is unsupported.  Migrate to FSEventsFramework\n"
            "fsevents: too many watchers!\n"
            "com.apple.private.vfs.fsevents-watcher"
            "com.apple.private.vfs.fsevents-access-granted-watcher"
        }
        symbol = "add_watcher"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "fsevents: close: still have readers! (%d) @%s:%d"
        }
        symbol = "remove_watcher"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "fsevents_empty"
            "/.Spotlight-V100/"
            "/.MobileBackups/"
            "/Backups.backupdb/"
        }
        symbol = "fseventsf_read"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "fsevents: copy_out_kfse: asked to copy out an invalid event (kfse %p, refcount %d) @%s:%d"
            "copy_out_kfse:2: empty/short path (%s)\n"
        }
        symbol = "copy_out_kfse"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "unexpected unmount pending ack %d (%d)\n"
        }
        symbol = "fseventsf_ioctl"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "watcher-close"
        }
        symbol = "fseventsf_drain"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "kern.maxkfsevents"
            "fs-event-buf"
        }
        symbol = "fsevents_init"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "cp_os_version: unable to parse osversion `%s'\n"
        }
        symbol = "cp_os_version"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "com.apple.private.dmc.set"
        }
        symbol = "disk_conditioner_set_info"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "dead_read: lock @%s:%d"
        }
        symbol = "dead_read"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "dead_write: lock @%s:%d"
        }
        symbol = "dead_write"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "dead_badop called @%s:%d"
        }
        symbol = "dead_badop"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Couldn\\'t make stdin, err %d.\n"
            "Couldn\\'t make stdout, err %d.\n"
            "Couldn\\'t make stderr, err %d.\n"
        }
        symbol = "devfs_fdesc_makelinks"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "fdesc_allocvp"
        }
        symbol = "fdesc_allocvp"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Invalid type for fdesc node! @%s:%d"
        }
        symbol = "fdesc_open"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "fifo_open with no fifoinfo @%s:%d"
            "fifo_vnops.c"
            "fifocreatewait"
            "fifoor"
            "fifoow"
        }
        symbol = "fifo_open"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "spec_open"
            "spec_open type @%s:%d"
        }
        symbol = "spec_open"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "spec_read type @%s:%d"
        }
        symbol = "spec_read"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "spec_write type @%s:%d"
        }
        symbol = "spec_write"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "spec_ioctl @%s:%d"
        }
        symbol = "spec_ioctl"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "iosched"
            "io_throttle_window_tier1"
            "io_throttle_window_tier2"
            "io_throttle_window_tier3"
        }
        symbol = "throttle_init"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "throttle_lowpri_io"
        }
        symbol = "throttle_lowpri_io"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Illegal devno (%d) passed into throttle_info_disable_throttle() @%s:%d"
        }
        symbol = "throttle_info_disable_throttle"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "spec_strategy"
            "Invalid value (%d) for si_devbsdunit for vnode %p @%s:%d"
            "Invalid value (%d) for si_isssd for vnode %p @%s:%d"
        }
        symbol = "spec_strategy"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "negative open count (c, %u, %u) @%s:%d"
            "negative open count (b, %u, %u) @%s:%d"
            "spec_close: not special @%s:%d"
        }
        symbol = "spec_close"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "spec_blktooff: not implemented for VBLK\n"
            "spec_blktooff type @%s:%d"
        }
        symbol = "spec_blktooff"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "spec_offtoblk: not implemented for VBLK\n"
            "spec_offtoblk type @%s:%d"
        }
        symbol = "spec_offtoblk"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s : si_devbsdunit initialized to (%d), throttle_mask is (0x%llx), isssd is (%d)\n"
        }
        symbol = "spec_init_bsdunit"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "devfs_sinit: dev_add_entry failed "
        }
        symbol = "devfs_sinit"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "devfs_remove: not ready for devices!\n"
        }
        symbol = "devfs_remove"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "plane count wrapped around. @%s:%d"
        }
        symbol = "devfs_free_plane"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "devfs_dntovn: DN_DELETE set on a devnode upon entry. @%s:%d"
            "devfs_dntovn: cloning device with a vnode? @%s:%d"
        }
        symbol = "devfs_dntovn"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "devfs_rele_node: devnode without a refcount! @%s:%d"
        }
        symbol = "devfs_rele_node"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "devfs_make_node: not ready for devices!\n"
        }
        symbol = "devfs_make_node_internal"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "devfs_read(): bad file type %d"
        }
        symbol = "devfs_read"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "devfs_write(): bad file type %d"
        }
        symbol = "devfs_write"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "devfs_kernel_mount: kernel_mount failed: %d\n"
        }
        symbol = "devfs_kernel_mount"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "oslog_stream"
        }
        symbol = "devfs_init"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s:%d:%s: %s: unknown cmp_state %d\n"
        }
        symbol = "decmpfs_file_is_compressed"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s:%d:%s: %s: VNOP_VERIFY returned error = %d\n"
            "%s:%d:%s: %s: verify block size (%zu) is not power of 2, no verification will be done\n"
            "%s:%d:%s: %s: upl size (%zu) is not a multiple of verify block size (%zu)\n"
            "%s:%d:%s: %s: FS block size (%u) is greater than PAGE_SIZE (%d) and is not power of 2, no verification will be done\n"
            "%s:%d:%s: %s: FS block size (%u) is greater than verify block size (%zu), no verification will be done\n"
            "%s:%d:%s: %s: unexpected pagein during decompress\n"
            "%s:%d:%s: %s: Unexpected size fetch of decompressed data, l_uplSize = %d, l_did_read = %d, inval_size = %d\n"
            "%s:%d:%s: %s: Verification failed with error %d, uplPos = %lld, uplSize = %d, did_read = %d, valid_pages = %d, invalid_pages = %d, tail_page_valid = %d\n"
            "%s:%d:%s: %s: ubc_upl_unmap error %d\n"
        }
        symbol = "decmpfs_pagein_compressed"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s:%d:%s: %s: verify block size is not power of 2, no verification will be done\n"
            "%s:%d:%s: %s: ubc_create_upl error %d\n"
            "%s:%d:%s: %s: ubc_upl_map kr=0x%x\n"
            "%s:%d:%s: %s: ubc_upl_map mapped null\n"
            "%s:%d:%s: %s: cmp_state == FILE_IS_CONVERTING\n"
            "%s:%d:%s: %s: cmp_state == FILE_IS_COMPRESSED\n"
            "%s:%d:%s: %s: cmp_state == FILE_IS_NOT_COMPRESSED\n"
            "%s:%d:%s: %s: Verification failed with error %d\n"
            "ubc_upl_unmap returned error %d (kern_return_t) @%s:%d"
            "%s:%d:%s: %s: uplOff %lld should never be negative\n"
            "%s:%d:%s: %s: uplOff %lld too large\n"
            "%s:%d:%s: %s: cluster_copy_upl_data err %d\n"
        }
        symbol = "decmpfs_read_compressed"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s:%d:%s: %s: decmpfs_fetch_compressed_header err %d\n"
            "%s:%d:%s: %s: decompressor err %d\n"
        }
        symbol = "decmpfs_free_compressed_data"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "%s:%d:%s: %s: uio_addiov err %d\n"
            "%s:%d:%s: %s: VNOP_WRITE err %d\n"
            "%s:%d:%s: %s: file decompressed to %lld instead of %lld\n"
            "%s:%d:%s: %s: VNOP_FSYNC err %d\n"
            "%s:%d:%s: %s: aborting decompress, err %d\n"
            "%s:%d:%s: %s: vnode_setsize err %d\n"
            "%s:%d:%s: %s: decmpfs_free_compressed_data err %d\n"
            "%s:%d:%s: %s: vnode_getattr err %d, num retries %d\n"
            "%s:%d:%s: %s: vnode_setattr err %d\n"
            "%s:%d:%s: %s: FSIOC_CAS_BSDFLAGS err: flags mismatc. actual (%x) expected (%x), num retries %d\n"
            "%s:%d:%s: %s: FSIOC_CAS_BSDFLAGS err %d, num retries %d\n"
        }
        symbol = "decmpfs_decompress_file"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s:%d:%s: %s: invalid compression_magic 0x%08x, should be 0x%08x\n"
            "%s:%d:%s: %s: compression_type %d out of range\n"
        }
        symbol = "decmpfs_fetch_compressed_header"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "com.apple.AppleFSCompression.providesType%u"
            "%s:%d:%s: %s: waiting for %s\n"
            "%s:%d:%s: %s: the kext with %s is no longer present\n"
            "%s:%d:%s: %s: still waiting for %s\n"
            "%s:%d:%s: %s: we found %s, but the type still isn't registered\n"
            "%s:%d:%s: %s: tried to access a compressed file of unregistered type %d\n"
        }
        symbol = "_decmp_get_func"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "wait_for_decompress"
        }
        symbol = "wait_for_decompress"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "bpfdraining"
            "Two threads blocked in a BPF close @%s:%d"
            "bpf buffer freed during read/write @%s:%d"
            "%s: bpf%d"
            "bpf%u closed by %s.%u dcount %llu fcount %llu ccount %llu"
        }
        symbol = "bpfclose"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "bpf_read"
            "%s: bpf%d ERESTART to EINTR"
        }
        symbol = "bpfread"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "bpfwrite"
            "bpfwrite: resid %d error %d"
            "bpf_movein_batch uiomove error %d"
            "bpf_movein_batch bh_hdrlen %u too small"
            "bpf_movein_batch bh_caplen %u != bh_datalen %u"
            "bpf_movein_batch bh_hdrlen %u too large"
            "bpf_movein_batch bpf_movein error %d"
        }
        symbol = "bpfwrite"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "BIOCFLUSH"
            "bpfioctl"
            "bpf%d BIOCSBLEN capped to %u from %u"
            "bpf%d BIOCSBLEN bumped to %u from %u"
            "bpf%d BIOCSBLEN %u"
            "bpf%u cannot set BIOCSHDRCMPLT when BIOCSBATCHWRITE is set"
            "bpf%u cannot set BIOCSETTC when BIOCSBATCHWRITE is set"
            "%s: ifnet not found for %s error %d"
            "bpf%u bd_write_size_max %u too big"
            "bpf%u cannot set BIOCSBATCHWRITE when BIOCSHDRCMPLT is not set"
            "bpf%u cannot set BIOCSBATCHWRITE when BIOCSETTC is set"
        }
        symbol = "bpfioctl"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "bpfselect"
        }
        symbol = "bpfselect"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "bpf_hdr_comp"
            "bpf_init: failed to allocate a major number"
        }
        symbol = "bpf_init"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "bpf_growing"
            "bpf%d"
            "bpf_make_dev_t: malloc bpf_dtab failed"
        }
        symbol = "bpf_make_dev_t"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: %p refcnt <= 0 @%s:%d"
            "%s: %p BPF_DETACHED not set @%s:%d"
        }
        symbol = "bpf_release_d"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "bpf_detachd: descriptor not in list @%s:%d"
            "bpf_detachd"
            " closed and"
            "bpf_detachd: bpf%d %s disable input 0"
            "%s: bpf%d ifnet_set_promiscuous %s failed"
            "bpf%d%s detached from %s fcount %llu dcount %llu"
        }
        symbol = "bpf_detachd"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "bpf_setf"
        }
        symbol = "bpf_setf"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "bpf_setif"
            "bpf%u attached to %s"
        }
        symbol = "bpf_setif"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "bpf_setdlt"
            "bpf_setdlt: bpf%d bpf_attachd %s error %d"
            "bpf_setdlt: bpf%d ifpromisc %s error %d"
        }
        symbol = "bpf_setdlt"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "SO_VALID_TC(tc)"
        }
        symbol = "bpf_set_packet_service_class"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s:%d tlen %u > bpfp_total_length %lu bpfp_header_length %lu pth_frame_pre_length %u pre_adjust %u in_pkt_len %u out_pkt_len %u @%s:%d"
            "%s:%d tlen %u > bpfp_total_length %lu bpfp_header_length %lu pth_frame_pre_length %u pre_adjust %u in_pkt_len %u out_pkt_len %u"
        }
        symbol = "bpf_tap_imp"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "bpf_mcopy @%s:%d"
            "buflet != NULL"
            "addr != NULL"
        }
        symbol = "copy_bpf_packet_offset"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "x_cnt < nbpfilter"
        }
        symbol = "sysctl_bpf_stats"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "bridgeattach"
            "proto_register_plumber failed for PF_INET error=%d\n"
            "proto_register_plumber failed for PF_INET6 error=%d\n"
            "%s: ifnet_clone_attach failed %d"
        }
        symbol = "ether_family_init"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "is_promisc == list_is_promisc"
            "%s: (%s): count %u"
            "%s: (%s): sublist %u pkts %u"
        }
        symbol = "bridge_early_input"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "mac_nat_entry_print2"
            "%s: %.*s %s%s%s %p (%s, %s, %s)"
        }
        symbol = "mac_nat_entry_print2"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "created"
        }
        symbol = "bridge_create_mac_nat_entry_common"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "bridge_mac_nat_arp_translate"
            "%s: mbuf_copyback failed"
            "%s: mbuf_copyback uh_sum failed"
            "%s: mbuf_copyback dp_flags failed"
            "%s: mbuf_copyback lladdr failed"
            "%s: mbuf_copyback cksum=0 failed"
            "%s: mbuf_copyback cksum failed"
        }
        symbol = "bridge_mac_nat_translate"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "bridge_pf"
            "%s: m_pullup failed"
        }
        symbol = "bridge_pf"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            " frag"
            "%s: Short IP packet %d < %d"
            "%s: m_pullup failed hlen %d"
            "%s: bad IP version"
            "%s: bad IP header length %d < %d"
            "%s: IP total len %d < header len %d"
            "%s: invalid IP payload length %d > %d"
            "%s: short IPv6 packet %d < %d"
            "%s: bad IPv6 version"
            "%s: ip6_lasthdr() returned %d"
            "%s: invalid IPv6 payload length %d > %d"
            "%s: IPv%c proto %d ip %u pay %u opt %u pkt %u%s"
        }
        symbol = "bridge_get_ip_proto"
        caller = "?"
    }
    new {
        args = 3
        anchors {
            "dst_ifp != NULL"
            "%s: large non IP packet"
            "%s: %s bridge_send(%s) len %d op %d"
        }
        symbol = "bridge_enqueue"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "tso_hwassist"
            "%s: %s: does%s support checksum 0x%x if_csum 0x%x"
        }
        symbol = "tso_hwassist"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "gso_ip_tcp"
            "%s: %s %s mss %d nsegs %d"
        }
        symbol = "gso_tcp"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "dst_ifp != NULL && src_ifp != NULL"
            "bridge_finalize_cksum"
            "bridge_compute_cksum"
            "%s: [%s] before 0x%x hwcap 0x%x sw_csum 0x%x did 0x%x after 0x%x"
            "%s: [%s -> %s] before 0x%x did 0x%x after 0x%x"
        }
        symbol = "bridge_handle_checksum_op"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "com.apple.kernel.bsd.net.if_bridge"
            "%s: %s invalid MTU for %s"
            "%s: ifnet_set_promiscuous(%s) failed %d, ignoring"
            "%s: ifnet_set_promiscuous(%s) failed %d"
            "%s: if_allmulti(%s) failed %d, ignoring"
            "%s: iflt_attach failed %d"
            "%s: bridge_attach_protocol failed %d"
            "%s: ifnet_set_lladdr failed %d"
            "%s: %s input broadcast %s"
        }
        symbol = "bridge_ioctl_add"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "inside"
            "outside"
            "bridge_iff_input["
            "bridge_iff_input]"
            "bcast_mcast "
            "bridge_ifp->if_bridge == NULL"
            "%s: %s from %s m 0x%llx data 0x%llx frame 0x%llx %s frmlen %lu"
            "%s: frame_ptr outside mbuf"
            "%s: short frame %lu < %lu"
            "%s: mbuf_pullup(%lu) failed %d"
            "%s: %s %sfrom %s m 0x%llx data 0x%llx"
            "%s: %s not running passing along"
            "%s: %s bridge_lookup_member_if failed"
            "%s: %s(%s) bridge_get_ip_proto failed %d"
            "%s: %s(%s) bridge_offload_checksum failed %d"
            "%s: %s bridge_host_filter failed"
            "%s:  multicast: %02x:%02x:%02x:%02x:%02x:%02x"
            "%s:  broadcast: %02x:%02x:%02x:%02x:%02x:%02x"
            "%s: %s mcast for us"
            "%s: %s.%dbrhf_bad_ether_srchw_addr"
            "%s: %s.%dbrhf_ip_too_small"
            "%s: %s.%dbrhf_ip_bad_srcaddr"
            "%s: %s.%dbrhf_ip_bad_proto"
            "%s: %s.%dbrhf_bad_ether_type"
        }
        symbol = "bridge_iff_input"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "bridge_forward"
            "src_if == m->m_pkthdr.rcvif"
            "%s: %s m 0x%llx"
        }
        symbol = "bridge_forward"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "bridge_mac_nat_arp_input"
            "%s: %s %s ARP %s -> %s"
        }
        symbol = "bridge_mac_nat_input"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "bridge_rtnode_hash"
            "%s: %s EEXIST %02x:%02x:%02x:%02x:%02x:%02x"
        }
        symbol = "bridge_rtnode_hash"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "bridge_iff_output"
            "bridge_member_output"
            "%s: %s from %s m 0x%llx data 0x%llx"
            "%s: ifp %s"
        }
        symbol = "bridge_iff_output"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "bridge_iflinkevent"
            "%s: %s event_code %u - %s"
            "%s: ifnet_set_promiscuous (%s) failed %d"
            "%s: if_allmulti (%s) failed %d"
        }
        symbol = "bridge_iff_event"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "flushed"
        }
        symbol = "bridge_mac_nat_flush_entries_common"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "bridge_iff_detached"
        }
        symbol = "bridge_iff_detached"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "bridge_attach_protocol"
            "%s: ifnet_attach_protocol(%s) failed, %d"
        }
        symbol = "bridge_attach_protocol"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "bridge_proto_input"
            "%s: %s unexpected packet"
        }
        symbol = "bridge_proto_input"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "bridge_link_event"
        }
        symbol = "bridge_link_event"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "bridge_detach_protocol"
            "ifnet_detach_flowswitch_nexus"
            "%s: ifnet_detach_protocol(%s) failed, %d"
        }
        symbol = "bridge_delete_member"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "aged out"
        }
        symbol = "bridge_mac_nat_age_entries_common"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "bridge_cancel_delayed_call"
            "%s: %s call 0x%llx flags 0x%x"
        }
        symbol = "bridge_cancel_delayed_call"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s (%d): ifnet_detach(%p) failed %d @%s:%d"
        }
        symbol = "bridge_clone_destroy"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "(call->bdc_flags & BDCF_OUTSTANDING) == 0"
            "(call->bdc_flags & BDCF_CANCELLING) == 0"
            "%s thread_call_free() failed for call %p @%s:%d"
            "bridge_cleanup_delayed_call"
        }
        symbol = "bridge_cleanup_delayed_call"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "etypef == ETHER_TYPE_FLAG_ARP"
            "%s: %s from %s count %d head 0x%llx.0x%llx tail 0x%llx.0x%llx"
        }
        symbol = "bridge_input_list"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "bridge_filter_checksum"
        }
        symbol = "bridge_filter_checksum_list"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "bridge_broadcast_list"
            "%s: %s mcast for us in_m %p"
        }
        symbol = "bridge_broadcast_list"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "dst_if != NULL"
            "%s: %s (%s) append gso #segs %u bytes %u"
            "%s: %s (%s) append %d bytes op %d"
            "%s: %s (%s) bridge_transmit packets %u bytes %u error %d"
        }
        symbol = "bridge_enqueue_multi"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "ifmultiaddr"
            "net_affinity"
            "net_rxpoll"
            "net_rtref"
            "net_async"
            "ifnet_debug"
            "dlil_pending_thread_cnt == 0"
            "kern.skywalk_netagent_enable"
            "kern.skywalk_netagent_disable"
            "(!pe_enable_fsw_transport_netagent && !pe_disable_fsw_transport_netagent) || (pe_enable_fsw_transport_netagent ^ pe_disable_fsw_transport_netagent)"
            "SK: netagent is enabled via an override for this platform\n"
            "SK: netagent is disabled via an override for this platform\n"
            "SK: netagent is %s by default for this platform\n"
            "disabled"
            "if_attach_nx"
            "SK: netagent is force-enabled\n"
            "SK: netagent is force-disabled\n"
            "ifnet"
            "ifnet_tcpstat"
            "ifnet_udpstat"
            "%s: Waiting for all the create dlil kernel threads to get scheduled at least once.\n"
            "%s: All the created dlil kernel threads have been scheduled at least once. Proceeding.\n"
            "if_low_power_event"
            "%s: no CPU clock available! @%s:%d"
            "pktsched_init"
            "pktsched.c"
        }
        symbol = "dlil_init"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "sc == MBUF_SC_UNSPEC || MBUF_VALID_SC(sc)"
            "flow != 0"
        }
        symbol = "if_qflush_sc"
        caller = "?"
    }
    new {
        args = 3
        anchors {
            "%s[%s,%d]: ifp %s cmd 0x%08lx (%c%c [%lu] %c %lu) error %d\n"
            "%s[%s,%d]: ifp %s cmd 0x%08lx (%c%c [%lu] %c %lu) OK\n"
        }
        symbol = "ifioctl"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: promiscuous mode %s %s (%d)\n"
        }
        symbol = "ifnet_set_promiscuous"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: %s allmulti %s (%d)\n"
        }
        symbol = "if_allmulti"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s: ifma=%p negative refcnt @%s:%d"
            "ifma_remref"
        }
        symbol = "ifma_remref"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "ifa %p attached to ifp is being freed @%s:%d"
        }
        symbol = "ifa_deallocated"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "intf_event_enqueue_nwk_wq_entry"
            "%s: eventhandler enqueuing event of type=intf_event event_code=%s"
        }
        symbol = "intf_event_enqueue_nwk_wq_entry"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: Mismatch ifa_ifp=%p != ifp=%p @%s:%d"
            "%s: Attempt to attach an already attached ifa=%p @%s:%d"
        }
        symbol = "if_attach_ifa_common"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s: Link address ifa=%p not first @%s:%d"
            "%s: Attempt to detach an unattached address ifa=%p @%s:%d"
            "%s: Mismatch ifa_ifp=%p, ifp=%p @%s:%d"
            "%s: Attempt to detach a stray address ifa=%p @%s:%d"
        }
        symbol = "if_detach_ifa_common"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "sa->sa_family == AF_LINK"
        }
        symbol = "ifconf"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "ifnet_reset_order"
            "if_ordered_count == 0"
            "%s: count %u"
        }
        symbol = "ifnet_reset_order"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "ifioctl_get_media"
            "%s: first ifnet_ioctl(%s, %08lx) error %d"
            "%s: %s kalloc_data() failed"
            "%s: %s copyin() error %d"
            "%s: %s converted extended media %08x to compat media %08x"
            "%s: %s copyout() error %d"
        }
        symbol = "ifioctl_get_media"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "if_output_netem_%s"
        }
        symbol = "ifioctl_linkparams"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "ifioctl_ifreq"
            "so->so_proto != NULL"
            "%s: interface name too long @%s:%d"
            "if_clone_create"
            "%s: %s SIOCSIFMEDIA ignore IFM_OTHER"
            "SIOCSIFESTTHROUGHPUT %s%s up: %u, down: %u"
            "SIOCSIFRADIODETAILS %s%s technology: %u, channel: %u"
            "ifioctl_req: cmd SIOCSIFMANAGEMENT on %s not allowed for %s:%u\n"
            "ifioctl_req: cmd SIOCSIFMANAGEMENT 0 not allowed on %s with subfamily management"
            "ifioctl_req: SIOCSATTACHPROTONULL ifnet_attach_protocol(%s) failed, %d"
            "ifioctl_req: SIOCSATTACHPROTONULL ifnet_detach_protocol(%s) failed, %d"
            "SIOCSIFNOTRAFFICSHAPING %s %d"
        }
        symbol = "ifioctl_ifreq"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s: Freeing ifma=%p with outstanding anon req @%s:%d"
            "%s: ifma=%p attached to ifma_ifp=%p is being freed @%s:%d"
            "%s: ifma %p cannot be freed @%s:%d"
            "%s: non-zero refcount ifma=%p @%s:%d"
            "%s: non-zero reqcnt ifma=%p @%s:%d"
            "%s: non-NULL ifma_ifp=%p for ifma=%p @%s:%d"
            "%s: non-NULL ifma_ll=%p for ifma=%p @%s:%d"
        }
        symbol = "ifma_free"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "!anon || sa->sa_family == AF_UNSPEC || sa->sa_family == AF_LINK"
            "!anon"
            "ifma->ifma_ll->ifma_ifp == ifp"
        }
        symbol = "if_addmulti_common"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "(ifma->ifma_flags & IFMAF_ANONYMOUS) || ifma->ifma_anoncnt == 0"
            "ifma->ifma_reqcnt > 1"
        }
        symbol = "if_addmulti_doesexist"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "ifma->ifma_anoncnt == 1"
            "%s: Mismatch ifma_ifp=%p != ifp=%p @%s:%d"
            "%s: Attempt to attach an already attached ifma=%p @%s:%d"
            "%s: ifma=%p unexpected IFMAF_ANONYMOUS @%s:%d"
            "%s: Attempt to reattach a detached ifma=%p @%s:%d"
            "ifma->ifma_reqcnt == 1"
        }
        symbol = "if_attach_ifma"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: ifma %p has no debug structure @%s:%d"
            "ifma_trace"
        }
        symbol = "ifma_trace"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "!lastref || (!(ifma->ifma_debug & IFD_ATTACHED) && ifma->ifma_reqcnt == 0)"
        }
        symbol = "if_delmulti_common"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s: ifma=%p negative reqcnt @%s:%d"
            "%s: ifma=%p missing IFMAF_ANONYMOUS @%s:%d"
            "%s: ifma=%p negative anonreqcnt @%s:%d"
            "%s: Mismatch ifma_ifp=%p, ifp=%p @%s:%d"
            "%s: Detaching ifma=%p with outstanding anon req @%s:%d"
            "%s: Attempt to detach an unattached address ifma=%p @%s:%d"
            "%s: ifma %p is already in trash list @%s:%d"
        }
        symbol = "if_detach_ifma"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "if_rtdel: error %d\n"
        }
        symbol = "if_rtdel"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "ifnet_set_flowswitch_rx_callback"
        }
        symbol = "ifnet_set_flowswitch_rx_callback"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "ifnet_set_delegate_parent"
        }
        symbol = "ifnet_set_delegate_parent"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "((intptr_t)base + dlif_tcpstat_size) <= ((intptr_t)buf + dlif_tcpstat_bufsize)"
            "((intptr_t)base + dlif_udpstat_size) <= ((intptr_t)buf + dlif_udpstat_bufsize)"
            "IS_P2ALIGNED(ifp->if_tcp_stat, sizeof(u_int64_t)) && IS_P2ALIGNED(ifp->if_udp_stat, sizeof(u_int64_t))"
        }
        symbol = "dlil_alloc_local_stats"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "dlil_attach_filter"
            "%s: %s filter attached\n"
            "%s: failed to attach %s (err=%d)\n"
            "%s: %s is no longer attached"
        }
        symbol = "dlil_attach_filter"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "plowat != 0 && phiwat != 0"
            "blowat != 0 && bhiwat != 0"
            "ival >= IF_RXPOLL_INTERVALTIME_MIN"
            "%s: speed %llu bps, sample per %llu nsec, poll interval %llu nsec, pkts per poll %u, pkt limits [%u/%u], wreq limits [%u/%u], bytes limits [%u/%u]\n"
        }
        symbol = "dlil_rxpoll_update_params"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "ifp != NULL && p != NULL"
        }
        symbol = "dlil_rxpoll_get_params"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s: restart interval set to %lu nsec\n"
            "%s: TBR disabled\n"
            "%s: TBR %s (rate %llu bps depth %u)\n"
            "reconfigured"
            "idepth > 0"
            "%s: TBR calculated tokens %lld filluptime %llu ns\n"
            "%s: TBR calculated tokens %lld infinite filluptime\n"
            "%s: TBR suspended (link is down)\n"
        }
        symbol = "ifclassq_tbr_set"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "tail->m_flags & M_PKTHDR"
        }
        symbol = "ifnet_enqueue"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "ifp->if_output_dlil != NULL"
            "ifp->if_eflags & IFEF_ENQUEUE_MULTI"
        }
        symbol = "dlil_output"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "(pop & ones) == pop"
            "(ptrdiff_t)(uth->uu_network_marks & pop) == pop"
        }
        symbol = "net_thread_marks_pop"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "(unpop & ones) == unpop"
            "(ptrdiff_t)(uth->uu_network_marks & unpop) == 0"
        }
        symbol = "net_thread_unmarks_pop"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "IF_FULLY_ATTACHED(ifp)"
        }
        symbol = "ifnet_incr_iorefcnt"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "ifp->if_datamov > 0"
            "Waking up drainers on %s\n"
        }
        symbol = "ifnet_datamov_end"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Waiting for data path(s) to quiesce on %s\n"
            "ifnet_datamov_drain"
            "ifp->if_drainers > 0"
        }
        symbol = "ifnet_datamov_drain"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s: negative refcnt for ifp=%p @%s:%d"
            "dlil_if_free"
        }
        symbol = "dlil_if_free"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: failed to attach v1 protocol %d (err=%d)\n"
            "%s: attached v1 protocol %d (count = %d)\n"
        }
        symbol = "ifnet_attach_protocol"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: failed to attach v2 protocol %d (err=%d)\n"
            "%s: attached v2 protocol %d (count = %d)\n"
        }
        symbol = "ifnet_attach_protocol_v2"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s: detached %s protocol %d\n"
        }
        symbol = "ifnet_detach_protocol"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: flags mismatch (embryonic not set) ifp=%p"
            "ifp->if_threads_pending == 0"
            "%s: Attempt to attach interface without family module - %d\n"
            "ifp->if_proto_hash == NULL"
            "LIST_EMPTY(&ifp->if_multiaddrs)"
            "ifp->if_allhostsinm == NULL"
            "ifnet_addrs[ifp->if_index - 1] == NULL"
            "ifp->if_output_sched_model == IFNET_SCHED_MODEL_NORMAL || ifp->if_output_sched_model == IFNET_SCHED_MODEL_DRIVER_MANAGED || ifp->if_output_sched_model == IFNET_SCHED_MODEL_FQ_CODEL"
            "dl_inp->dlth_flags == 0"
            "dl_inp->dlth_wtot == 0"
            "dl_inp->dlth_ifp == NULL"
            "qhead(&dl_inp->dlth_pkts) == NULL && qempty(&dl_inp->dlth_pkts)"
            "qlimit(&dl_inp->dlth_pkts) == 0"
            "!dl_inp->dlth_affinity"
            "ifp->if_inp == NULL"
            "dl_inp->dlth_thread == THREAD_NULL"
            "dl_inp->dlth_strategy == NULL"
            "dl_inp->dlth_driver_thread == THREAD_NULL"
            "dl_inp->dlth_poller_thread == THREAD_NULL"
            "dl_inp->dlth_affinity_tag == 0"
            "dl_inp->dlth_pkts_cnt == 0"
            "thfunc == NULL"
            "%s: ifp=%p couldn\\'t get an input thread; err=%d"
            "ifp->if_start_thread == THREAD_NULL"
            "ifp->if_start != NULL"
            "%s: ifp=%p couldn\\'t get a start thread; err=%d"
            "ifp->if_input_poll != NULL"
            "ifp->if_input_ctl != NULL"
            "%s: ifp=%p couldn\\'t get a poll thread; err=%d"
            "ifp->if_desc.ifd_len == 0"
            "%s: attached with %d suspended link-layer multicast membership(s)\n"
            "ifp->if_agentids == NULL"
            "ifp->if_agentcount == 0"
            "%s if_set_qosmarking_mode(%s) error %d\n"
            "IGMP_IFINFO(ifp) != NULL"
            "IGMP_IFINFO(ifp)->igi_ifp == ifp"
            "MLD_IFINFO(ifp) != NULL"
            "MLD_IFINFO(ifp)->mli_ifp == ifp"
            "ifp->if_data_threshold == 0"
            "%s: Waiting for all kernel threads created for interface %s to get scheduled at least once.\n"
            "%s: All kernel threads created for interface %s have been scheduled at least once. Proceeding.\n"
            "%s: attached%s\n"
            " (recycled)"
            "%s: %s already has nexus attached\n"
            "%s kern_nexus_ifattach %d\n"
            "ll_addr == NULL || ll_addr->sdl_alen == ifp->if_addrlen"
            "ifa->ifa_debug == IFD_LINK"
        }
        symbol = "ifnet_attach"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "ifp->if_flowhash != 0"
            "ifp != NULL && (ifp->if_eflags & IFEF_TXSTART)"
        }
        symbol = "ifnet_disable_output"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "!(ifp->if_refflags & IFRF_EMBRYONIC)"
            "%s: detaching\n"
            "ifnet_detach"
            "ifindex2ifnet[ifp->if_index] == ifp"
            "ifnet_detaching_cnt != 0"
            "%s %s tcp_kao_cnt %u not zero"
        }
        symbol = "ifnet_detach"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "*ifp == NULL"
            "((intptr_t)base + dlif_size) <= ((intptr_t)buf + dlif_bufsize)"
            "%s: failed to allocate if local stats, error: %d\n"
            "dlil_if_acquire"
            "dlifp1 == NULL || (IS_P2ALIGNED(dlifp1, sizeof(u_int64_t)) && IS_P2ALIGNED(&ifp1->if_data, sizeof(u_int64_t)))"
        }
        symbol = "dlil_if_acquire"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "src_rt.ro_rt == NULL"
        }
        symbol = "ifnet_cached_rtlookup_inet"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "lqm >= IFNET_LQM_MIN && lqm <= IFNET_LQM_MAX"
        }
        symbol = "if_lqm_update"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: Post DL_NODE_PRESENCE failed witherror %d\n"
            "dlil_node_present"
        }
        symbol = "dlil_node_present"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "sa != NULL"
        }
        symbol = "dlil_node_absent"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "sa != NULL && sdl != NULL"
            "sa->sa_family == AF_INET6 && sdl->sdl_family == AF_LINK"
            "sdl->sdl_len <= sizeof(*kev_sdl)"
            "%s: Post DL_NODE_PRESENCE failed with error %d\n"
            "dlil_node_present_v2"
        }
        symbol = "dlil_node_present_v2"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "modid != NULL"
        }
        symbol = "dlil_report_issues"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "cmd == SIOCSIFOPPORTUNISTIC || cmd == SIOCGIFOPPORTUNISTIC"
        }
        symbol = "ifnet_getset_opportunistic"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: throttling level set to %d\n"
        }
        symbol = "ifnet_set_throttle"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "cmd == SIOCSIFLOG || cmd == SIOCGIFLOG"
        }
        symbol = "ifnet_getset_log"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "level >= IFNET_LOG_MIN && level <= IFNET_LOG_MAX"
            "flags & IFNET_LOGF_MASK"
            "%s: logging level set to %d flags=0x%x arg=0x%x, category=%d subcategory=%d\n"
        }
        symbol = "ifnet_set_log"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "NAT64 prefixes purged from Interface %s\n"
            "NAT64 prefixlen is incorrect %d\n"
            "NAT64 prefix has interface/link local scope.\n"
            "NAT64 prefix set to %s with prefixlen: %d\n"
        }
        symbol = "ifnet_set_nat64prefix"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "skip attaching fsw to %s using legacy TX model\n"
            "%s: can't find netif for %s\n"
            "%s kern_nexus_ifattach device failed %d %s\n"
            "%s: not attaching flowswitch to %s\n"
        }
        symbol = "dlil_attach_flowswitch_nexus"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "%s: SIOCGIFDEVMTU failed for %s\n"
            "%s: %s %d %d\n"
            "%s: can't determine MAX MTU for %s\n"
            "%s: can't get pbufpool info for %s\n"
            "%s: interface %s packet pool (rx %d * %d, tx %d * %d) can't support max mtu(%d)\n"
        }
        symbol = "_dlil_get_flowswitch_buffer_size"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s can't get %s provider, error %d\n"
            "%s register %s provider failed, error %d\n"
            "%s alloc_provider_instance %s failed, %d\n"
        }
        symbol = "dlil_create_provider_and_instance"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "dlil_detach_flowswitch_nexus"
        }
        symbol = "dlil_detach_flowswitch_nexus"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "%s deregister_provider %d\n"
            "%s kern_nexus_ifdetach device failed %d\n"
            "%s free_provider_instance failed %d\n"
        }
        symbol = "dlil_detach_nexus"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "dlil_filter_event"
            "%s: eventhandler saw event type=net_filter_event_state event_code=0x%d"
        }
        symbol = "dlil_filter_event"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "main_input"
            "%s_input_poll"
            "%s_input"
            "inp->dlth_thread == THREAD_NULL"
            "%s: couldn\\'t create main input thread"
            "%s: couldn\\'t create %s input thread"
        }
        symbol = "dlil_create_input_thread"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "m_head != NULL || (m_tail == NULL && m_cnt == 0)"
            "dlil_input_async"
            "%s %s burst limit %u (sysctl: %u) exceeded. %u packets dropped [%u total in %u events]. new qlen %u "
        }
        symbol = "dlil_input_async"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "overcommitted_qlen == target_qlen + dropped_pkts"
            "%s: qlen: %u -> %u, qsize: %llu -> %llu qlimit: %u (sysctl: %u) target_qlen: %u (if_rcvq_trim_pct: %u) pkts_to_drop: %u dropped_pkts: %u dropped_bytes %u\n"
            "dlil_trim_overcomitted_queue_locked"
        }
        symbol = "dlil_trim_overcomitted_queue_locked"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "inp->dlth_ifp == NULL"
        }
        symbol = "dlil_main_input_thread_func"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "wres != THREAD_INTERRUPTED"
            "!(inp->dlth_flags & (DLIL_INPUT_TERMINATE | DLIL_INPUT_RUNNING))"
            "!(inp->dlth_flags & DLIL_INPUT_TERMINATE)"
        }
        symbol = "dlil_main_input_thread_cont"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "!(ifp->if_eflags & IFEF_RXPOLL) || !net_rxpoll || !(ifp->if_xflags & IFXF_LEGACY)"
            "ifp->if_poll_mode == IFNET_MODEL_INPUT_POLL_OFF || !(ifp->if_xflags & IFXF_LEGACY)"
            "dlil_input_%s"
        }
        symbol = "dlil_input_thread_func"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "(inp->dlth_flags & DLIL_INPUT_TERMINATE) != 0"
            "%s: input thread terminated\n"
        }
        symbol = "dlil_terminate_input_thread"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "dlil_input_sync"
            "%s %s burst limit %u (sysctl: %u) exceeded. %u packets dropped [%u total in %u events]. new qlen %u \n"
        }
        symbol = "dlil_input_sync"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: %s filter detached\n"
            "%s filter detached\n"
            "OSDecrementAtomic64(&net_api_stats.nas_iflt_attach_count) > 0"
            "OSDecrementAtomic64(&net_api_stats.nas_iflt_attach_os_count) > 0"
            "failed to detach %s filter (err=%d)\n"
        }
        symbol = "dlil_detach_filter_internal"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "m_head != NULL || (s == NULL && m_tail == NULL && !ext && poll)"
            "m_tail == NULL || ext"
            "input_func != NULL"
            "%s: invalid mbuf %p\n"
            "%s: invalid input packet chain for %s, tail mbuf %p instead of %p\n"
            "%s: input packet count mismatch for %s, %d instead of %d\n"
        }
        symbol = "ifnet_input_common"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "IS_INTF_CLAT46(ifp)"
            "*proto_family == PF_INET"
        }
        symbol = "dlil_clat46"
        caller = "?"
    }
    new {
        args = 3
        anchors {
            "%s: frame header pointer 0x%llx out of range [0x%llx,0x%llx] for mbuf 0x%llx\n"
            "%s: partial cksum start offset %d is less than frame header length %d for mbuf 0x%llx\n"
            "%s: bad partial cksum value 0x%x (expected 0x%x) for mbuf 0x%llx [rx_start %d]\n"
            "failed to restore"
            "wake packet from %s len %d"
        }
        symbol = "dlil_input_packet_list_common"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "if_proto_count == tmp_ifproto_arr_idx"
            "proto != NULL"
        }
        symbol = "dlil_event_internal"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "proto->detached"
        }
        symbol = "if_proto_free"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "dlil_attach_protocol"
        }
        symbol = "dlil_attach_protocol"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "ifnet_start_%s"
            "skywalk_doorbell_%s_tx"
            "!ifp->if_start_embryonic && !ifp->if_start_active"
        }
        symbol = "ifnet_start_thread_func"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: starter thread terminated\n"
        }
        symbol = "ifnet_start_thread_cont"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "ifp != NULL && (ifp->if_eflags & IFEF_RXPOLL) && (ifp->if_xflags & IFXF_LEGACY)"
            "dlil_input_poll_%s"
        }
        symbol = "dlil_rxpoll_input_thread_func"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "m != NULL || m_cnt == 0"
            "%s: [%s] pkts avg %d max %d limits [%d/%d], wreq avg %d limits [%d/%d], bytes avg %d limits [%d/%d]\n"
            "%s: polling is now %s, pkts avg %d max %d limits [%d/%d], wreq avg %d limits [%d/%d], bytes avg %d limits [%d/%d]\n"
            "%s: error setting polling mode to %s (%d)\n"
        }
        symbol = "dlil_rxpoll_input_thread_cont"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "ifnet_poller_%s"
            "!(ifp->if_poll_flags & (IF_POLLF_EMBRYONIC | IF_POLLF_RUNNING))"
        }
        symbol = "ifnet_poll_thread_func"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: polling up to %d pkts, pkts avg %d max %d, wreq avg %d, bytes avg %d\n"
            "m_tail != NULL && m_cnt > 0"
            "%s: polled %d pkts, pkts avg %d max %d, wreq avg %d, bytes avg %d\n"
            "%s: no packets, pkts avg %d max %d, wreq avg %d, bytes avg %d\n"
            "%s: poller thread terminated\n"
        }
        symbol = "ifnet_poll_thread_cont"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "TAILQ_FIRST(&ifnet_detaching_head) != NULL"
            "ifnet_detaching_cnt != 0 || ifp == NULL"
            "%s: flags mismatch (detaching not set) ifp=%p @%s:%d"
            "ifp->if_datamov == 0"
            "ifp->if_drainers == 0"
            "ifp->if_suspend == 0"
            "LIST_EMPTY(&ifp->if_netns_tokens)"
            "ifnet_addrs[ifp->if_index - 1] == ifa"
            "ifp->if_link.tqe_next == NULL"
            "ifp->if_link.tqe_prev == NULL"
            "ifp->if_ordered_link.tqe_next == NULL"
            "ifp->if_ordered_link.tqe_prev == NULL"
            "%s: waiting for %s starter thread to terminate\n"
            "ifnet_start_thread_exit"
            "%s: %s starter thread termination complete"
            "%s: waiting for %s poller thread to terminate\n"
            "%s: %s poller thread termination complete\n"
            "ifp->if_xflags & IFXF_LEGACY"
            "ifp->if_na_ops == NULL"
            "ifp->if_na == NULL"
            "!ifp->if_fwd_cacheok"
            "!thread_call_isactive(ifp->if_dt_tcall)"
            "%s: detached\n"
            "qhead(&inp->dlth_pkts) == NULL && qempty(&inp->dlth_pkts)"
            "!inp->dlth_affinity"
            "inp->dlth_affinity_tag == 0"
        }
        symbol = "ifnet_detacher_thread_cont"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "dlil_detach_netif_nexus"
        }
        symbol = "dlil_detach_netif_nexus"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: dl_if %p has no debug structure @%s:%d"
            "dlil_if_trace"
        }
        symbol = "dlil_if_trace"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "OSDecrementAtomic64(&net_api_stats.nas_ifnet_alloc_count) > 0"
            "OSDecrementAtomic64(&net_api_stats.nas_ifnet_alloc_os_count) > 0"
        }
        symbol = "_dlil_if_release"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "WARNING: %s can't attach ip to %s\n"
            "ether_attach_inet"
        }
        symbol = "ether_attach_inet"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s: can't handle af%d\n"
        }
        symbol = "ether_inet_pre_output"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "WARNING: %s can't attach ipv6 to %s\n"
            "ether_attach_inet6"
        }
        symbol = "ether_attach_inet6"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "lo_txstart"
            "%s: couldn\\'t allocate loopback ifnet (%d) @%s:%d"
            "%s: couldn\\'t attach loopback ifnet (%d) @%s:%d"
        }
        symbol = "loopattach"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "lo_attach_proto: ifnet_attach_protocol for %u returned=%d\n"
        }
        symbol = "lo_attach_proto"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "lo_input"
        }
        symbol = "lo_input"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "(*m)->m_flags & M_PKTHDR"
        }
        symbol = "lo_pre_output"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: mbuf_set_status() failed %d\n"
        }
        symbol = "lo_tx_compl"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "ifp == lo_ifp"
        }
        symbol = "lo_set_bpf_tap"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "ifvlan_release: bad signature @%s:%d"
            "ifvlan_release: retain count is 0 @%s:%d"
            "ifvlan_release"
        }
        symbol = "ifvlan_release"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "vlan_parent_release: signature is bad @%s:%d"
            "vlan_parent_release: retain count is 0 @%s:%d"
            "vlan_parent_release"
        }
        symbol = "vlan_parent_release"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "vlan_parent_wait"
            "%s: %s: %s msleep"
            "%s: %s: %s woke up"
        }
        symbol = "vlan_parent_wait"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "vlan_parent_create"
            "%s: %s: siocgifdevmtu failed, %d"
        }
        symbol = "vlan_config"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "vlan_attach_protocol"
            "%s: %s: ifnet_attach_protocol failed, %d"
        }
        symbol = "vlan_attach_protocol"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "(scan->m_pkthdr.csum_flags & CSUM_VLAN_TAG_VALID) != 0"
            "tag != 0"
            "vlan_input"
            "%s: %s tag %d"
        }
        symbol = "vlan_input"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "vlan_input_tag"
            "vlan_input_packet_list"
            "%s: %s VLAN tag %d (dropped)"
            "%s: %s: packets %d bytes %d"
        }
        symbol = "vlan_input_tag"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "vlan_parent_link_event"
        }
        symbol = "vlan_event"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "feth_fake_tx_exp_policy_sysctl"
            "%s: if_fake_tx_exp_policy: %u -> %u (%d)"
        }
        symbol = "feth_fake_tx_exp_policy_sysctl"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "com.apple.feth"
            "feth_register_nexus_domain_provider"
            "%s: failed to register domain provider"
        }
        symbol = "if_fake_init"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "fakeif->iff_retain_count == 0"
            "fakeif->iff_rx_pp == S_pp"
            "fakeif->iff_tx_pp == S_pp"
            "feth_free"
        }
        symbol = "feth_release"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "fakeif->iff_doorbell_tcall == NULL"
        }
        symbol = "feth_if_free"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "feth shared pp"
            "%s rx pp"
            "%s tx pp"
            "%s: feth used as ifname prefix but logical link support in feth is disabled."
            "%s: TSO mode requires global packet pool mode"
            "%s: multi-buflet not supported for split rx & tx pool"
            "%s: rx pp create failed %d"
            "%s: tx pp create failed %d"
            "%s: register provider failed, error %d"
            "%s: alloc_net_provider_instance failed, %d"
            "%s: create_non_default_llinks failed, %d"
            "%s: %s: nx not found"
            "%s: %s: llink add failed, error %d"
            "%s: %s: llink remove failed, llink_id 0x%llx, error %d"
        }
        symbol = "feth_clone_create"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "feth_nx_connected"
            "%s: %s: connected channel %p"
        }
        symbol = "feth_nx_connected"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "feth_nx_pre_disconnect"
            "%s: %s: pre-disconnect channel %p"
        }
        symbol = "feth_nx_pre_disconnect"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "feth_nx_disconnected"
            "%s: %s: disconnected channel %p"
        }
        symbol = "feth_nx_disconnected"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "fakeif->iff_tx_ring[ring_idx] == NULL"
            "fakeif->iff_tx_ring[0] == NULL"
            "fakeif->iff_rx_ring[0] == NULL"
            "feth_nx_ring_init"
            "%s: %s: %s ring init"
        }
        symbol = "feth_nx_ring_init"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "feth threadcall"
            "%s: %s: RX ring fini"
            "%s: %s: TX ring fini"
            "%s: %s: thread_call_cancel %s"
            "%s: %s: *waiting for threadcall"
            "%s: %s: ^threadcall done"
            "%s: %s: thread_call_free %s"
        }
        symbol = "feth_nx_ring_fini"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "clock_timebase.denom != 0"
            "feth_packet_has_expired"
            "feth_get_effective_expn_action"
            "%s: %s sent expiry notification on nexus port %u notif code %u"
            "%s: %s err=%d, nx_port_id: 0x%x"
            "%s: Packet has %llu usec until expiration"
            "%s: Unrecognized value %d for \"net.link.fake.tx_exp_policy\""
        }
        symbol = "feth_tx_expired_error"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "feth_tx_complete_error"
        }
        symbol = "feth_tx_complete_error"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "baddr != 0"
            "bufcnt == kern_packet_get_buflet_count(dph)"
        }
        symbol = "feth_copy_packet"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "feth_clone_packet"
            "%s: packet clone err %d"
        }
        symbol = "feth_clone_packet"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "feth_nx_sync_rx"
        }
        symbol = "feth_nx_sync_rx"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "feth_nx_tx_doorbell"
            "%s: %s: TX refill (sync) %d"
            "%s: %s: TX refilled (sync)"
            "%s: %s: schedule async refill"
        }
        symbol = "feth_nx_tx_doorbell"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "feth_nx_tx_dequeue_driver_managed"
            "%s: %s: TX refill ring %d (%s) %d"
            "%s: %s: TX refilled ring %d (%s)"
        }
        symbol = "feth_nx_tx_dequeue_driver_managed"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "feth_nx_capab_config"
        }
        symbol = "feth_nx_capab_config"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "feth_nx_intf_adv_config"
            "%s: %s enable %d"
        }
        symbol = "feth_nx_intf_adv_config"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "feth_notify_steering_info"
            "%s: %s: notify_steering_info: qset_id 0x%llx, %s"
        }
        symbol = "feth_notify_steering_info"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "feth_nx_tx_qset_notify"
            "%s: %s qset %p, idx %d, flags 0x%x"
            "%s: %s: detaching %s, channel connected %s"
            "%s: peer %s: detaching %s, channel connected %s"
            "%s: peer_fakeif is NULL"
            "%s: peer_ifp is NULL"
            "%s: %s queue %p dequeue failed: err %d"
        }
        symbol = "feth_nx_tx_qset_notify"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "feth_nx_tx_queue_deliver_pkt_chain"
            "%s: %s -> %s"
        }
        symbol = "feth_nx_tx_queue_deliver_pkt_chain"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "feth_nx_queue_tx_push"
            "%s: %s queue %p"
        }
        symbol = "feth_nx_queue_tx_push"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "com.apple.xnu.net.redirect"
            "redirect_register_nexus_domain_provider"
            "%s: failed to register domain provider\n"
        }
        symbol = "if_redirect_init"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "rd->rd_retain_count == 0"
            "redirect_free"
            "%s: %s\n"
        }
        symbol = "redirect_release"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "redirect_max_mtu"
        }
        symbol = "redirect_max_mtu"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "redirect_clear_delegate_locked"
        }
        symbol = "redirect_clear_delegate_locked"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "rd->rd_doorbell_tcall == NULL"
            "%s: ifp is NULL\n"
        }
        symbol = "redirect_if_free"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "redirect_demux"
            "%s: data is NULL\n"
        }
        symbol = "redirect_demux"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "redirect_attach_netif_nexus"
            "%s: create params not specified\n"
            "%s: copyin failed: error %d\n"
            "%s: invalid type(0x%x) or len(0x%d)\n"
            "%s: functional type(0x%x) not supported\n"
            "%s: invalid ifc_name(%s) or unit(%d)\n"
            "%s: attach netif nexus failed: error %d\n"
            "%s: %s packet pool make failed: %d\n"
            "%s: %s register provider failed, error %d\n"
            "%s: %s alloc net provider instance failed %d\n"
        }
        symbol = "redirect_clone_create"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "redirect_nx_connected"
            "%s: %s: connected channel %p\n"
        }
        symbol = "redirect_nx_connected"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "redirect_nx_pre_disconnect"
            "%s: %s: pre-disconnect channel %p\n"
        }
        symbol = "redirect_nx_pre_disconnect"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "redirect_nx_disconnected"
            "%s: %s: disconnected channel %p\n"
        }
        symbol = "redirect_nx_disconnected"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "rd->rd_tx_ring[0] == NULL"
            "rd->rd_rx_ring[0] == NULL"
            "redirect_nx_ring_init"
            "%s: %s: %s ring init\n"
        }
        symbol = "redirect_nx_ring_init"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "redirect threadcall"
            "%s: %s: RX ring fini\n"
            "%s: %s: TX ring fini\n"
            "%s: %s: thread_call_cancel %s\n"
            "%s: %s: *waiting for threadcall\n"
            "%s: %s: threadcall done\n"
            "%s: %s: thread_call_free %s\n"
        }
        symbol = "redirect_nx_ring_fini"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "multicast_list_program: ifnet_get_multicast_list(%s%d) failed, %d\n"
        }
        symbol = "multicast_list_program"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "bond_clone_create"
            "%s: %s: failed to add slow_proto multicast, %d"
        }
        symbol = "bond_clone_create"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "ifbond_release"
            "%s: %s: removing multicast"
        }
        symbol = "ifbond_release"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "/AppleInternal/Library/BuildRoots/d3a62b52-2ef5-11ef-9ecd-e2437461156c/Library/Caches/com.apple.xbs/Sources/xnu/bsd/net/if_bond.c"
            "bond_output"
            "%s: %s: %s bytes %d, error=%d"
        }
        symbol = "bond_output"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "bond_set_mtu"
        }
        symbol = "bond_set_mtu"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "ifbond_wait"
        }
        symbol = "ifbond_wait"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "bond_set_mtu_on_ports"
            "%s: %s: SIOCSIFMTU %s failed, %d"
        }
        symbol = "bond_set_mtu_on_ports"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "bondport_timer_process_func"
            "%s: %s: (timer) generating LINK event"
        }
        symbol = "bondport_timer_process_func"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "bond_attach_protocol"
        }
        symbol = "bond_attach_protocol"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "bond_input_packet_list"
            "%s: %s: %s packets %d bytes %d"
        }
        symbol = "bond_input_packet_list"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "ifbond_list_find_moved_port"
            "bond_receive_la_marker_pdu"
            "%s: dropping short LACP frame %d < %d"
            "%s: m_pullup LACPDU failed"
            "%s: m_pullup LA_MARKER failed"
            "%s: %s: (receive) generating LINK event"
            "%s: simulating link status changed event"
            "%s: System %x:%x:%x:%x:%x:%x Port 0x%x moved from %s to %s"
        }
        symbol = "bond_input"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "bondport_receive_machine_current"
            "bondport_UpdateSelected"
            "bondport_UpdateNTT"
            "%s: [%s] Receive CURRENT"
            "%s: [%s] updateSelected UNSELECTED"
            "%s: [%s] updateNTT: Need To Transmit"
            "%s: [%s] recordPDU: LACP will maintain"
            "%s: [%s] recordPDU: LACP partner in sync"
            "%s: [%s] recordPDU: LACP partner in sync (ind)"
        }
        symbol = "bondport_receive_machine_current"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "bondport_set_selected"
            "%s: [%s] SetSelected: %s (was %s)"
        }
        symbol = "bondport_set_selected"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "bondport_assign_to_LAG"
            "%s: Key 0x%04x: LAG Created (0x%04x,%x:%x:%x:%x:%x:%x,0x%04x)"
        }
        symbol = "bondport_assign_to_LAG"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "bondport_remove_from_LAG"
            "%s: [%s] Removed from LAG (0x%04x,%x:%x:%x:%x:%x:%x,0x%04x)"
            "%s: Key 0x%04x: LAG Released (%04x,%x:%x:%x:%x:%x:%x,0x%04x)"
        }
        symbol = "bondport_remove_from_LAG"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "bondport_add_to_LAG"
            "%s: [%s] Added to LAG (0x%04x,%x:%x:%x:%x:%x:%x0x%04x)"
        }
        symbol = "bondport_add_to_LAG"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "bondport_receive_machine_expired"
            "%s: [%s] Receive EXPIRED"
        }
        symbol = "bondport_receive_machine_expired"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "bondport_receive_machine_defaulted"
            "%s: [%s] Receive DEFAULTED"
        }
        symbol = "bondport_receive_machine_defaulted"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "bondport_receive_machine_lacp_disabled"
            "%s: [%s] Receive LACP_DISABLED"
        }
        symbol = "bondport_receive_machine_lacp_disabled"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "bondport_receive_machine_initialize"
            "%s: [%s] Receive INITIALIZE"
        }
        symbol = "bondport_receive_machine_initialize"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "bondport_mux_machine_detached"
            "bondport_DetachMuxFromAggregator"
            "%s: [%s] Mux DETACHED"
            "%s: [%s] Detached Mux From Aggregator"
        }
        symbol = "bondport_mux_machine_detached"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "bondport_mux_machine_attached"
            "bondport_AttachMuxToAggregator"
            "%s: [%s] Mux ATTACHED"
            "%s: [%s] Attached Mux To Aggregator"
        }
        symbol = "bondport_mux_machine_attached"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "bondport_mux_machine_collecting_distributing"
            "%s: [%s] Mux COLLECTING_DISTRIBUTING"
        }
        symbol = "bondport_mux_machine_collecting_distributing"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "bond_handle_event"
            "%s: %s: (event) generating LINK event"
            "%s: [%s] Link UP %d Mbit/s %s duplex"
            "%s: [%s] Link DOWN"
            "%s: [%s] Port speed %d differs from LAG %d"
        }
        symbol = "bond_handle_event"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "bondport_slow_proto_transmit"
            "%s: (%s) failed %d"
        }
        symbol = "bondport_slow_proto_transmit"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "[%s] Transmit: failed to allocate packet buffer\n"
            "%s: [%s] Transmit Timer Already Set"
            "%s: [%s] Transmit Timer Deadline %d secs"
            "%s: [%s] Transmit Timer Complete"
            "%s: [%s] Transmit Packet %d"
        }
        symbol = "bondport_transmit_machine"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "ifbond_selection"
            "%s: LAG PORT SPEED CHANGED from %d to %d"
        }
        symbol = "ifbond_selection"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "bondport_disable_distributing"
            "%s: [%s] Distribution Disabled"
        }
        symbol = "bondport_disable_distributing"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "bond_set_mode"
        }
        symbol = "bond_set_mode"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "bond_set_promisc"
            "%s: %s: ifnet_set_promiscuous(%s, %d): failed %d"
            "%s: %s: ifnet_set_promiscuous(%s, %d): succeeded"
            "%s: %s: multicast_list_program(%s) failed, %d"
        }
        symbol = "bond_ioctl"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "bond_if_detach"
            "%s: %s: ifnet_detach failed, %d"
        }
        symbol = "bond_clone_destroy"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "devtimer_set_absolute: uninitialized/freed timer\n"
        }
        symbol = "devtimer_set_absolute"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "ndrvdomain == NULL"
        }
        symbol = "ndrv_dominit"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "rn_addmask: mask impossibly already in tree"
        }
        symbol = "rn_addmask"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "Non-unique normal route, mask not entered"
        }
        symbol = "rn_addroute"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "rn_delete: couldn\\'t find our annotation\n"
            "rn_delete: couldn\\'t find us\n"
            "rn_delete: Orphaned Mask 0x%llx at 0x%llx\n"
        }
        symbol = "rn_delete"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "rn_init: radix functions require max_keylen be set\n"
            "radix_node"
        }
        symbol = "rn_init"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "rte_debug"
            "rtentry"
        }
        symbol = "route_init"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "buf != NULL && buflen >= sizeof(*ss)"
            "buflen >= sa->sa_len"
            "sdl->sdl_alen == size"
            "%s: broken logic (sa_len %d < skip %d ) @%s:%d"
            "sa_trim"
        }
        symbol = "rtm_scrub"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "rtunref"
            "rtunref: on freed rte=%p @%s:%d"
        }
        symbol = "rtunref"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "(p->rt_flags & RTF_DEAD) == 0"
            "rtref"
            "rtref_audit: on freed rte=%p @%s:%d"
        }
        symbol = "rtref"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "rt != ogwrt"
            "rt->rt_gwroute == NULL"
        }
        symbol = "rt_set_gwroute"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "gwrt != NULL"
            "rt->rt_flags & (RTF_CLONING | RTF_PRCLONING)"
        }
        symbol = "rt_revalidate_gwroute"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "rt == gwrt && rt != hint"
        }
        symbol = "route_to_gwroute"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "p_gw_saddr->sa_len <= sizeof(p_rt_ev->rt_ev_arg.rt_addr)"
            "route_event_enqueue_nwk_wq_entry"
            "%s: eventhandler enqueuing event of type=route_event event_code=%s"
        }
        symbol = "route_event_enqueue_nwk_wq_entry"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "sin6_get_embedded_ifscope"
            "IN6_IS_SCOPE_EMBED(&(SIN6(sa)->sin6_addr))"
        }
        symbol = "sa_copy"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "rt %p invalid refcnt %d @%s:%d"
            "!(rt->rt_flags & RTF_IFREF)"
            "rt %p freed while in radix tree @%s:%d"
            "rt->rt_llinfo_free != NULL"
        }
        symbol = "rtfree_common"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "rte_free: rte=%p refcnt=%d non-zero @%s:%d"
            "rte_free: rte=%p refcnt=%d @%s:%d"
            "rte_free: double free rte=%p @%s:%d"
            "rte_free: corrupted rte=%p @%s:%d"
        }
        symbol = "rte_free"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "SIN6(dst)->sin6_scope_id != IFSCOPE_NONE"
            "rtrequest delete @%s:%d"
            "rt->rt_flags & RTF_HOST"
            "rtrequest: RTF_GATEWAY but no gateway @%s:%d"
            "rtrequest_common_locked"
            "(*ret_nrt)->rt_expire == 0 || (*ret_nrt)->rt_rmx.rmx_expire != 0"
            "(*ret_nrt)->rt_expire != 0 || (*ret_nrt)->rt_rmx.rmx_expire == 0"
            "%s: route already exists: %s->%s->%s"
        }
        symbol = "rtrequest_common_locked"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "!coarse || ifscope == IFSCOPE_NONE"
            "%s unscoped search %p to %s->%s->%s ifa_ifp %s\n"
            "%s %u return NULL\n"
            "%s %u return %p to %s->%s->%s ifa_ifp %s\n"
        }
        symbol = "rt_lookup_common"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: invalid count argument (%d) @%s:%d"
            "%s: ifp=%p negative route refcnt! @%s:%d"
        }
        symbol = "rte_if_ref"
        caller = "?"
    }
    new {
        args = 4
        anchors {
            "rt_key(rt)->sa_family == AF_INET"
            "link#%u"
        }
        symbol = "rt_str"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "evtag != NULL"
            "eventhandler_deregister event_type=route_event"
            "eventhandler_invoke(\"route_event\")"
        }
        symbol = "route_event_callback"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "in->rt_expire == 0 || in->rt_rmx.rmx_expire != 0"
            "in->rt_expire != 0 || in->rt_rmx.rmx_expire == 0"
        }
        symbol = "rt_getmetrics"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "routedomain == NULL"
        }
        symbol = "route_dinit"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "out->rt_expire == 0 || out->rt_rmx.rmx_expire != 0"
            "out->rt_expire != 0 || out->rt_rmx.rmx_expire == 0"
        }
        symbol = "rt_setmetrics"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "so->so_pcb == NULL"
        }
        symbol = "rts_attach"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "rp != NULL"
        }
        symbol = "rts_detach"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "com.apple.netsrc"
            "%s: ctl_register failed %d\n"
            "netsrc_init"
        }
        symbol = "netsrc_init"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s: invalid family\n"
            "netsrc_ctlsend"
        }
        symbol = "netsrc_ctlsend"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "com.apple.xnu.net"
            "ntstat"
            "com.apple.network.statistics"
        }
        symbol = "nstat_init"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "ntstat_userland_stats_open"
            "%s - incorrect provider is supplied, %d"
        }
        symbol = "ntstat_userland_stats_open"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "nstat_tcp_copy_descriptor"
            "%s - NSTAT_DEBUG_SOCKET <pid %d>: NSTAT: TCP - pid %d uid %d euuid %s persona id %d"
        }
        symbol = "nstat_tcp_copy_descriptor"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "nstat_udp_copy_descriptor"
            "%s - NSTAT_DEBUG_SOCKET <pid %d>: NSTAT: UDP - pid %d uid %d euuid %s persona id %d"
        }
        symbol = "nstat_udp_copy_descriptor"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "nstat_userland_protocol_add_watcher"
            "%s - nstat_client_source_add returned %d for provider type: %d"
        }
        symbol = "nstat_userland_protocol_add_watcher"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "nstat_generic_provider_add_watcher"
        }
        symbol = "nstat_generic_provider_add_watcher"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "nstat_generic_provider_reporting_allowed"
            "%s - attempt to filter conn provider by effective pid/uuid, not supported"
        }
        symbol = "nstat_generic_provider_reporting_allowed"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "i == nkeyvals"
            "i > 0 && i <= nkeyvals"
        }
        symbol = "nstat_sysinfo_send_data"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "nstat_client_handle_query_request"
        }
        symbol = "nstat_client_send"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "nstat_flush_accumulated_msgs"
            "%s - ctl_enqueuembuf failed: %d"
        }
        symbol = "nstat_flush_accumulated_msgs"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "nstat_client_cleanup_source"
        }
        symbol = "nstat_client_cleanup_source"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "tcp_progress_probe_enable_for_interface"
            "%s - for interface index %u with flags %d"
            "%s - *matched* interface index %d, enable: %d"
            "%s - (%d) - nstat set tcp probe %d for interface index %d"
        }
        symbol = "ntstat_tcp_progress_enable"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "gif_init"
        }
        symbol = "gif_init"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "gif_attach_proto_family can't attach interface\t\t\t    fam=%d\n"
        }
        symbol = "gif_attach_proto_family"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "gif_clone_destroy: gif remove failed %d\n"
            "gif_clone_destroy: ifnet_set_flags failed %d\n"
            "gif_clone_destroy: ifnet_detach(%p) failed %d @%s:%d"
        }
        symbol = "gif_clone_destroy"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "gif_clone_create, ifnet_allocate failed - %d\n"
            "%s: unable to attach encap4\n"
            "%s: unable to attach encap6\n"
            "gif_clone_create - ifnet_attach failed - %d\n"
        }
        symbol = "gif_clone_create"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "gif_add_proto: request add_proto for gif%d\n"
        }
        symbol = "gif_add_proto"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "sftattach encap_attach_func failed\n"
            "stfattach, ifnet_allocate failed - %d\n"
            "stfattach: ifnet_attach returned error=%d\n"
        }
        symbol = "stfattach"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "stf: IFF_DOWN\n"
        }
        symbol = "stf_pre_output"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "stf_attach_proto_family can't attach interface fam=%d\n"
        }
        symbol = "stf_attach_inet6"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "stf_add_proto: stf already has a proto\n"
        }
        symbol = "stf_add_proto"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "defer encapsulated ESP matching"
            "%s: called PKTF_WAKE_PKT not set from %s"
            "%s: mbuf_copydata(ip) error %d"
            "%s: mbuf_copydata(tcphdr) error %d"
            "%s: mbuf_copydata(udphdr) error %d"
            "%s: unexpected IPv4 protocol %u from %s"
            "%s: mbuf_copydata(ip6_hdr) error %d"
            "%s: mbuf_copydata(ip6_frag) error %d"
            "%s: unexpected IPv6 protocol %u from %s"
            "%s: unexpected protocol family %d from %s"
        }
        symbol = "if_ports_used_match_mbuf"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "TAILQ_EMPTY(&net_port_entry_hash_table[i])"
            "/AppleInternal/Library/BuildRoots/d3a62b52-2ef5-11ef-9ecd-e2437461156c/Library/Caches/com.apple.xbs/Sources/xnu/bsd/net/if_ports_used.c"
            "%s: IOPMCopySleepWakeUUIDKey got bad value %s\n"
            "%s: SleepWakeUUID not set, don't update the port list for %s\n"
            "%s: current wakeuuid %s"
        }
        symbol = "if_ports_used_update_wakeuuid"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: SYSCTL_OUT(xnpigen) error %d\n"
            "%s: SYSCTL_OUT(npi) error %d\n"
        }
        symbol = "sysctl_net_port_info_list"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: ifnet_get_local_ports_extended() error %d\n"
            "sysctl_get_ports_used"
        }
        symbol = "sysctl_get_ports_used"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "is_encapsulated_esp"
            "%s: mbuf_copydata(ESP_HDR_SIZE) error %d"
        }
        symbol = "is_encapsulated_esp"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "wake packet match"
            "wake packet no match"
        }
        symbol = "net_port_info_find_match"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "already notified wake packet"
        }
        symbol = "if_notify_wake_packet"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "if_notify_unattributed_wake_mbuf"
            "%s: mbuf_copydata() failed with error %d for wake uuid %s"
        }
        symbol = "if_notify_unattributed_wake_mbuf"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "if_notify_unattributed_wake_pkt"
            "%s: receive interface is NULL"
        }
        symbol = "if_notify_unattributed_wake_pkt"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "if_set_low_power"
            "%s: ifp %s low_power mode %d"
        }
        symbol = "ifnet_set_low_power_mode"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "if_low_power_evhdlr_callback"
            "%s: ifp %s event_code %d"
        }
        symbol = "if_low_power_evhdlr_callback"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "!(einit.flags & IFNET_INIT_LEGACY) || (ifp->if_pre_enqueue == NULL && ifp->if_start == NULL && ifp->if_output_ctl == NULL && ifp->if_input_poll == NULL && ifp->if_input_ctl == NULL)"
            "!(einit.flags & IFNET_INIT_INPUT_POLL) || (ifp->if_input_poll != NULL && ifp->if_input_ctl != NULL)"
            "!(einit.flags & IFNET_INIT_LEGACY)"
            "(ifp->if_xflags & IFXF_LEGACY) == 0"
        }
        symbol = "ifnet_allocate_extended"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "err == 0 || *addresses == NULL"
            "return_inuse_addrs == 1"
        }
        symbol = "ifnet_get_address_list_family_internal"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: already a cloner for %s\n"
            "%s: if_clone_attach failed %d\n"
        }
        symbol = "ifnet_clone_attach"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: no cloner for %s\n"
            "ifnet_clone_detach"
        }
        symbol = "ifnet_clone_detach"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: delegating to %s would cause a loop\n"
            "%s: is now delegating %s (type 0x%x, family %u, sub-family %u)\n"
            "%s: is no longer delegating %s\n"
        }
        symbol = "ifnet_set_delegate"
        caller = "?"
    }
    new {
        args = 4
        anchors {
            "*used_frames_count <= frames_array_count"
        }
        symbol = "ifnet_get_keepalive_offload_frames"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: set offload flags=0x%x\n"
        }
        symbol = "ifnet_set_offload_common"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "com.apple.net.utun_control"
            "utun_register_nexus"
            "utun_register_control - ctl_register failed: %d\n"
            "utun_register_control - proto_register_plumber(PF_INET, IFNET_FAMILY_UTUN) failed: %d\n"
            "utun_register_control - proto_register_plumber(PF_INET6, IFNET_FAMILY_UTUN) failed: %d\n"
        }
        symbol = "utun_register_control"
        caller = "?"
    }
    new {
        args = 3
        anchors {
            "utun%d"
            "utunid%d"
            "utun_flowswitch_attach - ifnet_detach failed: %d @%s:%d"
            "utun_ctl_connect - utun_nexus_ifattach failed: %d\n"
            "utun_ctl_connect - utun_flowswitch_attach failed: %d\n"
            "utun_ctl_connect - ifnet_allocate failed: %d\n"
            "utun_ctl_connect - ifnet_attach failed: %d\n"
            "%s pbufbool create failed, error %d\n"
            "%s register provider failed, error %d\n"
            "%s alloc_net_provider_instance failed, %d\n"
            "%s: failed to create bridge provider and instance\n"
            "%s kern_nexus_ifattach ms device %d\n"
            "utun_flowswitch_attach - flowswitch is NULL\n"
            "utun_flowswitch_attach - unable to find flowswitch nexus\n"
        }
        symbol = "utun_ctl_connect"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "utun_start"
            "%s: data path stopped for %s\n"
            "utun_start: ctl_getenqueuepacketcount returned error %d\n"
            "utun_start: ifnet_disable_output returned error %d\n"
        }
        symbol = "utun_start"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "utun_data_move_drain"
            "pcb->utun_pcb_drainers > 0"
        }
        symbol = "utun_wait_data_move_drain"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "pcb->utun_netif_rxring == NULL"
            "pcb->utun_netif_txring == NULL"
        }
        symbol = "utun_netif_ring_init"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "utun_netif_sync_tx"
            "tx_offset >= UTUN_HEADER_SIZE(pcb)"
            "utun_netif_sync_tx %s: unknown ip version %u vhl %u tx_offset %u len %u header_size %zu\n"
            "utun_netif_sync_tx %s - mbuf_copyback(%zu) error %d\n"
            "utun_netif_sync_tx %s - mbuf_gethdr error %d\n"
            "utun_netif_sync_tx %s - 0 length packet\n"
        }
        symbol = "utun_netif_sync_tx"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "utun_netif_sync_rx"
            "utun_netif_sync_rx %s: legacy packet length too short for header %zu < %zu\n"
            "utun_netif_sync_rx %s: legacy packet length %zu > %u\n"
            "utun_netif_sync_rx %s: packet length too short for header %u < %zu\n"
        }
        symbol = "utun_netif_sync_rx"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "utun_nexus_detach"
            "%s: kern_nexus_ifdetach ms device failed %d\n"
        }
        symbol = "utun_nexus_detach"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "utun_ctl_disconnect - ifnet_detach failed: %d @%s:%d"
            "utun_ctl_disconnect - ifnet_detach failed: %d\n"
        }
        symbol = "utun_ctl_disconnect"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "utun_ctl_send"
            "%s - unexpected short mbuf pkt len %d\n"
            "%s - ifnet_input failed: %d\n"
        }
        symbol = "utun_ctl_send"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "utun_ncd"
            "utun_enable_channel"
            "uuid_is_null(pcb->utun_kpipe_uuid)"
            "%s: kern_nexus_controller_create failed: %d\n"
            "%s: kern_nexus_get_default_domain_provider failed: %d\n"
            "%s: kern_nexus_controller_register_provider failed: %d\n"
        }
        symbol = "utun_enable_channel"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "pcb->utun_kpipe_rxring == NULL"
            "pcb->utun_kpipe_txring == NULL"
        }
        symbol = "utun_kpipe_ring_init"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "utun_kpipe_sync_tx"
        }
        symbol = "utun_kpipe_sync_tx"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "utun_kpipe_sync_rx"
            "tx_baddr != NULL"
            "mb_cnt <= avail"
            "mb_cnt == 0"
            "utun_kpipe_sync_rx %s: failed to allocate packet\n"
            "utun_kpipe_sync_rx %s: invalid length %zu header_size %zu\n"
            "utun_kpipe_sync_rx %s: unknown ip version %u vhl %u header_size %zu\n"
            "utun_kpipe_sync_rx: ifnet_enable_output returned error %d\n"
        }
        symbol = "utun_kpipe_sync_rx"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "uuid_is_null(pcb->utun_kpipe_uuid) == !enabled"
        }
        symbol = "utun_disable_channel"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "com.apple.net.ipsec_control"
            "ipsec_register_nexus"
            "ipsec_register_control - ctl_register failed: %d\n"
            "ipsec_register_control - proto_register_plumber(PF_INET, IFNET_FAMILY_IPSEC) failed: %d\n"
            "ipsec_register_control - proto_register_plumber(PF_INET6, IFNET_FAMILY_IPSEC) failed: %d\n"
        }
        symbol = "ipsec_register_control"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "ipsec_inject_inbound_packet"
        }
        symbol = "ipsec_inject_inbound_packet"
        caller = "?"
    }
    new {
        args = 3
        anchors {
            "ipsec%d"
            "ipsecid%d"
            "%s: %s%d use_netif %d kpipe_count %d slot_size %u ring_size %u kpipe_tx_ring_size %u kpipe_rx_ring_size %u\n"
            "!ipsec_flag_isset(pcb, IPSEC_FLAGS_KPIPE_ALLOCATED)"
            "ipsec_ncd"
            "ipsec_nexus_ifattach"
            "ipsec_flowswitch_attach - ifnet_detach failed: %d @%s:%d"
            "ipsec_ctl_connect: creating interface %s (id %s)\n"
            "ipsec_ctl_connect - kpipe requires netif: failed %d\n"
            "%s: %s failed to enable channels\n"
            "ipsec_ctl_connect - ipsec_nexus_ifattach failed: %d\n"
            "ipsec_ctl_connect - ipsec_flowswitch_attach failed: %d\n"
            "ipsec_ctl_connect - ifnet_allocate failed: %d\n"
            "ipsec_ctl_connect - ifnet_attach failed: %d\n"
            "%s: %s failed to register kernel pipe nexus\n"
            "%s: %s pbufbool create failed, error %d\n"
            "%s: %s enabling wmm mode\n"
            "ipsec_flowswitch_attach - flowswitch is NULL\n"
            "ipsec_flowswitch_attach - unable to find flowswitch nexus\n"
        }
        symbol = "ipsec_ctl_connect"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "pcb->ipsec_kpipe_count != 0"
        }
        symbol = "_ipsec_nexus_pre_disconnect"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "ipsec_data_move_drain"
            "pcb->ipsec_pcb_drainers > 0"
        }
        symbol = "ipsec_wait_data_move_drain"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "ipsec_kpipe_ring_init"
            "pcb->ipsec_kpipe_rxring[ring_idx] == NULL"
            "pcb->ipsec_kpipe_txring[ring_idx] == NULL"
            "%s: %s cannot find channel %s\n"
        }
        symbol = "ipsec_kpipe_ring_init"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "ipsec_kpipe_sync_tx"
        }
        symbol = "ipsec_kpipe_sync_tx"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "ring_idx <= pcb->ipsec_kpipe_count"
            "interface != NULL"
            "dph != 0"
            "%s: %s ring %s index %d no room in rx_ring\n"
            "%s: %s ring %s index %d bad netif_txring 1\n"
            "%s: %s ring %s index %d bad netif_txring 2\n"
            "ipsec_kpipe_sync_rx %s: failed to allocate packet\n"
            "ipsec_kpipe_sync_rx %s: packet length %zu"
            "ipsec_kpipe_sync_rx %s: failed to encrypt packet"
            "ipsec_kpipe_sync_rx: ifnet_enable_output returned error %d\n"
            "ipsec encrypt kpipe pkt: source buffer shorter than ip header, %u\n"
            "ipsec4 interface kpipe output error %d\n"
            "ipsec6 interface kpipe output error %d\n"
            "received unknown packet version: %d\n"
        }
        symbol = "ipsec_kpipe_sync_rx"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "pcb->ipsec_netif_rxring[0] == NULL"
            "pcb->ipsec_netif_txring[ring_idx] == NULL"
        }
        symbol = "ipsec_netif_ring_init"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "!found"
        }
        symbol = "ipsec_netif_ring_fini"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "ipsec_netif_sync_tx"
            "ring_idx < IPSEC_IF_MAX_RING_COUNT"
            "ipsec_netif_sync_tx %s - failed policy check\n"
            "ipsec_netif_sync_tx %s - ipsec_output error %d\n"
            "ipsec_netif_sync_tx %s - mbuf_copyback(%zu) error %d\n"
            "ipsec_netif_sync_tx %s - mbuf_gethdr error %d\n"
            "ipsec_netif_sync_tx %s - 0 length packet\n"
            "ipsec_netif_sync_tx %s: no encrypted packet to send\n"
        }
        symbol = "ipsec_netif_sync_tx"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "ipsec_netif_sync_rx"
            "fragment_chain != fragment_chain->m_nextpkt"
            "netif_ph != 0"
            "kpipe_buf != NULL"
            "netif_buf != NULL"
            "ipsec_netif_sync_rx %s: legacy decrypted packet length cannot hold IP %zu < %zu\n"
            "ipsec_netif_sync_rx %s: legacy unknown ip version %u\n"
            "ipsec_netif_sync_rx %s: failed to fragment IPv4 packet of length %zu (%d)\n"
            "ipsec_netif_sync_rx %s: failed to fragment IPv6 packet of length %zu < %zu\n"
            "ipsec_netif_sync_rx %s: failed to fragment IPv6 packet of length %zu (%d)\n"
            "ipsec_netif_sync_rx %s: uknown legacy decrypted packet length %zu > %u\n"
            "ipsec_transform_kpipe_pkt_to_netif_pkt %s: kpipe buffer length %u > pcb ipsec slot size %u"
            "ipsec_transform_kpipe_pkt_to_netif_pkt %s - bad packet length %u\n"
            "ipsec_transform_kpipe_pkt_to_netif_pkt %s - bad ip version %u\n"
            "ipsec_transform_kpipe_pkt_to_netif_pkt %s - netif buffer length %u too short\n"
            "ipsec_transform_kpipe_pkt_to_netif_pkt %s: wake packet flag is set\n"
        }
        symbol = "ipsec_netif_sync_rx"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "ipsec_netif_tx_doorbell"
        }
        symbol = "ipsec_netif_tx_doorbell"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "(flags & KERN_NEXUS_TXDOORBELLF_ASYNC_REFILL) == 0"
            "%s: %s ring %s tx refill failed %d\n"
            "%s: %s ring %s index %d bad netif_txring 3\n"
            "ipsec_netif_tx_doorbell: ifnet_disable_output returned error %d\n"
        }
        symbol = "ipsec_netif_tx_doorbell_one"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "ipsec_nexus_detach"
        }
        symbol = "ipsec_nexus_detach"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "ipsec_ctl_disconnect: detaching interface %s (id %s)\n"
            "ipsec_ctl_disconnect - ifnet_detach failed: %d @%s:%d"
            "dc->count >= 0"
            "dc->count <= IPSEC_IF_MAX_RING_COUNT"
            "!uuid_is_null(pcb->ipsec_kpipe_uuid[i])"
            "pcb->ipsec_kpipe_pp"
            "!pcb->ipsec_kpipe_pp"
            "ipsec_ctl_disconnect - ifnet_detach failed: %d\n"
        }
        symbol = "ipsec_ctl_disconnect"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "!result"
            "dc->pp"
        }
        symbol = "ipsec_free_channels"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: IPSEC_OPT_SLOT_SIZE %u\n"
            "%s: IPSEC_OPT_NETIF_RING_SIZE %u\n"
            "%s: IPSEC_OPT_TX_FSW_RING_SIZE %u\n"
            "%s: IPSEC_OPT_KPIPE_TX_RING_SIZE %u\n"
            "%s: IPSEC_OPT_KPIPE_RX_RING_SIZE %u\n"
            "%s IPSEC_OPT_SET_DELEGATE_INTERFACE %s to %s\n"
            "%s IPSEC_OPT_OUTPUT_TRAFFIC_CLASS %s svc %d\n"
            "%s IPSEC_OPT_OUTPUT_DSCP_MAPPING %s DSCP %d\n"
        }
        symbol = "ipsec_ctl_setopt"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Only platform-signed binaries can open NECP sessions"
            "Process does not hold necessary entitlement to open NECP session"
            "necp_create_session"
            "%s: Created NECP session, control unit %d\n"
        }
        symbol = "necp_session_open"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "com.apple.xnu.net.necp"
            "necp-data-trace"
        }
        symbol = "necp_init"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "euuid"
            "RESULT - Loopback PASS <NO MATCH>"
            "RESULT - DROP <NO CLIENT / MULTICAST>"
            "%s: Invalid TLV length (%u)\n"
            "%s: %s(%d) does not hold the necessary entitlement to delegate network traffic for other processes by %s\n"
            "%s: DATA-TRACE <%s>: %s - fam %d proto %d port <local %d/%d remote %d/%d> <local %s remote %s> <drop-all order %d> <pid=%d Application %d Real Application %d BoundInterface %d> <policy_id %d skip_policy_id %d>\n"
        }
        symbol = "necp_application_find_policy_match_internal"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "RESULT - Loopback PASS"
            "RESULT - Inactive Agent DROP"
            "socket unscoped for PASS result"
            "FLOW DIVERT <ROUTE RULE>"
            "socket unscoped for <NO MATCH>"
            "RESULT - DROP <MISSING CLIENT>"
            "%s: DATA-TRACE <%s %llx>: %s - fam %d proto %d port <local %d/%d remote %d/%d> <local %s remote %s> <drop-all order %d> <pid=%d Application %d Real Application %d BoundInterface %d> <policy_id %d skip_policy_id %d result %d>\n"
            "%s: DATA-TRACE: Socket Policy - INP UPDATE - RESULT - CACHED <MATCHED>: %p (BoundInterface %d Proto %d) Policy %d Result %d Parameter %d\n"
            "%s: DATA-TRACE: Socket Policy: <so %llx> (BoundInterface %d Proto %d) Dropping packet because agent is not active\n"
            "%s: Marking socket in state %d as defunct\n"
            "%s: DATA-TRACE: Socket Policy: <so %llx> (BoundInterface %d Proto %d) Policy %d Skip %d Result %d Parameter %d Filter %d\n"
        }
        symbol = "necp_socket_find_policy_match"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "necp_mark_packet_from_socket"
            "START - MARK PACKET"
            "RESULT - MARK PACKET"
            "%s: DATA-TRACE <%s %llx>: %s - <policy_id %d skip_policy_id %d> <cached policy_id %d skip_policy_id %d>\n"
        }
        symbol = "necp_mark_packet_from_socket"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "necp_policy_apply_all"
            "Applied NECP policies"
            "necp_policy_delete"
            "Removed NECP policy"
            "NECP Application Policies:\n"
            "NECP Socket Policies:\n"
            "necp_kernel_ip_output_policies_dump_all"
            "NECP IP Output Policies:\n"
            "%s: \t%3d. Policy ID: %5d\tProcess: %10.10s\tOrder: %04d.%04d\tMask: %llx\tResult: %s\n\n"
            "%s: \tApp Bucket: %d\n\n"
            "%s:  ID Bucket: %d\n\n"
            "%s: \t%3d. Policy ID: %5d\tProcess: %10.10s\tOrder: %04d.%04d.%d\tMask: %llx\tResult: %s\n\n"
        }
        symbol = "necp_policy_apply_all"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Error applying socket kernel policy"
            "necp_get_new_string_id"
            "Failed to find a free route rule id.\n"
            "Allocate route rule ID failed.\n"
            "necp_kernel_socket_policy_add"
            "Failed to find a free socket kernel policy ID.\n"
            "%s: Added kernel policy: socket, id=%d, mask=%llx\n\n"
        }
        symbol = "necp_policy_apply"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Failed to find a free service UUID.\n"
            "Allocate uuid ID failed.\n"
        }
        symbol = "necp_get_new_uuid_id"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Failed to find a free aggregate route rule id.\n"
        }
        symbol = "necp_create_aggregate_route_rule"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Failed to find a free IP kernel policy ID.\n"
            "necp_kernel_ip_output_policy_add"
            "%s: Added kernel policy: ip output, id=%d, mask=%llx\n\n"
        }
        symbol = "necp_kernel_ip_output_policy_add"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "Pass (%X)"
            "Skip (%u)"
            "Drop (%X)"
            "SocketDivert (%d)"
            "SocketFilter (%d)"
            "IPTunnel (%s%d)"
            "IPFilter"
            "SocketScoped (%s%d)"
            "ScopedDirect"
            "AllowUnentitled"
            "RouteRules (Only %s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s)"
            "RouteRules (%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s)"
            "!Cell "
            "!WiFi "
            "!Wired "
            "!Exp "
            "!Constrained "
            "!Companion "
            "!VPN "
            "RouteRules (QoSMarking %s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s)"
            "RouteRules (Unknown)"
            "UseNetAgent (%s)"
            "NetAgentScoped (%s)"
            "RemoveNetAgent (%s)"
            "Unknown %d (%d)"
        }
        symbol = "necp_get_result_description"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "necp_delete_session"
            "Deleted NECP session"
        }
        symbol = "necp_session_op_close"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Failed to validate policy result"
            "Route rules size overflowed, too large"
            "Failed to get policy route rules"
            "Failed to validate policy route rule"
            "Failed to validate route rule; contained multiple default route rules"
            "Conditions size overflowed, too large"
            "Failed to get policy conditions"
            "Failed to validate policy condition"
            "Failed to validate conditions; contained default and non-default conditions"
            "Failed to validate conditions; did not contain application condition"
            "Failed to validate conditions; kernel pid (0) condition allows only Pass/Skip result"
            "%s: necp_session_add_policy invalid input (%zu)\n"
            "%s: necp_session_add_policy invalid output buffer (%zu)\n"
            "%s: necp_session_add_policy tlv copyin error (%d)\n"
            "%s: necp_session_add_policy failed to add policy (%d)\n"
            "%s: necp_session_add_policy policy_id copyout error (%d)\n"
            "%s: Failed to get policy order: %d\n"
            "%s: Failed to find policy result TLV: %d\n"
            "%s: Failed to get policy result length: %d\n"
            "%s: Policy result length too large: %u\n"
            "%s: Failed to allocate a policy result buffer (size %d)\n"
            "%s: Failed to get policy result: %d\n"
            "%s: Route rules length too large: %u\n"
            "%s: Failed to allocate a policy route rules array (size %d)\n"
            "%s: Conditions length too large: %u\n"
            "%s: Failed to allocate a policy conditions array (size %d)\n"
        }
        symbol = "necp_session_add_policy"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "necp_get_tlv_at_offset buffer is NULL"
            "necp_get_tlv_at_offset tlv_value is NULL"
            "%s: necp_get_tlv_at_offset buffer_length is too small for TLV (%u < %lu)\n"
            "%s: necp_get_tlv_at_offset buffer_length is too small for TLV of length %u (%u < %lu)\n"
            "%s: necp_get_tlv_at_offset out_buffer_length is too small for TLV value (%u < %u)\n"
        }
        symbol = "necp_get_tlv_at_offset"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "necp_policy_result_is_valid"
            "%s: Policy result type %d, valid %d\n"
        }
        symbol = "necp_policy_result_is_valid"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "necp_policy_route_rule_is_valid"
            "%s: Policy route rule type %d, valid %d\n"
        }
        symbol = "necp_policy_route_rule_is_valid"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "necp_policy_condition_is_valid"
            "%s: Policy condition type %d, valid %d\n"
        }
        symbol = "necp_policy_condition_is_valid"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "necp_policy_create"
            "%s: Created NECP policy, order %d\n"
        }
        symbol = "necp_policy_create"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "necp_session_dump_all"
            "Session does not hold the necessary entitlement to get Network Extension Policy information"
            "Gathering policies"
            "%s: necp_session_dump_all invalid output buffer (%zu)\n"
            "%s: Failed to allocate tlv_buffer_pointers (%lu bytes)\n"
            "%s: Failed to allocate tlv_buffer_lengths (%lu bytes)\n"
            "%s: Policy: process: %s, result: %s\n"
            "%s: Failed to allocate tlv_buffer (%u bytes)\n"
            "%s: Failed to allocate cond_buffer (%u bytes)\n"
            "%s: out_buffer_length too small (%lu < %lu)\n"
            "%s: Failed to allocate result_buffer (%lu bytes)\n"
            "%s: Failed to copy out result_buffer (%lu bytes)\n"
        }
        symbol = "necp_session_dump_all"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "necp_get_new_domain_filter_id"
            "Failed to find a free filter ID.\n"
        }
        symbol = "necp_create_domain_filter"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "com.apple.configd"
            "com.apple.private.necp.drop_all_bypass"
        }
        symbol = "necp_check_drop_all_bypass_result"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "com.apple.developer.networking.multicast"
            "necp_check_restricted_multicast_drop"
            "%s: Dropping unentitled multicast (SDK 0x%x, min 0x%x)\n"
        }
        symbol = "necp_check_restricted_multicast_drop"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "RESULT - DROP - (session order > drop-all order)"
            "SKIP (cleared saved skip)"
            "Scope"
            "NECP_KERNEL_CONDITION_APP_ID"
            "NECP_KERNEL_CONDITION_SIGNING_IDENTIFIER"
            "<n/a>"
            "NECP_KERNEL_CONDITION_REAL_APP_ID"
            "NECP_KERNEL_CONDITION_PLATFORM_BINARY"
            "NECP_KERNEL_CONDITION_EXACT_DOMAIN"
            "NECP_KERNEL_CONDITION_DOMAIN"
            "NECP_KERNEL_CONDITION_URL"
            "NECP_KERNEL_CONDITION_ACCOUNT_ID"
            "NECP_KERNEL_CONDITION_PID"
            "NECP_KERNEL_CONDITION_UID"
            "NECP_KERNEL_CONDITION_REAL_UID"
            "NECP_KERNEL_CONDITION_TRAFFIC_CLASS"
            "NECP_KERNEL_CONDITION_AGENT_TYPE"
            "NECP_KERNEL_CONDITION_CLIENT_FLAGS"
            "NECP_KERNEL_CONDITION_LOCAL_EMPTY"
            "NECP_KERNEL_CONDITION_REMOTE_EMPTY"
            "NECP_KERNEL_CONDITION_IS_LOOPBACK"
            "NECP_KERNEL_CONDITION_DELEGATE_IS_PLATFORM_BINARY"
            "%s: DATA-TRACE <%s %llx>: %s - policy id=%d session_order=%d policy_order=%d result=%s (cond_policy_id %d) (skip_session_order %d skip_order %d)\n"
            "%s: DATA-TRACE <%s %llx>: %s - fam %d proto %d port <local %d/%d remote %d/%d> <local %s remote %s> <drop-all order %d> <pid=%d Application %d Real Application %d BoundInterface %d> (policy id=%d session_order=%d policy_order=%d result=%s)\n"
            "%s: DATA-TRACE: Socket Policy <so %llx>: (Application %d Real Application %d BoundInterface %d Proto %d) Filter %d\n"
            "%s: DATA-TRACE: Socket Policy <so %llx>: (Application %d Real Application %d BoundInterface %d Proto %d) Route Rule %d\n"
            "%s: DATA-TRACE: Socket Policy <so %llx>: (Application %d Real Application %d BoundInterface %d Proto %d) %s Netagent %d\n"
            "%s: DATA-TRACE: Socket Policy <so %llx>: (Application %d Real Application %d BoundInterface %d Proto %d) Remove Netagent %d\n"
            "%s: DATA-TRACE: Socket Policy <so %llx>: (Application %d Real Application %d BoundInterface %d Proto %d) flow divert %u\n"
            "%s: DATA-TRACE: Socket Policy <so %llx>: MATCHED SKIP POLICY (Application %d Real Application %d BoundInterface %d Proto %d) set skip_policy_id %d\n"
            "%s: DATA-TRACE <%s %llx>: ------ %smatching <%s> <value (%d / 0x%X) (%d / 0x%X) (%d / 0x%X) input (%d / 0x%X) (%d / 0x%X) (%d / 0x%X)>\n"
            "%s: DATA-TRACE <%s %llx>: ------ %smatching <%s> <value %s %s %s input %s %s %s>\n"
        }
        symbol = "necp_socket_find_policy_match_with_info_locked"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "necp_socket_verify_netagents"
            "%s: DATA-TRACE: Socket Policy: <so %llx> Triggering inactive agent (%d), error %d\n"
        }
        symbol = "necp_socket_verify_netagents"
        caller = "?"
    }
    new {
        args = 6
        anchors {
            "necp_route_is_allowed"
            "%s: Route Allowed: no route or interface, Rule %d Allowed %d\n"
        }
        symbol = "necp_route_is_allowed"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "START - RESULT - CACHED DROP"
            "START - RESULT - CACHED"
            "RESULT - CACHED <DROP>"
            "RESULT - loopback"
            "RESULT - AGENT INACTIVE"
            "RESULT - DROP - NO MATCH"
            "RESULT - DROP - MULTICAST"
            "%s: DATA-TRACE <%s %llx>: %s - fam %d proto %d port <local %d/%d remote %d/%d> <local %s remote %s> <drop-all order %d> <pid=%d Application %d Real Application %d BoundInterface %d> <policy_id %d skip_policy_id %d result %d> <input ifindex %d> <allowed_to_receive %d><pf_tag %X pass_flags %X>\n"
            "%s: DATA-TRACE: Socket Policy - Send/Recv - RESULT - CACHED <MATCHED>: %p (BoundInterface %d Proto %d) Policy %d Skip %d Result %d Parameter %d\n"
            "%s: DATA-TRACE: Socket Policy - Send/Recv: %p (BoundInterface %d Proto %d) Policy %d Result %d Parameter %d Allowed %d <filter_control_unit %d flow_divert_aggregate_unit %d>\n"
        }
        symbol = "necp_socket_is_allowed_to_send_recv_internal"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "necp_client_assert_bb_radio_manager"
            "Couldn\\'t find client"
            "BB radio manager agent not found"
            "netagent_client_message failed"
        }
        symbol = "necp_client_assert_bb_radio_manager"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "necp_update_all_clients_immediately_if_needed"
            "%s: necp_update_all_clients immediate %s update %u\n"
        }
        symbol = "necp_update_all_clients_immediately_if_needed"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "NULL proc"
            "NULL fp"
            "Could not find client structure for backgrounded client"
            "Not a client fd, ignore"
        }
        symbol = "necp_set_client_as_background"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "Client does not hold necessary entitlement to observe other NECP clients"
        }
        symbol = "necp_open"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "necp_set_socket_attributes"
            "%s: NECP_SOCKET_ATTRIBUTE_LOG: NECP ATTRIBUTES SOCKET - domain <%s> owner <%s> context <%s> tracker domain <%s> account <%s>\n\n"
            "%s: Set on socket: Domain %s, Domain owner %s, Domain context %s, Tracker domain %s, Account %s\n"
        }
        symbol = "necp_set_socket_attributes"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "necp_client_remove_assertion"
            "Netagent uuid not previously asserted"
        }
        symbol = "necp_client_remove_assertion"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "Multiple resolver tags are not supported"
            "Resolver tag invalid client ID"
            "Resolver tag hostname does not match"
            "Resolver tag address type does not match"
            "Resolver tag port does not match"
            "Resolver tag address does not match"
            "Failed to validate resolve answer"
            "necp_client_trace_parsed_parameters"
            "%s: Resolver tag length too short: %u\n"
            "%s: Resolver tag unknown sign type: %u\n"
            "%s: NECP_CLIENT_PARAMS_LOG <pid %d %s>: Parsing param - type %d length %d value <%llu (%llX)> %s\n\n"
            "%s: NECP_CLIENT_PARAMS_LOG <pid %d %s>: Parsing param - type %d length %d\n\n"
            "%s: NECP_CLIENT_PARAMS_LOG <pid %d %s>: Parsed params - valid_fields %X flags %X delegated_upid %llu local_addr %s remote_addr %s required_interface_index %u required_interface_type %d local_address_preference %d ip_protocol %d transport_protocol %d ethertype %d effective_pid %d effective_uuid %s uid %d persona_id %d traffic_class %d\n\n"
            "%s: NECP_CLIENT_PARAMS_LOG <pid %d %s>: Parsed params - tracker flags <known-tracker %X> <non-app-initiated %X> <silent %X> <app-approved %X>\n\n"
            "%s: NECP_CLIENT_PARAMS_LOG <pid %d %s>: Parsed prohibited_interfaces[%d] <%s>\n\n"
        }
        symbol = "necp_client_parse_parameters"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "need_defunct == TRUE"
        }
        symbol = "necp_fd_defunct"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "nai->nai_use_count == 0"
        }
        symbol = "necp_arena_info_free"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "necp_process_defunct_list"
            "%s: necp_update_client abort nexus error (%d) for pid %d %s\n"
        }
        symbol = "necp_process_defunct_list"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "nai->nai_use_count >= 1"
            "nai->nai_flags & NAIF_ATTACHED"
        }
        symbol = "necp_stats_arenas_destroy"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "necp_destroy_client"
            "%s: necp_client_remove unassert agent error (%d)\n"
        }
        symbol = "necp_destroy_client"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "necp_destroy_client_flow_registration"
            "%s: necp_client_remove close nexus error (%d) MESSAGE TYPE %u\n"
        }
        symbol = "necp_destroy_client_flow_registration"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "No channel for kqfilter"
            "%s: bad filter request %d\n"
        }
        symbol = "necpop_kqfilter"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "NECP client observers with push enabled may not add their own clients"
            "necp_client_add, no necp_client_inherit_from_parent as can't find parent on fd_data"
            "necp_client_add, child does not have a demux pattern"
            "necp_client_add, parent ID is null"
            "necp_client_add, multiple parent flows not supported"
            "necp_client_add, parent/child ip protocol mismatch"
            "necp_client_add, local/remote address family mismatch"
            "necp_client_add, parent/child address family mismatch"
            "necp_client_add, parent/child local address mismatch"
            "necp_client_add, parent/child remote address mismatch"
            "necp_client_add, parent/child local port mismatch"
            "necp_client_add, parent/child remote port mismatch"
            "%s: necp_client_add parameters copyin error (%d)\n"
            "%s: NECP_CLIENT_LOG <pid %d %s>: Adding client\n\n"
            "%s: necp_client_add client_id copyout error (%d)\n"
            "%s: %s(%d) does not hold the necessary entitlement to delegate network traffic for other processes by upid\n"
            "%s: %s(%d) does not hold the necessary entitlement to set attributed bundle identifier\n"
            "%s: %s(%d) does not hold the necessary entitlement to open a custom nexus client\n"
            "%s: %s(%d) does not hold the necessary entitlement for custom protocol APIs\n"
            "%s: necp_client_add listener invalid address family (%d)\n"
            "%s: necp_client_add netns_reserve_ephemeral error (%d)\n"
            "%s: necp_client_add netns_reserve error (%d)\n"
            "%s: necp_client_add, flow demux pattern not supported for %d protocol\n"
            "%s: necp_client_add, flow demux pattern not supported for %d family\n"
        }
        symbol = "necp_client_add"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "necp_client_update_local_port_parameters"
        }
        symbol = "necp_client_update_local_port_parameters"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "parameters != NULL"
        }
        symbol = "necp_client_copy_parameters_locked"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "necp_find_conn_netstat_data"
        }
        symbol = "necp_find_conn_netstat_data"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "necp_client_claim cannot claim from flow UUID"
            "%s: necp_client_claim copyin client_id error (%d)\n"
            "%s: NECP_CLIENT_LOG <pid %d %s>: Claiming client\n\n"
        }
        symbol = "necp_client_claim"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "necp_client_remove ntstat shutdown finds nstat_context NULL"
            "%s: necp_client_remove copyin client_id error (%d)\n"
            "%s: necp_client_remove flow_ifnet_stats copyin error (%d)\n"
            "%s: necp_client_remove unexpected parameters length (%zu)\n"
            "%s: NECP_CLIENT_LOG <pid %d %s>: Removing client\n\n"
            "%s: necp_client_remove invalid client_id (%d)\n"
        }
        symbol = "necp_client_remove"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "necp_client_check_tcp_heuristics"
            "%s: necp_client_parse_parameters error (%d)\n"
        }
        symbol = "necp_client_check_tcp_heuristics"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Client does not hold necessary entitlement to list other NECP clients"
            "%s: necp_client_list buffer copyout error (%d)\n"
            "%s: necp_client_list client count copyout error (%d)\n"
        }
        symbol = "necp_client_list"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Requested nexus not found"
            "%s: necp_client_add_flow invalid client_id (length %zu)\n"
            "%s: necp_client_add_flow invalid buffer (length %zu)\n"
            "%s: necp_client_add_flow copyin client_id error (%d)\n"
            "%s: necp_client_add_flow copyin default_add_request error (%d)\n"
            "%s: necp_client_add_flow process not found for pid %d error (%d)\n"
            "%s: NECP CLIENT FLOW TRACE <pid %d %s> <flow %s>: adding flow\n\n"
            "%s: netagent_client_message error (%d)\n"
            "%s: NECP CLIENT FLOW TRACE <pid %d %s> <flow %s>: Initializing stats\n\n"
            "%s: necp_client_add_flow copyout add_request error (%d)\n"
            "%s: Add flow error (%d)\n"
        }
        symbol = "necp_client_add_flow"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "stats-%u.%s.%d"
            "!(nai->nai_flags & NAIF_ATTACHED)"
            "%s: failed to create stats arena for pid %d\n\n"
            "%s: failed to map stats arena for pid %d\n\n"
        }
        symbol = "necp_arena_initialize"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "fd_data->stats_arena_active != NULL"
            "fd_data->stats_arena_active->nai_arena != NULL"
            "!(fd_data->stats_arena_active->nai_flags & (NAIF_REDIRECT | NAIF_DEFUNCT))"
            "necp_stats_initialize"
            "necp_find_netstat_initial_properties"
            "%s: NECP CLIENT FLOW TRACE <pid %d %s> <flow %s>: Initialized stats <error %d>\n\n"
        }
        symbol = "necp_stats_initialize"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "necp_find_netstat_data"
        }
        symbol = "necp_find_netstat_data"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "necp_client_remove_flow"
            "%s: necp_client_remove_flow invalid client_id (length %zu)\n"
            "%s: necp_client_remove_flow copyin client_id error (%d)\n"
            "%s: NECP CLIENT FLOW TRACE <pid %d %s> <flow %s>: removing flow\n\n"
            "%s: Remove flow error (%d)\n"
        }
        symbol = "necp_client_remove_flow"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "necp_client_agent_action invalid parameters"
            "Invalid TLV value"
            "%s: necp_client_agent_action copyin client_id error (%d)\n"
            "%s: necp_client_agent_action invalid buffer size (>%u)\n"
            "%s: necp_client_agent_action parameters copyin error (%d)\n"
        }
        symbol = "necp_client_agent_action"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "necp_client_copy_interface bad input"
            "%s: necp_client_copy_interface copyin interface_index error (%d)\n"
            "%s: necp_client_copy_interface bad interface_index (%d)\n"
            "%s: necp_client_copy_interface copyout error (%d)\n"
        }
        symbol = "necp_client_copy_interface"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "necp_client_get_interface_address bad input"
            "necp_client_get_interface_address no matching interface found"
            "necp_client_get_interface_address route lookup failed"
            "%s: necp_client_get_interface_address copyin interface_index error (%d)\n"
            "%s: necp_client_get_interface_address bad interface_index (%d)\n"
            "%s: necp_client_get_interface_address copyin address error (%d)\n"
            "%s: necp_client_get_interface_address invalid address family (%u)\n"
            "%s: necp_client_get_interface_address invalid address length (%u)\n"
            "%s: necp_client_get_interface_address local address selection failed (%d)\n"
            "%s: necp_client_get_interface_address local address too long for buffer (%u)\n"
            "%s: necp_client_get_interface_address copyout error (%d)\n"
        }
        symbol = "necp_client_get_interface_address"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "sysctl.%s.%d"
            "%s: failed to create arena for pid %d\n\n"
            "%s: failed to map sysctl arena for pid %d\n\n"
        }
        symbol = "necp_client_map_sysctls"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "necp_client_copy_route_statistics bad input"
            "%s: necp_client_copy_route_statistics copyin client_id error (%d)\n"
            "%s: necp_client_copy_route_statistics copyout error (%d)\n"
        }
        symbol = "necp_client_copy_route_statistics"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "NECP fd is not observer, cannot copy client update"
            "Client id invalid, cannot copy client update"
            "Buffer invalid, cannot copy client update"
            "fd_data->update_count > 0"
            "%s: Copy client update copyout client id error (%d)\n"
            "%s: Buffer size cannot hold update (%zu < %zu)\n"
            "%s: Copy client update copyout error (%d)\n"
        }
        symbol = "necp_client_copy_client_update"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Process does not hold the necessary entitlement to sign resolver answers"
            "%s: necp_client_sign allocate signable %zu failed\n"
            "%s: necp_client_sign copyin signable error (%d)\n"
            "%s: necp_client_sign unknown signable type (%u)\n"
            "%s: necp_client_sign unexpected tag size %zu\n"
            "%s: necp_client_sign copyout error (%d)\n"
        }
        symbol = "necp_client_sign"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Process does not hold the necessary entitlement to directly validate resolver answers"
            "%s: necp_client_validate allocate struct %zu failed\n"
            "%s: necp_client_validate copyin error (%d)\n"
        }
        symbol = "necp_client_validate"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "necp_client_get_signed_client_id bad input"
            "%s: necp_client_get_signed_client_id copyin request_type error (%d)\n"
            "%s: necp_client_get_signed_client_id bad request_type (%d)\n"
            "%s: necp_client_get_signed_client_id unexpected tag size %zu\n"
            "%s: necp_client_get_signed_client_id copyout error (%d)\n"
        }
        symbol = "necp_client_get_signed_client_id"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "necp_client_set_signed_client_id client lacks the necessary entitlement"
            "necp_client_set_signed_client_id bad input"
            "%s: necp_client_set_signed_client_id copyin request_type error (%d)\n"
            "%s: necp_client_set_signed_client_id bad request_type (%d)\n"
            "%s: necp_client_set_signed_client_id copyin request error (%d)\n"
            "%s: necp_client_set_signed_client_id signature validation failed (%d)\n"
        }
        symbol = "necp_client_set_signed_client_id"
        caller = "?"
    }
    new {
        args = 3
        anchors {
            "Failed to get socket attribute"
            "%s: Failed to allocate a socket attribute buffer (size %zu)\n"
        }
        symbol = "necp_set_socket_attribute"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "necp_update_all_clients_callout"
            "%s: necp_update_all_clients_callout running for coalesced %u updates\n"
        }
        symbol = "necp_update_all_clients_callout"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Cannot register agent on NULL session"
            "Cannot register NULL agent"
            "%s: Register message size could not be read, data_size %zu\n"
        }
        symbol = "netagent_register"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "netagent_unregister"
            "Cannot unregister NULL session"
            "FlowSwitch"
        }
        symbol = "fsw_netagent_register"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "netagent_post_updated_interfaces"
            "Interface event with no associated agent"
        }
        symbol = "netagent_post_updated_interfaces"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "netagent_ioctl"
            "Client does not hold the necessary entitlement to get netagent information"
        }
        symbol = "netagent_ioctl"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "netagent_get_flags"
            "Flags requested for invalid netagent"
        }
        symbol = "netagent_get_flags"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "netagent_set_flags"
            "Attempt to set flags for invalid netagent"
        }
        symbol = "netagent_set_flags"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "netagent_get_generation"
            "Generation requested for invalid netagent"
        }
        symbol = "netagent_get_generation"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Type requested for invalid netagent"
            "%s: Invalid arguments for netagent_get_agent_domain_and_type %p %p\n"
        }
        symbol = "netagent_get_agent_domain_and_type"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Requested netagent for kernel trigger could not be found"
            "Requested netagent for kernel trigger is not kernel activated"
            "Requested netagent for kernel trigger is already active"
            "%s: Triggered netagent from kernel (error %d)\n"
        }
        symbol = "netagent_kernel_trigger"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Requested netagent for nexus instance is not a nexus provider"
            "Requested netagent for nexus instance is not active"
            "Requested netagent for group operation is not a group provider"
            "Requested netagent for group operation is not active"
            "assigned_results == NULL || *assigned_results == NULL"
            "assigned_results_length == NULL || *assigned_results_length == 0"
            "Failed to allocate client for trigger"
            "netagent_send_error_message"
            "netagent_send_group_message"
            "netagent_send_client_message"
            "%s: Client netagent message type (%d) is invalid\n"
            "%s: Send message %d for client (error %d)\n"
            "%s: Triggered network agent %s, error = %d\n"
            "%s: Failed to send client message %d on control unit %d\n"
            "%s: Failed to send client group message %d on control unit %d\n"
        }
        symbol = "netagent_client_message_with_params"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "netagent_use"
            "netagent_assert: Requested netagent UUID is not registered"
        }
        symbol = "netagent_use"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Network agent for request UUID could not be found"
            "Network agent does not have any tokens"
            "%s: Copied token content (error %d)\n"
        }
        symbol = "netagent_acquire_token"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "uap == NULL"
            "Requested netagent UUID is empty"
            "Requested netagent UUID is not registered"
            "Requested netagent UUID is not eligible for triggering"
            "Requested netagent UUID is already active"
            "%s: Incorrect length (got %zu, expected %lu)\n"
            "%s: copyin error (%d)\n"
            "%s: Triggered netagent (error %d)\n"
        }
        symbol = "netagent_trigger"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "Got a NULL session"
            "NETAGENT_MESSAGE_TYPE_GET no longer supported"
            "NETAGENT_MESSAGE_TYPE_ASSERT no longer supported"
            "NETAGENT_MESSAGE_TYPE_UNASSERT no longer supported"
            "%s: Got a bad packet, length (%lu) < sizeof header (%lu)\n"
            "%s: mbuf_copydata failed for the header: %d\n"
            "%s: Received unknown message type %d\n"
        }
        symbol = "netagent_ctl_send"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "netagent_send_success_response"
        }
        symbol = "netagent_send_success_response"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "netagent_send_error_response"
        }
        symbol = "netagent_send_error_response"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "Request for registration"
            "Request for update"
            "Request for unregistration"
            "Request for assigning nexus"
            "Request for assigning group members"
            "Request to set use count"
            "Request to add a token"
            "Request to flush tokens"
            "Request to set token low water mark"
            "Request to reset client error"
            "Group assign message is too short"
            "Agent assigned group members to client"
            "No token received"
            "Session cannot add more tokens"
            "netagent_handle_flush_tokens_setopt"
            "netagent_handle_reset_client_error_setopt"
            "%s: Mismatch between data size and payload length (%lu != %zu)\n"
            "%s: Update message size (%zu > %u) too large\n"
            "%s: Failed to allocate group assign message (%lu bytes)\n"
            "%s: Client group assignment failed: %d\n"
            "%s: Payload length is invalid (%lu)\n"
            "%s: Token length is invalid (%lu)\n"
            "%s: Buffer length is invalid (%lu)\n"
        }
        symbol = "netagent_ctl_setopt"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Request to get use count"
            "Request to get token count"
            "Request to get token low water mark"
        }
        symbol = "netagent_ctl_getopt"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "netagent_unregister_session_wrapper"
            "Unregistered agent"
        }
        symbol = "netagent_unregister_session_wrapper"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Invalid argument: agent_changed"
            "Basic agent parameters do not match, cannot update"
            "Updated agent (no changes)"
            "Updated agent"
        }
        symbol = "netagent_handle_update_inner"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "netagent_send_trigger"
            "%s: Failed to send trigger message on control unit %d\n"
        }
        symbol = "netagent_send_trigger"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "netagent_send_tokens_needed"
            "%s: Failed to send client tokens needed message on control unit %d\n"
        }
        symbol = "netagent_send_tokens_needed"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: unit (%d) exceeds max (%d) @%s:%d"
            "if_pflog.c"
            "%s: ifnet_allocate failed - %d\n"
            "%s: ifnet_attach failed - %d\n"
        }
        symbol = "pflog_clone_create"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "pflogoutput"
        }
        symbol = "pflogoutput"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "pflogdemux"
        }
        symbol = "pflogdemux"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s synthesized  %s\n"
            "nat464_synthesize_ipv6"
        }
        symbol = "nat464_synthesize_ipv6"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "prefix_len < sizeof(prefix)"
            "%s desynthesized to %s\n"
            "nat464_synthesize_ipv4"
        }
        symbol = "nat464_synthesize_ipv4"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s translated to IPv4 (inner) ip_len: %#x ip_p: %d ip_sum: %#x ip_src: %s ip_dst: %s \n"
            "%s translated to IPv6 (inner) ip6_plen: %#x ip6_nxt: %d ip6_src: %s ip6_dst: %s \n"
        }
        symbol = "nat464_translate_icmp_ip"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s translated to IPv4 ip_len: %#x ip_p: %d ip_sum: %#x ip_src: %s ip_dst: %s \n"
            "nat464_translate_64"
        }
        symbol = "nat464_translate_64"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s translated to IPv6 ip6_plen: %#x  ip6_nxt: %d ip6_src: %s ip6_dst: %s \n"
            "nat464_translate_46"
        }
        symbol = "nat464_translate_46"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "af == PF_INET || af == PF_INET6"
            "IN_ARE_ADDR_EQUAL(&odst->natv4addr, &iph2->ip_src)"
            "%s translated to ICMPV6 type: %d code: %d checksum: %#x \n"
            "%s translated to ICMP type: %d code: %d checksum: %#x \n"
            "FALSE"
        }
        symbol = "nat464_translate_proto"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "in6_clat46_event_enqueue_nwk_wq_entry"
            "IN6_CLAT46_EVENT_V4_FLOW"
            "IN6_CLAT46_EVENT_V6_ADDR_CONFFAIL"
            "UNKNOWN_IN6_CLAT46_EVHDLR_CODE"
            "%s: eventhandler enqueuing event of type=in6_clat46_event event_code=%s"
        }
        symbol = "in6_clat46_event_enqueue_nwk_wq_entry"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "pf_find_state_all @%s:%d"
        }
        symbol = "pf_find_state_all"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "pf: src_tree insert failed: "
        }
        symbol = "pf_insert_src_node"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "s->state_key != NULL"
            "tree_lan_ext"
            "tree_ext_gwy"
            "pf: state insert failed: id: %016llx creatorid: %08x"
            "pf_status.states != 0"
        }
        symbol = "pf_insert_state"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "pf_purge"
        }
        symbol = "pf_purge_thread_fn"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "state->timeout != PFTM_UNLINKED"
            "state->timeout < PFTM_MAX"
        }
        symbol = "pf_state_expires"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "s->src_node->conn > 0"
            "s->src_node->states > 0"
            "s->nat_src_node->states > 0"
        }
        symbol = "pf_src_tree_remove_state"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "cur->timeout == PFTM_UNLINKED"
            "cur->rule.ptr->states > 0"
            "cur->nat_rule.ptr->states > 0"
            "cur->anchor.ptr->states > 0"
            "pf_status.states > 0"
        }
        symbol = "pf_free_state"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "GRE%u "
            "ICMP "
            "ICMPV6 "
            " %u:%u"
        }
        symbol = "pf_print_state"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "pf_step_into_anchor: stack overflow\n"
        }
        symbol = "pf_step_into_anchor"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "psk->app_state == NULL"
        }
        symbol = "pf_alloc_state_key"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "pf: pool %s hard limit reached (%d)\n"
        }
        symbol = "pool_get"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "(tag == NULL) || (pftag->pftag_flags & PF_TAG_REASSEMBLED)"
        }
        symbol = "pf_find_fragment_tag"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "pf: state insert failed: %s %s "
            "ICMP4"
            "PROTO=%u"
            " lan: "
            " gwy: "
            " ext_lan: "
        }
        symbol = "pf_stateins_err"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "pf_purge_cont"
        }
        symbol = "pf_purge_thread_cont"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "[%08x]"
        }
        symbol = "pf_print_sk_host"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "invalid address type: %d\n"
        }
        symbol = "pf_addr_wrap_neq"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "pf_send_tcp: not AF_INET or AF_INET6! @%s:%d"
        }
        symbol = "pf_send_tcp"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "pf_test: pf_get_mtag_pbuf returned NULL\n"
            "pf_test: kif == NULL, if_name %s\n"
            "pf: dropping packet with ip options [hlen=%u]\n"
        }
        symbol = "pf_test"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "pf: state reuse "
            "pf: loose state match: "
            " seq=%u (%u) ack=%u len=%u ackskew=%d pkts=%llu:%llu dir=%s,%s\n"
            "pf: BAD state: "
            "\n   seq=%u (%u) ack=%u len=%u ackskew=%d sws=%u dws=%u pkts=%llu:%llu dir=%s,%s\n"
            "pf: State failure on: %c %c %c %c | %c %c\n"
        }
        symbol = "pf_test_state_tcp"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "pf_find_state @%s:%d"
        }
        symbol = "pf_find_state"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "(*state)->src_node->conn != 0"
            "pf_src_connlimit: blocking address "
            ", %u states killed"
        }
        symbol = "pf_src_connlimit"
        caller = "?"
    }
    new {
        args = 5
        anchors {
            "!NETNS_TOKEN_VALID(&nstoken)"
            "s->rule.ptr->states != 0"
            "s->anchor.ptr->states != 0"
            "s->nat_rule.ptr->states != 0"
            "s->src_node->states != 0"
            "s->nat_src_node->states != 0"
            "pf_normalize_tcp_stateful failed on first pkt"
            "pf_tag_packet failed"
        }
        symbol = "pf_test_rule"
        caller = "?"
    }
    new {
        args = 7
        anchors {
            "pf: NAT proxy port allocation (%u-%u) failed\n"
        }
        symbol = "pf_get_translation_aux"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "pf_map_addr: src tracking maps "
            "pf_map_addr: selected address "
        }
        symbol = "pf_map_addr"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "gs->rule.ptr->states != 0"
            "gs->anchor.ptr->states != 0"
            "gs->nat_rule.ptr->states != 0"
            "pf_pptp_handler: bad directional!\n"
            "pf_pptp_handler: failed to spoof call id\n"
            "gs->src_node->states != 0"
            "gs->nat_src_node->states != 0"
            "pf_pptp_handler: error inserting GREv1 state.\n"
        }
        symbol = "pf_pptp_handler"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "pf_calc_mss: not AF_INET or AF_INET6! @%s:%d"
        }
        symbol = "pf_calc_mss"
        caller = "?"
    }
    new {
        args = 3
        anchors {
            "pf: IKE message too small.\n"
            "pf: IKE initiator cookie = 0.\n"
        }
        symbol = "pf_test_state_udp"
        caller = "?"
    }
    new {
        args = 3
        anchors {
            "pf: ICMP error message too short (ip)\n"
            "pf: ICMP error message too short (ip6)\n"
            "pf: ICMPv6 short opt\n"
            "pf: ICMP error message too short (tcp)\n"
            "pf: BAD ICMP %d:%d "
            " state: "
            " seq=%u\n"
            "pf: ICMP error message too short (udp)\n"
            "pf: ICMP error, embedded IKE message too small.\n"
            "pf: ICMP error message too short i(icmp)\n"
            "pf: ICMP error message too short (icmp6)\n"
        }
        symbol = "pf_test_state_icmp"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "pf_route: invalid parameters @%s:%d"
            "pf_route: packet length < sizeof (struct ip)\n"
            "pf_route: TAILQ_EMPTY(&r->rpool.list)\n"
        }
        symbol = "pf_route"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "pf_test6: pf_get_mtag_pbuf returned NULL\n"
            "pf_test6: kif == NULL, if_name %s\n"
            "pf: IPv6 short fragment header\n"
            "pf: IPv6 short opt\n"
            "pf: dropping packet with dangerous v6addr headers\n"
        }
        symbol = "pf_test6"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "pf_route6: m0->m_len < sizeof (struct ip6_hdr)\n"
            "pf_route6: TAILQ_EMPTY(&r->rpool.list)\n"
            "pf_route6:dropped refragmented packet\n"
        }
        symbol = "pf_route6"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "pfiaddrpl"
            "pfi_kif_get for pfi_all failed @%s:%d"
        }
        symbol = "pfi_initialize"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "pfi_kif_unref: rules refcount <= 0\n"
            "pfi_kif_unref: state refcount <= 0\n"
            "pfi_kif_unref with unknown type @%s:%d"
        }
        symbol = "pfi_kif_unref"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "pfi_kif_get failed @%s:%d"
        }
        symbol = "pfi_attach_ifnet"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            ":network"
            ":broadcast"
            ":peer"
        }
        symbol = "pfi_dynaddr_setup"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "pfi_dynaddr_update @%s:%d"
            "pfi_table_update: cannot set %d new addresses into table %s: %d\n"
        }
        symbol = "pfi_kif_update"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "pfi_address_add: address buffer full (%d/%d)\n"
            "pfi_address_add: no memory to grow buffer (%d/%d)\n"
        }
        symbol = "pfi_address_add"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "pfrulepl"
            "pfsrctrpl"
            "pfstatepl"
            "pfstatekeypl"
            "pfappstatepl"
            "pfpooladdrpl"
            "%s: unable to start purge thread!"
            "%s: failed to allocate major number!\n"
            "pfosfpen"
            "pfosfp"
        }
        symbol = "pfinit"
        caller = "?"
    }
    new {
        args = 4
        anchors {
            "*mppn == *mp"
        }
        symbol = "pf_af_hook"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "pfdevcnt > 0"
        }
        symbol = "pfclose"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "pf: unable to generate token\n"
            "pf: enabled refcount decremented\n"
            "pf: token mismatch\n"
            "cmd == DIOCOSFPGET"
            "%s: rule not found! @%s:%d"
            "pf_delete_rule_by_ticket"
            "%s: parent rule of anchor not found! @%s:%d"
            "pf_deleterule_anchor_step_out"
        }
        symbol = "pfioctl"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "pf_is_enabled == 0"
            "pf: started\n"
        }
        symbol = "pf_start"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "generate_token"
            "%s: NR_TOKENS_LIMIT reached"
        }
        symbol = "generate_token"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "pf_is_enabled"
            "pf: stopped\n"
        }
        symbol = "pf_stop"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "pf : remove failure\n"
        }
        symbol = "remove_token"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "pfioctl_ioc_tokens"
            "%s: size overflows"
        }
        symbol = "pfioctl_ioc_tokens"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: rcount value broken! @%s:%d"
            "pf_delete_rule_from_ruleset"
        }
        symbol = "pf_delete_rule_from_ruleset"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "pf_default_rule.states != 0"
        }
        symbol = "pfioctl_ioc_state"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "pffrent"
            "pffrag"
            "pffrcache"
            "pffrcent"
            "pfstscr"
        }
        symbol = "pf_normalize_init"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "BUFFER_FRAGMENTS(frag)"
            "pf_purge_expired_fragments"
            "expiring IPv4 %d(0x%llx) from queue.\n"
            "expiring IPv6 %d(0x%llx) from queue.\n"
            "!BUFFER_FRAGMENTS(frag)"
            "expiring IPv4 %d(0x%llx) from cache.\n"
            "expiring IPv6 %d(0x%llx) from cache.\n"
            "TAILQ_EMPTY(&pf_cachequeue) || TAILQ_LAST(&pf_cachequeue, pf_cachequeue) != frag"
        }
        symbol = "pf_purge_expired_fragments"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "pf_norm.c"
            "pkt too short"
            "refragment error %d"
        }
        symbol = "pf_refragment6"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "IP_DF\n"
            "mff and %d\n"
            "max packet %d\n"
            "reass IPv4 frag %d @ %d-%d\n"
            "dropping bad IPv4 fragment\n"
        }
        symbol = "pf_normalize_ip"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "reass IPv6 frag %d @ %d-%d\n"
            "dropping bad IPv6 fragment\n"
        }
        symbol = "pf_normalize_ip6"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "src->scrub == NULL"
        }
        symbol = "pf_normalize_tcp_init"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "src->scrub || dst->scrub"
            "multiple TS??"
            "src idled out of PAWS\n"
            "dst idled out of PAWS\n"
            "Timestamp failed %c%c%c%c\n"
            " tsval: %u  tsecr: %u  +ticks: %u  idle: %lus %ums\n"
            " src->tsval: %u  tsecr: %u\n"
            " dst->tsval: %u  tsecr: %u  tsval0: %u\n"
            "Did not receive expected RFC1323 timestamp\n"
            "Broken RFC1323 stack did not timestamp data packet. Disabled PAWS security.\n"
        }
        symbol = "pf_normalize_tcp_stateful"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "LIST_EMPTY(&frag->fr_cache) || LIST_FIRST(&frag->fr_cache)->fr_off > frcache->fr_end"
        }
        symbol = "pf_free_fragment"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "complete: 0x%llx(%d)\n"
        }
        symbol = "pf_reassemble"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "pf_flush_fragments"
            "trying to free > %d frents\n"
            "trying to free > %d cache entries\n"
        }
        symbol = "pf_flush_fragments"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "fragcache[%d]: new %d-%d\n"
            "fragcache[%d]: dead (%d-%d) %d-%d\n"
            "fragcache[%d]: adjacent (%d-%d) %d-%d\n"
            "fragcache[%d]: chop %d (%d-%d) %d-%d\n"
            "(int)m->m_len == ntohs(h->ip_len) - precut"
            "fragcache[%d]: gap %d (%d-%d) %d-%d\n"
            "fragcache[%d]: adjacent %d-%d (%d-%d)\n"
            "fragcache[%d]: chop %d %d-%d (%d-%d)\n"
            "(int)m->m_len == ntohs(h->ip_len) - aftercut"
            "fragcache[%d]: gap %d %d-%d (%d-%d)\n"
            "fragcache[%d]: done 0-%d\n"
            "fragcache[%d]: dropping overall fragment\n"
        }
        symbol = "pf_fragcache"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "0x%llx IPv6 frag plen %u off %u fr_ip6f_hlen %u fr_max %u m_len %u\n"
            "frep at %d, next %d, max %d\n"
            "drop: atomic fragment\n"
            "complete: 0x%llx ip6_plen %d m_pkthdr.len %d\n"
        }
        symbol = "pf_reassemble6"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "0x%llx plen %u off %u fr_max %u\n"
            "frag6cache[%d]: new %d-%d\n"
            "frag6cache[%u]: dead (%d-%d) %d-%d\n"
            "frag6cache[%u]: adjacent (%d-%d) %d-%d\n"
            "frag6cache[%u]: chop %d (%d-%d) %d-%d\n"
            "(int)m->m_len == ntohs(h->ip6_plen) - precut"
            "frag6cache[%u]: gap %d (%d-%d) %d-%d\n"
            "frag6cache[%u]: adjacent %d-%d (%d-%d)\n"
            "frag6cache[%u]: chop %d %d-%d (%d-%d)\n"
            "(int)m->m_len == ntohs(h->ip6_plen) - aftercut"
            "frag6cache[%u]: gap %d %d-%d (%d-%d)\n"
            "frag6cache[%u]: done 0-%d\n"
            "frag6cache[%u]: dropping overall fragment\n"
        }
        symbol = "pf_frag6cache"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "fingerprinted %s:%d  %d:%d:%d:%d:%llx (%d) (TS=%s,M=%s%d,W=%s%d)\n"
        }
        symbol = "pf_osfp_fingerprint_hdr"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "osfp no match against %x\n"
            "osfp matched %s %s %s  %x==%x\n"
            "fingerprint 0x%x didn't match\n"
        }
        symbol = "pf_osfp_match"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "adding osfp %s %s %s = %s%d:%d:%d:%s%d:0x%llx %d (TS=%s,M=%s%d,W=%s%d) %x\n"
        }
        symbol = "pf_osfp_add"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "nm->pm_buffer != NULL"
            "nm->pm_buffer_len != 0"
            "nm->pm_len != 0"
            "nm->pm_len <= nm->pm_buffer_len"
            "nm->pm_offset < nm->pm_len"
            "pbuf_sync"
        }
        symbol = "pbuf_sync"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: packet too big for cluster (%u)\n"
            "pbuf_to_mbuf"
        }
        symbol = "pbuf_to_mbuf"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "pbuf_clone_to_mbuf"
        }
        symbol = "pbuf_clone_to_mbuf"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "pbuf_ensure_writable"
        }
        symbol = "pbuf_ensure_writable"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "(u_int)off <= pbuf->pb_packet_len"
            "pbuf->pb_mbuf != NULL"
            "nm->pm_offset + (nm->pm_len + delta_len) <= nm->pm_buffer_len"
            "(nm->pm_len + nm->pm_offset) <= nm->pm_buffer_len"
            "pbuf_csum_flags_get: bad pb_type: %d @%s:%d"
        }
        symbol = "pbuf_resize_segment"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "pbuf_contig_segment"
        }
        symbol = "pbuf_contig_segment"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "(size_t)len <= src_buflen"
            "pbuf_copy_back"
        }
        symbol = "pbuf_copy_back"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "(size_t)len <= dst_buflen"
            "pbuf_copy_data"
        }
        symbol = "pbuf_copy_data"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "pbuf_inet_cksum"
        }
        symbol = "pbuf_inet_cksum"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "pbuf_inet6_cksum"
        }
        symbol = "pbuf_inet6_cksum"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "pf_find_or_create_ruleset: RB_INSERT1 '%s' '%s' collides with '%s' '%s'\n"
            "pf_find_or_create_ruleset: RB_INSERT2 '%s' '%s' collides with '%s' '%s'\n"
        }
        symbol = "pf_find_or_create_ruleset"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "pf_anchor_setup: .. beyond root\n"
            "pf_anchor_setup: ruleset\n"
        }
        symbol = "pf_anchor_setup"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "pf_anchor_copyout: '%s' '%s'\n"
        }
        symbol = "pf_anchor_copyout"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "pf_anchor_remove: broken refcount\n"
        }
        symbol = "pf_rm_rule"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "pfrktable"
            "pfrkentry"
            "pfrkentry2"
        }
        symbol = "pfr_initialize"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "pfr_clr_addrs: corruption detected (%d).\n"
        }
        symbol = "pfr_clr_addrs"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "pfr_get_addrs: corruption detected (%d).\n"
        }
        symbol = "pfr_get_addrs"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "pfr_get_astats: corruption detected (%d).\n"
        }
        symbol = "pfr_get_astats"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "pfr_get_tables: corruption detected (%d).\n"
        }
        symbol = "pfr_get_tables"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "pfr_get_tstats: corruption detected (%d).\n"
        }
        symbol = "pfr_get_tstats"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "pfr_update_stats: assertion failed.\n"
        }
        symbol = "pfr_update_stats"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "pfr_unroute_kentry: delete failed.\n"
        }
        symbol = "pfr_unroute_kentry"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "ke != NULL"
            "/AppleInternal/Library/BuildRoots/d3a62b52-2ef5-11ef-9ecd-e2437461156c/Library/Caches/com.apple.xbs/Sources/xnu/bsd/net/pf_table.c"
        }
        symbol = "pfr_walktree"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "iptap_init"
            "iptap.c"
            "com.apple.network.advisory"
            "pthread kernel extension not loaded (function table is NULL). @%s:%d"
            "Copyright (c) 1982, 1986, 1989, 1991, 1993\n\tThe Regents of the University of California. All rights reserved.\n\n"
            "bsd_init: We have a problem, current task is not kernel task\n"
            "bsd_init: failed to mount network root, error %d, %s\n"
            "We are hanging here...\n"
            "cannot mount root, errno = %d\n"
            "bsd_init: cannot find root vnode: %s @%s:%d"
            "rootvp not authenticated after mounting @%s:%d"
            "trying to find and mount BaseSystem dmg as root volume\n"
            "bsdmgpath"
            "System/Volumes/macOS"
            "bsd_autoconf: calling kminit\n"
            "/usr/standalone/firmware/"
            "arm64eBaseSystem.rooted.dmg"
            "arm64eBaseSystem.dmg"
            "/BaseSystem.rooted.dmg"
            "/BaseSystem.dmg"
            "-bsdmgroot"
            "-nobsdmgroot"
            "com.apple.kauth.process"
            "com.apple.kauth.generic"
            "com.apple.kauth.fileop"
        }
        symbol = "bsd_init"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "iptap_tap_callback"
            "iptap_total_tap_count >= 0"
            "/AppleInternal/Library/BuildRoots/d3a62b52-2ef5-11ef-9ecd-e2437461156c/Library/Caches/com.apple.xbs/Sources/xnu/bsd/net/iptap.c"
        }
        symbol = "iptap_tap_callback"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "iptap_ipf_register"
            "%s: ipf_addv4 for %s0 failed - %d\n"
            "%s: ipf_addv6 for %s0 failed - %d\n"
        }
        symbol = "iptap_clone_create"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "iptap_ipf_input"
        }
        symbol = "iptap_ipf_input"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "iptap_ipf_output"
        }
        symbol = "iptap_ipf_output"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "iptap_ipf_unregister"
            "%s: ipf_remove (ipv4) for %s0 failed - %d\n"
            "%s: ipf_remove (ipv6) for %s0 failed - %d\n"
        }
        symbol = "iptap_detach"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "pktap_inited == 0"
            "pktap_init"
            "pktap.c"
        }
        symbol = "pktap_init"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "pktap_clone_destroy"
        }
        symbol = "pktap_clone_destroy"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "pktap_tap_callback"
        }
        symbol = "pktap_tap_callback"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "pktap_if_output"
        }
        symbol = "pktap_if_output"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "pktap_demux"
        }
        symbol = "pktap_demux"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "pktap_add_proto"
            "%s:%d %s pf %u\n"
        }
        symbol = "pktap_add_proto"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "pktap_del_proto"
        }
        symbol = "pktap_del_proto"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: PKTP_CMD_FILTER_GET ifd_len %llu too small - error %d\n"
            "%s: PKTP_CMD_FILTER_GET copyout - error %d\n"
        }
        symbol = "pktap_getdrvspec"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: PKTP_CMD_FILTER_SET bad ifd_len %llu - error %d\n"
            "%s: copyin - error %d\n"
        }
        symbol = "pktap_setdrvspec"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "pktap_detach"
        }
        symbol = "pktap_detach"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "pktap_bpf_tap"
            "%s:%d unknown if_type %u for %s\n"
        }
        symbol = "pktap_bpf_tap"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "pktap_output"
        }
        symbol = "pktap_output"
        caller = "?"
    }
    new {
        args = 6
        anchors {
            "pktap_input_packet"
            "%s:%d IN %s proto %u pid %d epid %d\n"
        }
        symbol = "pktap_input_packet"
        caller = "?"
    }
    new {
        args = 6
        anchors {
            "pktap_output_packet"
            "%s:%d OUT %s proto %u pid %d epid %d\n"
        }
        symbol = "pktap_output_packet"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "bpf_pkt->bpfp_header_length >= sizeof(struct pktap_header)"
            "extra_src_size <= sizeof(union pktap_header_extra)"
            "pktap_v2_hdr->pth_length + extra_src_size <= sizeof(struct pktap_buffer_v2_hdr_extra)"
            "pktap_v2_hdr->pth_length + extra_src_size <= bpf_pkt->bpfp_header_length"
        }
        symbol = "convert_to_pktap_header_to_v2"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "droptap_inited == 0"
            "/AppleInternal/Library/BuildRoots/d3a62b52-2ef5-11ef-9ecd-e2437461156c/Library/Caches/com.apple.xbs/Sources/xnu/bsd/net/droptap.c"
            "droptap_init"
            "droptap.c"
        }
        symbol = "droptap_init"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: ifnet_allocate_extended failed, error: %d\n"
            "%s: ifnet_attach failed, error: %d\n"
        }
        symbol = "droptap_clone_create"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "lr->lr_reqcnt >= 1"
            "lr->lr_reqcnt != 0"
            "lr->lr_reqcnt == 1"
            "%s: lr=%p wraparound refcnt @%s:%d"
            "iflr_addref"
        }
        symbol = "ifnet_llreach_alloc"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: lr=%p negative reqcnt @%s:%d"
            "%s: Attempt to detach an unattached llreach lr=%p @%s:%d"
        }
        symbol = "ifnet_llreach_free"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "ifp != NULL && iflri != NULL && (af == AF_INET || af == AF_INET6)"
        }
        symbol = "ifnet_llreach_get_defrouter"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s: lr=%p negative refcnt @%s:%d"
            "iflr_remref"
            "%s: attached lr=%p is being freed @%s:%d"
            "%s: lr %p cannot be freed @%s:%d"
            "%s: non-zero refcount lr=%p @%s:%d"
            "%s: non-zero reqcnt lr=%p @%s:%d"
        }
        symbol = "iflr_remref"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: couldn\\'t create flow event advisory thread @%s:%d"
            "flowadv_init"
            "flowadv.c"
        }
        symbol = "flowadv_init"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "!fadv_active"
            "flowadv_cont"
        }
        symbol = "flowadv_thread_cont"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "com.apple.content-filter"
            "%s:%d ctl_register failed: %d\n"
            "%s: Can't create statistics report thread"
            "cfil_stats_report_thread != NULL"
        }
        symbol = "cfil_init"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "%s:%d CFIL: TCP (dir %d) - debug flow with port %d\n"
            "%s:%d already attached\n"
            "%s:%d cfil_info_attach_unit(%u) failed\n"
            "%s:%d so %llx filter_control_unit %u sockID %llu <%llx>\n"
        }
        symbol = "cfil_sock_attach"
        caller = "?"
    }
    new {
        args = 4
        anchors {
            "%s:%d CFIL: TCP(OUT) <so %llx> - filter state changed - dropped pre-existing flow\n"
            "%s:%d CFIL: TCP(OUT) <so %llx> - filter state changed - dropped pre-existing flow (old state 0x%x new state 0x%x)\n"
            "so %p SB_LOCK not set @%s:%d"
            "%s sb_cfil_thread %p not NULL @%s:%d"
        }
        symbol = "cfil_sock_data_out"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s:%d CFIL: TCP(IN) <so %llx> - filter state changed - dropped pre-existing flow\n"
            "%s:%d CFIL: TCP(IN) <so %llx> - filter state changed - dropped pre-existing flow (old state 0x%x new state 0x%x)\n"
        }
        symbol = "cfil_sock_data_in"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "cfil_sock_is_closed"
        }
        symbol = "cfil_sock_is_closed"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "cfil_sock_notify_shutdown"
        }
        symbol = "cfil_sock_notify_shutdown"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "CFIL: SKIP CLOSE WAIT"
            "cfil_sock_close_wait"
            "%s:%d so %llx waiting\n"
            "%s:%d so %llx timed out %d\n"
        }
        symbol = "cfil_sock_close_wait"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "cfil_sock_buf_update"
        }
        symbol = "cfil_sock_buf_update"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s:%d CFIL: FILTER SHOW: Filter <unit %d, entry count %d> flags <%lx>:\n"
            "%s:%d CFIL: FILTER SHOW:-DETACHING\n"
            "%s:%d CFIL: FILTER SHOW:-ACTIVE\n"
            "%s:%d CFIL: FILTER SHOW:-FLOW CONTROLLED\n"
            "CFIL: FILTER SHOW:-DETACHED"
            "CFIL: FILTER SHOW:-ATTACHED"
            "%s:%d CFIL: FILTER SHOW:Filter - total entries shown: %d\n"
        }
        symbol = "cfil_filter_show"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s:%d CFIL: INFO SHOW:count %d\n"
            "cfil_info_show"
            "CFIL: INFO SHOW"
            "%s:%d CFIL: INFO FLAG - DROP\n"
            "%s:%d CFIL: INFO FLAG - CLOSE_WAIT\n"
            "%s:%d CFIL: INFO FLAG - SOCK_CLOSED\n"
            "%s:%d CFIL: INFO FLAG - RETRY_INJECT_IN\n"
            "%s:%d CFIL: INFO FLAG - RETRY_INJECT_OUT\n"
            "%s:%d CFIL: INFO FLAG - SHUT_WR\n"
            "%s:%d CFIL: INFO FLAG - SHUT_RD\n"
            "%s:%d CFIL: INFO SHOW:total cfil_info shown: %d\n"
        }
        symbol = "cfil_info_show"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "CFIL: flow ACTION timeout expired"
        }
        symbol = "cfil_info_action_timed_out"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s:%d CFIL: queue threshold exceeded:mbuf max < count: %d bytes: %d > tail drop count < OUT: %d IN: %d > \n"
            "cfil_info_buffer_threshold_exceeded"
            "CFIL: queue threshold exceeded"
            "CFIL: UDP PER-FLOW GC NEEDED"
        }
        symbol = "cfil_dgram_gc_needed"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s:%d bad sc_unit %u\n"
            "%s:%d sc_unit %u in use\n"
        }
        symbol = "cfil_ctl_connect"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "CFIL: UDP PER-FLOW GC PERFORM"
        }
        symbol = "cfil_dgram_gc_perform"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s:%d CFIL <%s>: <so %llx> - use count %d\n"
            "cfil_sock_udp_unlink_flow"
        }
        symbol = "cfil_sock_udp_unlink_flow"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "CFIL: DGRAM DETACH ENTRY"
        }
        symbol = "cfil_dgram_detach_entry"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s:%d CFIL: DGRAM DETACH DB <so %llx>\n"
            "cfil_dgram_detach_db"
        }
        symbol = "cfil_dgram_detach_db"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "CFIL: FILTER DISCONNECTED"
            "cfc->cf_sock_count == 0"
        }
        symbol = "cfil_ctl_disconnect"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s:%d no socket for sock_id %llx gencnt %llx flowhash %x\n"
            "cfil_socket_from_sock_id"
        }
        symbol = "cfil_socket_from_sock_id"
        caller = "?"
    }
    new {
        args = 3
        anchors {
            "%s:%d so %llx %s dropped\n"
            "%s:%d pass %llu peek %llu\n"
            "%s:%d pass_offset %llu <= cfe_pass_offset %llu\n"
            "CFIL: OUT - PASSED ALL - DETACH"
            "CFIL: IN - PASSED ALL - DETACH"
            "CFIL: WAKING"
            "%s:%d CFIL: <so %llx, sockID %llu <%llx>> outgoing %d cfi_pending_first %llu cfi_pending_last %llu\n"
            "%s:%d CFIL: <so %llx, sockID %llu <%llx>>, cfi_pass_offset %llu\n"
        }
        symbol = "cfil_action_data_pass"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s:%d CFIL: SERVICE CTL-Q: pass_offset %llu peeked %llu peek_offset %llu\n"
            "copylen <= datalen"
            "%s:%d CFIL: SERVICE CTL-Q PASSING: %llx first %llu peeked %llu pass %llu peek %lludatalen %u copylen %u\n"
            "%s:%d %llx first %llu peeked %llu pass %llu peek %lludatalen %u copylen %u\n"
            "copyoffset < datalen"
            "%s:%d CFIL: SERVICE CTL-Q PEEKING: %llx current %llu peeked %llu pass %llu peek %llu datalen %u copylen %u copyoffset %u\n"
            "%s:%d %llx first %llu peeked %llu pass %llu peek %lludatalen %u copylen %u copyoffset %u\n"
            "%s:%d cfil_service_pending_queue() error %d\n"
            "%s:%d first %llu peeked %llu pass %llu peek %llu\n"
            "%s:%d m_copym_mode() failed\n"
            "%s:%d mbuf_allocpacket() failed\n"
            "%s:%d CFIL: Failed to get audit token for <sockID %llu <%llx>> \n"
            "CFIL: SENDING DATA UP"
            "%s:%d CFIL: VERDICT ACTION: so %llx sockID %llu <%llx> outgoing %d: mbuf %llx copyoffset %u copylen %u (%s)\n"
            "IP HDR"
            "NO IP HDR"
            "%s:%d CFIL: Failed to sign data msg <sockID %llu <%llx>>\n"
            "cfil_dispatch_data_event_sign"
            "%s:%d CFIL: SERVICE PENDING-Q: data %llx datalen %u passlen %llu curlen %llu\n"
        }
        symbol = "cfil_data_service_ctl_q"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "cfil_data_length(m, NULL, NULL) == len"
        }
        symbol = "cfil_queue_remove"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "cfq->q_start <= cfq->q_end"
            "(MBUFQ_EMPTY(&cfq->q_mq) && cfq->q_start == cfq->q_end) || (!MBUFQ_EMPTY(&cfq->q_mq) && cfq->q_start != cfq->q_end)"
            "%s - mq %p is free at %p @%s:%d"
            "%s - %p unsupported type %u @%s:%d"
            "%s - %p m_length() %u != chainsize %lu @%s:%d"
            "%s - %p queuesize %llu != offsetdiffs %llu @%s:%d"
        }
        symbol = "cfil_queue_verify"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s:%d CFIL Preserve Connections - %s\n"
            "cfil_update_behavior_flags"
        }
        symbol = "cfil_update_behavior_flags"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "%s:%d null mbuf\n"
            "%s:%d too short %u\n"
            "%s:%d bad version %u\n"
            "%s:%d bad type %u\n"
            "%s:%d bad length %u\n"
            "%s:%d bad len: %u for op %u\n"
            "%s:%d bad op %u\n"
            "%s:%d bad sock_id %llx\n"
            "%s:%d so %llx <id %llu> not attached\n"
            "CFIL: RECEIVED MSG FROM FILTER"
            "%s:%d so %llx no filter\n"
            "%s:%d so %llx attached not sent for %u\n"
            "CFIL: RECEIVED CFM_OP_DATA_UPDATE"
            "%s:%d CFIL: VERDICT RECEIVED: <so %llx sockID %llu <%llx>> <IN peek:%llu pass:%llu, OUT peek:%llu pass:%llu>\n"
            "CFIL: RECEIVED CFM_OP_DROP"
            "%s:%d CFIL: VERDICT DROP RECEIVED: <so %llx sockID %llu <%llx>> <IN peek:%llu pass:%llu, OUT peek:%llu pass:%llu>\n"
        }
        symbol = "cfil_ctl_send"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "CFIL: VERDICT RECEIVED: BLESS"
        }
        symbol = "cfil_action_bless_client"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s:%d CFIL: VERDICT RECEIVED - STATS FLOW INSERTED: <so %llx sockID %llu <%llx>> stats frequency %d msecs\n"
            "%s:%d CFIL: VERDICT RECEIVED - STATS FLOW DELETED: <so %llx sockID %llu <%llx>> stats frequency reset\n"
        }
        symbol = "cfil_info_stats_toggle"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "CFIL: DROP - DETACH"
        }
        symbol = "cfil_action_drop"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s:%d len too small %lu\n"
            "%s:%d len does not match %lu\n"
            "%s:%d data not passed\n"
            "%s:%d CFIL: GET_SOCKET_INFO failed: bad sock_id %llu\n"
            "%s:%d CFIL: GET_SOCKET_INFO failed: so %llx not attached, cannot fetch info\n"
            "%s:%d CFIL: GET_SOCKET_INFO failed: so %llx NULL so_proto / pr_domain\n"
        }
        symbol = "cfil_ctl_getopt"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s:%d CFIL_OPT_NECP_CONTROL_UNIT len too small %lu\n"
            "%s:%d CFIL_OPT_NECP_CONTROL_UNIT already set %u\n"
            "%s:%d CFIL_OPT_PRESERVE_CONNECTIONS got %d (kcunit %d)\n"
        }
        symbol = "cfil_ctl_setopt"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "cfil_info_alloc"
        }
        symbol = "cfil_info_alloc"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "cfil_info_attach_unit"
        }
        symbol = "cfil_info_attach_unit"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "cfe_buf->cfe_ctl_q.q_start >= cfe_buf->cfe_pending_q.q_end"
            "cfe_buf->cfe_peek_offset >= cfe_buf->cfe_pass_offset"
            "cfe_buf->cfe_ctl_q.q_start <= cfe_buf->cfe_peeked"
        }
        symbol = "cfil_entry_buf_verify"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "cfil_info_free"
            "CFIL: FREEING CFIL_INFO"
        }
        symbol = "cfil_info_free"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s:%d so %llx filter_control_unit %u kcunit %u\n"
            "%s:%d CFIL: Failed to get effective audit token for <sockID %llu <%llx>> \n"
            "%s:%d CFIL: Failed to get real audit token for <sockID %llu <%llx>> \n"
            "CFIL: SENDING ATTACH UP"
            "%s:%d CFIL: Failed to sign attached msg <sockID %llu <%llx>>\n"
            "cfil_dispatch_attach_event_sign"
        }
        symbol = "cfil_dispatch_attach_event"
        caller = "?"
    }
    new {
        args = 4
        anchors {
            "%s:%d CFIL: QUEUEING DATA: <so %llx> %s: data %llx len %u flags 0x%x nextpkt %llx - cfi_pending_last %llu cfi_pending_mbcnt %u   cfi_pass_offset %llu\n"
            "%s:%d CFIL: QUEUEING DATA: <so %llx> %s: FAST PATH\n"
            "%s:%d so %llx outgoing %d datalen %u\n"
            "cfil_update_entry_offsets"
        }
        symbol = "cfil_data_common"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s:%d CFIL: IPHDR STRIPPING: <so %llx>: <hlen %d m_len %d>\n"
            "cfil_strip_ip_header"
            "hlen <= data_start->m_len"
        }
        symbol = "cfil_strip_ip_header"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s:%d so %llx kcunit %d\n"
            "CFIL: SENDING CLOSED UP"
            "%s:%d CFIL: Failed to sign closed msg <sockID %llu <%llx>>\n"
            "cfil_dispatch_closed_event_sign"
        }
        symbol = "cfil_dispatch_closed_event"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "cfil_acquire_sockbuf"
            "sb->sb_cfil_thread == NULL"
            "(sb->sb_flags & SB_LOCK) == 0"
        }
        symbol = "cfil_acquire_sockbuf"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s:%d CFIL: SERVICE INJECT-Q: <so %llx> outgoing %d queue len %llu\n"
            "%s:%d CFIL: SERVICE INJECT-Q: <so %llx> data %llx datalen %u (mbcnt %u)\n"
            "CFIL: Error: sosend_reinject() failed"
            "%s:%d CFIL: sosend() failed %d\n"
            "%s:%d CFIL: SERVICE INJECT-Q: <so %llx> injected %d\n"
            "CFIL: Marked previoulsy delayed socket as DEAD"
            "CFIL: Handled previously delayed socket for TCP time wait"
        }
        symbol = "cfil_service_inject_queue"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s sb_cfil_thread %p not current %p @%s:%d"
            "%s SB_LOCK not set on %p @%s:%d"
        }
        symbol = "cfil_release_sockbuf"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s:%d so %llx disconnect already sent\n"
            "%s:%d so %llx control queue not empty\n"
            "CFIL: OUT - SENDING DISCONNECT UP"
            "CFIL: IN - SENDING DISCONNECT UP"
        }
        symbol = "cfil_dispatch_disconnect_event"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "CFIL: UDP PER-FLOW WAIT FOR FLOW TO FINISH"
            "cfil_filters_udp_attached_per_flow"
            "CFIL: UDP PER-FLOW WAIT FOR FLOW DONE"
            "CFIL: UDP PER-FLOW WAIT FOR FLOW TIMED OUT, FORCE DETACH"
        }
        symbol = "cfil_filters_udp_attached_per_flow"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s:%d <%s>: <%s(%d) so %llx cfil %p, entry %p, sockID %llu <%llx> feat_ctxt_id <%llu> lport %d fport %d laddr %s faddr %s hash %X\n"
            "cfil_hash_entry_log"
            "%s:%d <%s>: <%s so %llx cfil %p - flags 0x%x 0x%x, sockID %llu <%llx>> lport %d fport %d laddr %s faddr %s\n"
            "%s:%d <%s>: <%s so %llx - flags 0x%x 0x%x> lport %d fport %d laddr %s faddr %s\n"
        }
        symbol = "cfil_info_log"
        caller = "?"
    }
    new {
        args = 6
        anchors {
            "%s:%d CFIL: UDP no active filter\n"
            "%s:%d CFIL: UDP failed to get control unit\n"
            "%s:%d CFIL: UDP user space only\n"
            "%s:%d CFIL: <so %llx> NULL soflow_hash_entry\n"
            "%s:%d CFIL: <so %llx> NULL soflow_hash_entry db\n"
            "CFIL: Got flow"
            "CFIL: UDP DROP"
            "%s:%d CFIL: UDP(%s) <so %llx> - filter state changed - dropped pre-existing flow (old state 0x%x new state 0x%x)\n"
            "%s:%d CFIL: <so %llx> UDP (outgoing %d) - debug flow with port %d\n"
            "%s:%d CFIL: <so %llx> UDP so_gencnt %llx entry flowhash %x cfil %p sockID %llu <%llx>\n"
            "%s:%d CFIL: <so %llx> UDP cfil_info_attach_unit(%u) failed\n"
            "%s:%d CFIL: UDP <so %llx> filter_control_unit %u sockID %llu <%llx> attached\n"
            "%s:%d CFIL: UDP <so %llx> cfil_dispatch_attach_event failed <error %d>\n"
        }
        symbol = "cfil_sock_udp_handle_data"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "CFIL: UDP PER-FLOW NOTIFY_SHUTDOWN"
        }
        symbol = "cfil_sock_udp_notify_shutdown_per_flow"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "cfil_sock_udp_shutdown"
        }
        symbol = "cfil_sock_shutdown"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "CFIL: UDP PER-FLOW IS_CLOSED"
        }
        symbol = "cfil_sock_udp_is_closed_per_flow"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "cfil_sock_udp_buf_update_per_flow"
        }
        symbol = "cfil_sock_udp_buf_update_per_flow"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "CFIL_STATS_REPORT"
        }
        symbol = "cfil_stats_report_thread_func"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s:%d CFIL: STATS COLLECTION RUNNING\n"
            "%s:%d CFIL: STATS: no flow\n"
            "%s:%d CFIL: STATS REPORT - so %llx no filter\n"
            "%s:%d CFIL: STATS reporting for %d flows\n"
            "%s:%d CFIL: STATS: no buffer\n"
            "%s:%d CFIL: STATS REPORT - elapsed time - ts %llu %llu cur ts %llu %llu diff %llu %llu(usecs %llu) @freq %llu usecs sockID %llu <%llx>\n"
            "%s:%d CFIL: STATS REPORT - in %llu reported %llu\n"
            "%s:%d CFIL: STATS REPORT - out %llu reported %llu\n"
            "CFIL: STATS COLLECTED"
            "%s:%d STATS (kcunit %d): msg size %lu - %lu %lu %lu\n"
            "%s:%d ctl_enqueuedata() failed:%d\n"
            "%s:%d CFIL: STATS REPORT:send msg to %d\n"
        }
        symbol = "cfil_stats_report"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s:%d Inited client key\n"
            "cfil_crypto_init_client"
        }
        symbol = "cfil_action_set_crypto_key"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: couldn\\'t create network work queue thread"
            "nwk_wq_init"
        }
        symbol = "nwk_wq_init"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "nwk_wq_thread_func"
        }
        symbol = "nwk_wq_thread_func"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "nwk_wq_thread_cont"
            "TAILQ_EMPTY(&nwk_wq_head)"
            "TAILQ_FIRST(&temp_nwk_wq_head) != NULL"
        }
        symbol = "nwk_wq_thread_cont"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "restricted_port_init: bitmap allocation failed @%s:%d"
            "restricted_in_port.c"
        }
        symbol = "restricted_in_port_init"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "com.apple.private.network.restricted.port.control"
            "%s:%u sysctl net.restricted_port.verbose: %d -> %d)"
        }
        symbol = "sysctl_restricted_port_verbose"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "com.apple.private.network.restricted.port.lights_out_management"
            "port %u for protocol %u via %s can be used by process %s:%u"
            "entitlement restricted port %u for protocol %u via %s cannot be used by kernel"
            "entitlement restricted port %u for protocol %u via %s cannot be used by process %s:%u -- IOTaskHasEntitlement(%s) failed"
            "entitlement restricted port %u for protocol %u via %s can be used by process %s:%u"
        }
        symbol = "current_task_can_use_restricted_in_port"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "com.apple.net.rvi_control"
            "rvi_start failed: rvi_register_control failure"
        }
        symbol = "rvi_init"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "rvi_ctl_connect"
            "%s: failure to create virtual interface %d"
            "%s: ifnet_allocate for %s%d failed - %d"
            "%s: ifnet_attach for %s%d failed - %d"
        }
        symbol = "rvi_ctl_connect"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "rvi_set_bpf_tap"
            "%s: ifnet_softc is NULL for ifp %p"
        }
        symbol = "rvi_set_bpf_tap"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "rvi_ctl_disconnect: received a disconnect notification without a cache entry @%s:%d"
            "remote_vif.c"
            "rvi_destroy_if"
            "%s: ifnet_detach for %s%d failed - %d"
        }
        symbol = "rvi_ctl_disconnect"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "rvi_ctl_send"
            "rvi_bpf_tap"
            "%s: mbuf_copydata failed %d"
            "%s mbuf_pullup failed"
        }
        symbol = "rvi_ctl_send"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "qlen(q) != 0"
        }
        symbol = "_addq"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "qlen(q) == 0"
        }
        symbol = "_getq"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "n != NULL || (qlen(q) == 1 && m == MBUFQ_FIRST(head))"
            "m == MBUFQ_FIRST(head)"
            "n != NULL"
        }
        symbol = "_getq_tail"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "c == 0 || !MBUFQ_EMPTY(&freeq)"
            "c == 0 || !KPKTQ_EMPTY(&freeq)"
        }
        symbol = "_flushq_flow"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "ifq->ifcq_sflags == 0"
        }
        symbol = "ifclassq_setup"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "packets != NULL"
            "MBUF_VALID_SC(sc) || sc == MBUF_SC_UNSPEC"
        }
        symbol = "ifclassq_get_len"
        caller = "?"
    }
    new {
        args = 3
        anchors {
            "IFCQ_TBR_IS_ENABLED(ifq)"
        }
        symbol = "ifclassq_tbr_dequeue_common"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "ptype == QP_PACKET"
        }
        symbol = "fq_alloc"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "!fq->fq_in_dqlist"
            "fq_empty(fq, ptype)"
            "!(fq->fq_flags & (FQF_NEW_FLOW | FQF_OLD_FLOW | FQF_EMPTY_FLOW))"
        }
        symbol = "fq_destroy"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "!(*pkt_flags & PKTF_PRIV_GUARDED)"
            "fq->fq_group == fq_grp"
            "fqs->fqs_ptype == pkt->pktsched_ptype"
            "STAILQ_NEXT(fq, fq_actlink) == NULL"
            "fq_detect_dequeue_stall"
            "%s:num: %d, scidx: %d, flow: 0x%x, iface: %s grp: %hhu"
        }
        symbol = "fq_addq"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "fq->fq_bytes >= plen"
        }
        symbol = "fq_getq_flow_internal"
        caller = "?"
    }
    new {
        args = 3
        anchors {
            "pkt->pktsched_pkt_mbuf == NULL"
            "%s: dequeue num overflow, flow: 0x%x, iface: %s"
            "%s: scidx: %d, %llu, flow: 0x%x, iface: %s, grp: %hhu\n"
        }
        symbol = "fq_getq_flow"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "kern_packet_finalize(ph2) == 0"
        }
        symbol = "pktsched_clone_pkt"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "cnt == (uint32_t)pcnt"
        }
        symbol = "pktsched_free_pkt"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "ifclassq_enable_pacing"
            "ifcq_drr_max"
            "buf[i] >= '0' && buf[i] <= '9'"
        }
        symbol = "pktsched_fq_init"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "fq_if_enqueue_classq"
        }
        symbol = "fq_if_enqueue_classq"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "fq_if_setup_ifclassq"
            "%s: error from fq_if_create_grp, failed to create a fq group: %d\n"
        }
        symbol = "fq_if_setup_ifclassq"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "!fq_empty(fq, fqs->fqs_ptype)"
            "fq->fq_flags & FQF_NEW_FLOW"
        }
        symbol = "fq_if_drop_packet"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "fq_if_add_fcentry"
            "%s: num: %d, scidx: %d, flowsrc: %d, flow: 0x%x, iface: %s, B:%u\n"
        }
        symbol = "fq_if_add_fcentry"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "fq_if_flow_feedback"
            "%s: num: %d, scidx: %d, flowsrc: %d, flow: 0x%x, iface: %s grp: %hhu, B:%u\n"
        }
        symbol = "fq_if_flow_feedback"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "fqs != NULL && ifq->ifcq_type == PKTSCHEDT_FQ_CODEL"
        }
        symbol = "fq_if_teardown_ifclassq"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "i <= flowstat_cnt"
        }
        symbol = "fq_if_getqstats_ifclassq"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "svc == MBUF_SC_UNSPEC"
            "!TAILQ_EMPTY(grp_list)"
            "pri > 0"
            "TAILQ_EMPTY(grp_list)"
        }
        symbol = "fq_if_dequeue_classq_multi_common"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "pktlimit > 0 && bytelimit > 0 && top != NULL"
            "(fq->fq_flags & (FQF_NEW_FLOW | FQF_OLD_FLOW)) == FQF_OLD_FLOW"
            "top->cp_mbuf != NULL"
        }
        symbol = "fq_if_dequeue"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "fqs->fqs_empty_list_cnt == 0"
            "STAILQ_EMPTY(&fqs->fqs_fclist)"
            "LIST_EMPTY(&fqs->fqs_flows[i])"
        }
        symbol = "fq_if_purge"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "STAILQ_EMPTY(&fq_cl->fcl_new_flows)"
            "STAILQ_EMPTY(&fq_cl->fcl_old_flows)"
        }
        symbol = "fq_if_purge_classq"
        caller = "?"
    }
    new {
        args = 3
        anchors {
            "pkt.pktsched_ptype == QP_INVALID"
            "(fq->fq_flags & (FQF_NEW_FLOW | FQF_OLD_FLOW | FQF_EMPTY_FLOW))"
        }
        symbol = "fq_if_purge_flow"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "req->flow != 0"
            "FQ_IF_CLASSQ_IDLE(fq_cl)"
        }
        symbol = "fq_if_request_classq"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "ifp->if_mtu <= IF_MAXMTU"
            "ifp->if_mtu <= UINT16_MAX"
            "ifp->if_tso_v4_mtu <= UINT16_MAX"
            "ifp->if_tso_v6_mtu <= UINT16_MAX"
        }
        symbol = "fq_if_calc_quantum"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "fq_cl->fcl_quantum == 0"
        }
        symbol = "fq_if_classq_init"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "NETEM: %-30s ┌ begin %s\n"
            "NETEM: %-30s | netem no traffic shapping %s on %s\n"
            "NETEM: %-30s | netem create %s\n"
            "NETEM: %-30s | netem disable %s\n"
            "NETEM: %-30s | netem destroy %s\n"
            "NETEM: %-30s └ ret %d\n"
            "NETEM: %-30s | error: invalid scheduler model %d\n"
            "NETEM: %-30s | error: corruption_p %d > %d\n"
            "NETEM: %-30s | error: duplication_p %d > %d\n"
            "NETEM: %-30s | error: duplication needs latency param\n"
            "NETEM: %-30s | error: latency %d too big (> 1 sec)\n"
            "NETEM: %-30s | error: jitter %dms too big (latency %dms)\n"
            "NETEM: %-30s | error: loss params not all zero when p_gr_gl is zero\n"
            "NETEM: %-30s | error: loss recovery %dms too big\n"
            "NETEM: %-30s | error: loss params too big\n"
            "NETEM: %-30s | error: reordering %d > %d\n"
            "NETEM: %-30s | error: output interval %dms too big\n"
            "%s can't create thread"
            "NETEM: %-30s | %s set_params success\n"
            "NETEM: %-30s | model %s\n"
            "NETEM: %-30s | bandwidth %llu bps %s\n"
            "no limit"
            "NETEM: %-30s | corruption  %d%%\n"
            "NETEM: %-30s | duplication  %d%%\n"
            "NETEM: %-30s | latency_ms  %d jitter_ms %d\n"
            "NETEM: %-30s | loss p_gr_gl  %d%%\n"
            "NETEM: %-30s |      p_gr_bl  %d%%\n"
            "NETEM: %-30s |      p_bl_gr  %d%%\n"
            "NETEM: %-30s |      p_bl_br  %d%%\n"
            "NETEM: %-30s |      p_br_bl  %d%%\n"
            "NETEM: %-30s |      recovery_ms  %dms\n"
            "NETEM: %-30s | reordering  %d%% %d ms behind\n"
            "NETEM: %-30s | output ival  %d ms\n"
            "Network link conditioner"
        }
        symbol = "netem_config"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "!(ne->netem_flags & NETEMF_RUNNING)"
        }
        symbol = "netem_output_thread_func"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "NETEM: %-30s %s output thread terminated\n"
            "netem_output_thread_cont"
            "NETEM: %-30s ┌ begin\n"
            "netem_dequeue_internal_locked"
            "NETEM: %-30s | heap empty\n"
            "NETEM: %-30s | TTS not yet reached: %llu now %llu\n"
            "NETEM: %-30s └ end\n"
        }
        symbol = "netem_output_thread_cont"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "NETEM: %-30s ┌ begin p %p len %u, now %llu\n"
            "NETEM: %-30s | zero-bw blocked\n"
            "NETEM: %-30s | lost\n"
            "NETEM: %-30s | dup'ed\n"
            "NETEM: %-30s | heap_insert p %p err(%d), freeing pkt\n"
            "NETEM: %-30s | %p enqueued TTS %llu\n"
            "NETEM: %-30s └ %p end\n"
            "NETEM: %-30s | corrupted\n"
            "corruption_event"
            "NETEM: %-30s | reorder %dms behind\n"
            "NETEM: %-30s | total delay %dms\n"
        }
        symbol = "nlc_enqueue"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "%s: mbuf %p too short (%d) for IPv4 header @%s:%d"
            "inet_cksum"
        }
        symbol = "inet_cksum"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s: off (%d) >= len (%d) @%s:%d"
            "inet_cksum_buffer"
        }
        symbol = "inet_cksum_buffer"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "igmp_domifattach"
            "%s: called for ifp %s\n"
        }
        symbol = "igmp_domifattach"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "!(igi->igi_debug & IFD_ATTACHED)"
            "igmp_domifreattach"
            "%s: reattached igmp_ifinfo for ifp %s\n"
        }
        symbol = "igmp_domifreattach"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "igmp_domifdetach"
            "%s: igmp_ifinfo not found for ifp %p(%s) @%s:%d"
            "igi_delete"
        }
        symbol = "igmp_domifdetach"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s: igi=%p negative refcnt @%s:%d"
            "%s: attached igi=%p is being freed @%s:%d"
            "%s: ifp not NULL for igi=%p @%s:%d"
            "%s: igi %p cannot be freed @%s:%d"
            "%s: non-zero refcnt igi=%p @%s:%d"
            "%s: freeing igmp_ifinfo for ifp %s\n"
        }
        symbol = "igi_remref"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s: called w/mbuf(0x%llx,%d)\n"
            "igmp_input"
        }
        symbol = "igmp_input"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "igmp_init"
            "%s: initializing\n"
        }
        symbol = "igmp_init"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "sysctl_igmp_default_version"
            "%s: changed igmp_default_version from %d to %d\n"
        }
        symbol = "sysctl_igmp_default_version"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s: cancel v3 timers on ifp 0x%llx(%s)\n"
            "igmp_v3_cancel_link_timers"
        }
        symbol = "igmp_v3_cancel_link_timers"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "process v2 query %s on ifp 0x%llx(%s)\n"
            "%s: ignore v2 query on IGIF_LOOPBACK ifp %s\n"
            "%s: process v2 general query on ifp %s\n"
        }
        symbol = "igmp_input_v2_query"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "igmp_v2_update_group"
        }
        symbol = "igmp_v2_update_group"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "process v3 %s query on ifp 0x%llx(%s)\n"
            "igmp_input_v3_group_query"
            "%s: process v3 query on ifp %s\n"
            "%s: ignore v3 query on IGIF_LOOPBACK ifp %s\n"
            "%s: ignore v3 query in v%d mode on ifp %s\n"
            "%s: process v3 general query on ifp %s\n"
            "%s: GS query throttled.\n"
            "%s: v3 general query response scheduled in T+%d seconds on ifp %s\n"
        }
        symbol = "igmp_input_v3_query"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "report suppressed for %s on ifp 0x%llx(%s)\n"
            "process v2 report %s on ifp 0x%llx(%s)\n"
            "igmp_input_v2_report"
            "%s: process v2 report on ifp %s"
        }
        symbol = "igmp_input_v2_report"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "inm->inm_igi->igi_version == IGMP_VERSION_3"
        }
        symbol = "igmp_v3_suppress_group_record"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "igmp_v1v2_process_querier_timers"
            "%s: cancel v2 timer on 0x%llx(%s)\n"
            "igmp_v3_dispatch_general_query"
            "igi == inm->inm_igi"
            "%s: transition from v%d->v%d on %s\n"
        }
        symbol = "igmp_timeout"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "inm->inm_st[1].iss_asm == 0"
            "%s: m_adj(m, -ig)\n"
            "%s: outbound queue full on %s\n"
            "%s: m_append() failed\n"
            "%s: m_append() failed"
            "%s: m_get*() failed"
        }
        symbol = "igmp_v3_enqueue_group_record"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "igmp_v1v2_queue_report"
            "%s: v1 / v2 outbound queue full on %s\n"
        }
        symbol = "igmp_v1v2_queue_report"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "igmp_dispatch_queue"
            "(m->m_flags & M_PKTHDR)"
            "%s: igmpreclen is %d\n"
            "%s: dropped 0x%llx as interface went away\n"
            "%s: dropped 0x%llx\n"
            "%s: ip_output(0x%llx) = %d\n"
            "%s: invalid length %d\n"
        }
        symbol = "igmp_dispatch_queue"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "igmp_flush_relq"
            "inm->inm_in_nrele == true"
            "%s: flushing %llx on relq ifp %s"
        }
        symbol = "igmp_flush_relq"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "igmp_initial_join"
            "igi->igi_rv > 1"
            "%s: T1->T0 for %s / %s\n"
            "%s: nothing to do \n"
            "inm->inm_debug & IFD_ATTACHED"
            "%s: T1 now MCAST_UNDEFINED for %s/%s\n"
        }
        symbol = "igmp_change_state"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "cmd == SIOCDIFADDR"
            "in_control"
            "cmd == SIOCDIFADDR || cmd == SIOCSIFADDR || cmd == SIOCSIFNETMASK || cmd == SIOCSIFDSTADDR"
            "Another thread is already attempting to delete IPv4 address: %s on interface %s. Go to sleep and check again after the operation is done"
        }
        symbol = "in_control"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: SIOCDIFADDR ifp=%s ifa_addr=%s ifa_dstaddr=%s (err=%d)\n"
            "%s: error retrieving list of AF_INET addresses for ifp=%s (err=%d)\n"
        }
        symbol = "in_purgeaddrs"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "in_domifattach"
        }
        symbol = "in_domifattach"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: failed to add membership to all-hosts multicast address on %s\n"
            "in_ifinit"
            "pinm != NULL || error != 0"
        }
        symbol = "in_ifinit"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "attempt to remove wrong ia %p from hash table @%s:%d"
        }
        symbol = "in_iahash_remove"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "in_ifaddr_free"
        }
        symbol = "in_ifaddr_free"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: draining ARP entries\n"
            "in_arpdrain"
        }
        symbol = "in_arpdrain"
        caller = "?"
    }
    new {
        args = 5
        anchors {
            "%s: can't allocate llinfo for %s\n"
            "arp_lookup_ip"
            "pkt.cp_mbuf == packet"
        }
        symbol = "arp_lookup_ip"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s duplicate IP address %s sent from address %s\n"
            "arp: %s on %s sent probe for %s, already on %s\n"
            "arp: sending conflicting probe to %s on %s\n"
            "arp: %s is on %s but got reply from %s on %s\n"
            "arp: %s moved from %s to %s on %s\n"
            "arp: %s attempts to modify permanent entry for %s on %s\n"
            "%s: sending %u held packets\n"
            "arp_ip_handle_input"
            "qempty(&llinfo->la_holdq)"
            "ARP reply"
            "ARP announcement"
            "%s: %s%s for %s\n"
        }
        symbol = "arp_ip_handle_input"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "host is not on local network"
            "could not allocate llinfo"
            "gateway route is not ours"
            "%s: link#%d %s failed: %s\n"
            "arp_lookup_route"
        }
        symbol = "arp_lookup_route"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "la->la_llreach != NULL"
            "has alias(es) and hasn't been used in a while"
            "haven't heard from it in a while"
            "%s: ARP probe(s) needed for %s; %s [lastused %lld, lastrcvd %lld] secs ago\n"
        }
        symbol = "arp_llreach_reachable"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: dropping packet due to maxhold_total\n"
            "_m != NULL"
            "%s: dropping packet (scidx %u)\n"
            "%s: enqueued packet (scidx %u), qlen now %u\n"
        }
        symbol = "arp_llinfo_addq"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: probe scheduled in T+%llus.%lluu\n"
            "arp_sched_probe"
        }
        symbol = "arp_sched_probe"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: not rescheduling probe\n"
        }
        symbol = "arp_probe"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "arp_rtrequest"
        }
        symbol = "arp_rtrequest"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "rt->rt_llinfo_purge == arp_llinfo_purge && la != NULL"
        }
        symbol = "arp_llinfo_purge"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "arp_llinfo_free"
            "in_arp.c"
            "la->la_rt->rt_llinfo == la"
        }
        symbol = "arp_llinfo_free"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: timer scheduled in T+%llus.%lluu\n"
            "arp_sched_timeout"
        }
        symbol = "arp_sched_timeout"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: not rescheduling timer\n"
        }
        symbol = "arp_timeout"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "inm->inm_st[1].iss_rec == 0"
        }
        symbol = "inm_clear_recorded"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "imf_purge"
        }
        symbol = "imf_purge"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "inm_commit"
        }
        symbol = "inm_commit"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "inm_purge"
        }
        symbol = "inm_purge"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "in_leavegroup"
            "inm->inm_ifp == inm->inm_ifma->ifma_ifp"
        }
        symbol = "in_leavegroup"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s: error copyin IP_ADD_MEMBERSHIP/IP_ADD_SOURCE_MEMBERSHIP %d err=%d\n"
            "imo->imo_mfilters != NULL"
            "%s: new join w/o source\n"
        }
        symbol = "inp_join_group"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s: opt=%d is_final=0\n"
            "inm == imo->imo_membership[idx]"
        }
        symbol = "inp_leave_group"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s: inm=%p negative reqcnt @%s:%d"
            "%s: Attempt to detach an unattached record inm=%p @%s:%d"
            "%s: inm %p is already in trash list @%s:%d"
        }
        symbol = "in_multi_detach"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s: inm=%p negative/missing refcnt @%s:%d"
            "inm_remref"
            "%s: attached inm=%p is being freed @%s:%d"
            "%s: ifma not NULL for inm=%p @%s:%d"
            "%s: inm %p cannot be freed @%s:%d"
            "%s: non-zero refcount inm=%p @%s:%d"
            "%s: non-zero reqcnt inm=%p @%s:%d"
        }
        symbol = "inm_remref"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: --- begin inm 0x%llx ---\n"
            "inm_print"
            "igi 0x%llx nsrc %lu sctimer %u scrv %u\n"
            "%s: --- end inm 0x%llx ---\n"
        }
        symbol = "inm_print"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "inm_get_source"
            "inm_reap"
        }
        symbol = "inm_merge"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s: in_getmulti() failure\n"
            "ifma->ifma_addr->sa_family == AF_INET"
            "inm->inm_ifma == ifma"
            "in_hosteq(inm->inm_addr, *group)"
        }
        symbol = "in_joingroup"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s: Attempt to attach an already attached inm=%p @%s:%d"
            "%s: Attempt to reattach a detached inm=%p @%s:%d"
            "inm->inm_reqcnt == 1"
        }
        symbol = "in_multi_attach"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: inm %p has no debug structure @%s:%d"
            "inm_trace"
        }
        symbol = "inm_trace"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "imf_rollback"
        }
        symbol = "imf_rollback"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "imf_reap"
        }
        symbol = "imf_reap"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s: can't find ifp for addr=%s\n"
            "inp_set_multicast_if"
        }
        symbol = "inp_set_multicast_if"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "!inpcb_initialized"
            "unable to alloc the inpcb thread call @%s:%d"
        }
        symbol = "in_pcbinit"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: ipi %p already in the list @%s:%d"
            "in_pcbinfo_attach"
        }
        symbol = "in_pcbinfo_attach"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "[%u %s:%u %s:%u]"
        }
        symbol = "inp_snprintf_tuple"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: insufficient space to align inp_stat @%s:%d"
            "%s: insufficient space to align inp_cstat @%s:%d"
            "%s: insufficient space to align inp_wstat @%s:%d"
            "%s: insufficient space to align inp_Wstat @%s:%d"
            "%s: insufficient space to align inp_btstat @%s:%d"
        }
        symbol = "in_pcballoc"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s: so %p [%d,%d] usecount %d lockhistory %s @%s:%d"
            "%s: inp %p invalid wantcnt %d, so %p [%d,%d] usecount %d retaincnt %d state 0x%x flags 0x%x lockhistory %s\n"
            "%s: inp %p invalid wantcnt %d no socket @%s:%d"
            "%s: so=%p head still exist @%s:%d"
        }
        symbol = "in_pcbdispose"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "phd != NULL && inp->inp_lport > 0"
            "inp->inp_pcbinfo->ipi_twcount != 0"
            "!(inp->inp_flags2 & INP2_IN_FCTREE)"
        }
        symbol = "in_pcbremlists"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: pcb=%p so=%p usecount is negative @%s:%d"
            "%s: pcb=%p release with zero count @%s:%d"
            "%s: RELEASE pcb=%p so=%p usecount is negative @%s:%d"
            "%s: so=%p not a valid state =%x @%s:%d"
        }
        symbol = "in_pcb_checkstate"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "inp_route_copyin"
        }
        symbol = "inp_route_copyin"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "RB_INSERT(inp_fc_tree, &inp_fc_tree, inp) == NULL"
        }
        symbol = "inp_calc_flowhash"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "tmp_inp == inp"
        }
        symbol = "inp_set_fc_state"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "pid %d (%s) is unable to receive packets on %s\n"
            "_inp_restricted_recv %s:%d not allowed on management interface %s"
        }
        symbol = "inp_restricted_recv"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "pid %d (%s) is unable to transmit packets on %s\n"
            "_inp_restricted_send %s:%d not allowed on management interface %s"
        }
        symbol = "inp_restricted_send"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "inpcb_timeout_run >= 0 && inpcb_timeout_run < 2"
        }
        symbol = "inpcb_timeout"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "proc != NULL"
        }
        symbol = "in_pcbladdr"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "NOACCESS"
            "inp_update_cellular_policy"
        }
        symbol = "inp_update_cellular_policy"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "WANTED"
            "UNWANTED"
            "inp_update_necp_want_app_policy"
        }
        symbol = "inp_update_necp_want_app_policy"
        caller = "?"
    }
    new {
        args = 4
        anchors {
            "inpcb_get_ports_used"
            "%s: ifnet_list_get_all() failed %d"
        }
        symbol = "inpcb_get_ports_used"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "throttle[%d]: so 0x%llx [%d,%d] %s\n"
            "SUSPENDED"
            "RESUMED"
        }
        symbol = "inpcb_count_opportunistic"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: sosetdefunct() error %d"
            "shutdown_sockets_on_interface_proc_callout"
        }
        symbol = "shutdown_sockets_on_interface_proc_callout"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "inetdomain == NULL"
            "%s: failed to register PF_INET protocol: %d @%s:%d"
            "in_dinit"
            "in_proto.c"
        }
        symbol = "in_dinit"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "in_validate"
            "%s: route to %s->%s->%s validated, flags=0x%x\n"
        }
        symbol = "in_validate"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "in_rtqdrain"
            "%s: draining routes\n"
        }
        symbol = "in_rtqdrain"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "head != inet_rt_table || *head == NULL"
        }
        symbol = "in_inithead"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "in_rmx.c"
            "%s: deleting route to %s->%s->%s, flags=0x%x, draining=%d\n"
            "%s: error deleting route to %s->%s->%s, flags=0x%x, err=%d\n"
            "%s: route to %s->%s->%s, flags=0x%x, adjusted expire=T+%u (was T+%u)\n"
        }
        symbol = "in_rtqkill"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "in_deleteroute"
            "%s: route to %s->%s->%s deleted, flags=0x%x\n"
        }
        symbol = "in_deleteroute"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "in_ifadownkill"
        }
        symbol = "in_ifadownkill"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "SO_VALID_TC(optval)"
            "throttle[%d]: so 0x%llx [%d,%d] opportunistic %s\n"
        }
        symbol = "so_set_traffic_class"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "(SOCK_CHECK_DOM(so, PF_INET) || SOCK_CHECK_DOM(so, PF_INET6)) && SOCK_CHECK_TYPE(so, SOCK_STREAM) && SOCK_CHECK_PROTO(so, IPPROTO_TCP)"
            "throttle[%d]: so 0x%llx [%d,%d] TCP %s send; %s recv\n"
        }
        symbol = "set_tcp_stream_priority"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "SO_VALID_TC(sotc)"
            "MBUF_VALID_SC(msc)"
        }
        symbol = "set_packet_service_class"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "invalid QoS marking type @%s:%d"
            "in_tclass.c"
            "%s qos_allowed %d sotc %u netsvctype %u dscp %u\n"
            "%s set msc %u for dscp %u\n"
        }
        symbol = "set_packet_qos"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "netsvctype_dscp_map != NULL"
        }
        symbol = "set_netsvctype_dscp_map"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "UNKNOWN_DUMMYNET_EVENT"
        }
        symbol = "dummynet_event_enqueue_nwk_wq_entry"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "dummynet: -- unknown option %d"
            "dummynet: no memory for new pipe\n"
            "dummynet: ++ ref to pipe %d from fs %d\n"
        }
        symbol = "ip_dn_ctl"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "\ndummynet: net.inet.ip.dummynet.red_lookup_depth must be > 0\n"
            "dummynet: sorry, cannot allocate red lookup table\n"
        }
        symbol = "set_fs_parms"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "dummynet: heap_init, resize %d failed\n"
        }
        symbol = "heap_insert_0"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "dummynet_io m: 0x%llx pipe: %d dir: %d\n"
            "dummynet: no pipe %d for queue %d, drop pkt\n"
            "dummynet: ++ ouch! not eligible but empty scheduler!\n"
            "dummynet: OUCH! pipe should have been idle!\n"
            "dummynet: waking up pipe %d at %d\n"
            "dummynet: sorry, cannot allocate queue for new flow\n"
            "\ndummynet: %d q: %2u "
            "dummynet: avg: %u "
            "dummynet: - drop"
            "dummynet: - red drop"
        }
        symbol = "dummynet_io"
        caller = "?"
    }
    new {
        args = 3
        anchors {
            "dummynet: ready_event pipe is gone\n"
        }
        symbol = "ready_event"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "dummynet: warning, extract from empty heap 0x%llx\n"
            "dummynet: heap_extract from middle not supported on this heap!!! @%s:%d"
            "dummynet: heap_extract, father %d out of bound 0..%d\n"
            "dummynet: heap_extract @%s:%d"
        }
        symbol = "heap_extract_0"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "dummynet: pipe %d ready from %s --\n"
        }
        symbol = "ready_event_wfq"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "dummynet: bad ready_event_wfq for pipe %s\n"
        }
        symbol = "dummynet"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "dummynet_send m: 0x%llx dn_dir: %d dn_flags: 0x%x\n"
            "dummynet: bad switch %d!\n"
        }
        symbol = "dummynet_send"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "dummynet_event"
            "eventhandler_invoke(\"dummynet_event\")"
        }
        symbol = "dummynet_event_callback"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "(u_int)type <= ICMP_MAXTYPE"
            "code <= UINT8_MAX"
        }
        symbol = "icmp_error"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s: redirect dst %s to %s from %s\n"
            "icmp_input"
        }
        symbol = "icmp_input"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "icmp_dgram_attach @%s:%d"
            "ip_icmp.c"
        }
        symbol = "icmp_dgram_attach"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: Unable to find [PF_INET,IPPROTO_RAW,SOCK_RAW] @%s:%d"
            "ip_init"
            "dp == inetdomain && dp->dom_family == PF_INET"
            "ip_checkinterface"
            "inaddr_nhash"
            "ip_moptions"
        }
        symbol = "ip_init"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "ip_input"
        }
        symbol = "ip_input"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: failed to initialise lo0's address, error=%d\n"
            "ip_init_delayed"
        }
        symbol = "ip_init_delayed"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "ip_input_first_pass"
        }
        symbol = "ip_input_process_list"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "attempted source route from %s to %s\n"
        }
        symbol = "ip_dooptions"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "ip_fwd_route_copyout"
            "ip_fwd_route_copyin"
        }
        symbol = "ip_forward"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "sysctl_ip_checkinterface"
            "%s: ip_checkinterface is now %d\n"
        }
        symbol = "sysctl_ip_checkinterface"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "ip_output: Invalid policy found. %d\n"
            "ip4_output (ipsec): error code %d\n"
            "%s: can't update route after IPsec processing\n"
            "interface_mtu != 0"
            "src.s_addr != INADDR_ANY"
            "%s->%s ifscope %d->%d ifa_if %s ro_if %s\n"
            "%s->%s ifscope %d->%d ifa_if %s\n"
            "%s->%s ifscope %d ifa_if %s\n"
            "%s->%s ifscope %d ro_if %s != ifa_if %s (cached route cleared)\n"
            "%s->%s ifscope %d ro_if %s (no ifa_if found)\n"
            "%s->%s ifscope %d (neither ro_if/ifa_if found)\n"
        }
        symbol = "ip_output_list"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "%s: mbuf %p pkt len (%u) < hoff+ip_hdr (%u+%u)\n @%s:%d"
            "%s: mbuf %p pkt too short (%d) for IP header (%u), hoff %u @%s:%d"
            "%s: mbuf 0x%llx proto %d IP len %d (%x) [swapped %d (%x)] doesn't match actual packet length; %d is used instead\n"
            "%s: mlen %u - hoff %u > 65535 @%s:%d"
            "_hlen == sizeof(*ip)"
        }
        symbol = "in_finalize_cksum"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s: imo %p negative refcnt @%s:%d"
            "%s: imo %p cannot be freed @%s:%d"
        }
        symbol = "imo_remref"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: imo %p has no debug structure @%s:%d"
            "imo_trace"
        }
        symbol = "imo_trace"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "/AppleInternal/Library/BuildRoots/d3a62b52-2ef5-11ef-9ecd-e2437461156c/Library/Caches/com.apple.xbs/Sources/xnu/bsd/netinet/raw_ip.c"
            "ripcb"
        }
        symbol = "rip_init"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "%s in_pcbladdr(%p) error %d\n"
            "rip_output"
        }
        symbol = "rip_output"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "rip_unlock: bad refoucnt so=%p val=%x lrh= %s @%s:%d"
        }
        symbol = "rip_unlock"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "rip_attach @%s:%d"
        }
        symbol = "rip_attach"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "oldest_cache != NULL"
            "tcp_getcache_with_lock"
            "%s could not allocate cache"
        }
        symbol = "tcp_getcache_with_lock"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "__tcp_heuristic_tfo_middlebox_common"
            "%s disable TFO until %u now %u on %lx\n"
        }
        symbol = "__tcp_heuristic_tfo_middlebox_common"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "tcp_heuristic_ecn_aggressive_common"
            "%s disable ECN until %u now %u on %lx\n"
        }
        symbol = "tcp_heuristic_ecn_aggressive_common"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "oldest_heur != NULL"
            "tcp_getheuristic_with_lock"
            "%s could not allocate heuristic"
        }
        symbol = "tcp_getheuristic_with_lock"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "sysctl_cleartfo"
            "%s could not parse int: %d"
        }
        symbol = "sysctl_cleartfo"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "IPv6 bad tcp checksum"
            "src IPv6 address unspecified"
            "IPv4 bad tcp checksum"
            "bad tcp offset"
            "drop SYN FIN"
            "Connection attempt to TCP %s:%d from %s:%d\n"
            "Connection attempt to TCP %s:%d from %s:%d flags:0x%x\n"
            "Stealth Mode connection attempt to TCP %s:%d from %s:%d\n"
            "blackhole 1 syn for closed port"
            "blackhole 2 closed port"
            "blackhole closed port"
            "closed port"
            "inp_socket NULL"
            "inp state WNT_STOPUSING"
            "tp is NULL"
            "tp state TCPS_CLOSED"
            "rfc5961 TH_ACCEPT == 0"
            "closing a listening socket"
            "ignore SYN with RST"
            "ignore RST"
            "bad SYN with ACK"
            "bad SYN"
            "bad tuple same port"
            "bad tuple same IPv4 address"
            "mbuf M_BCAST | M_MCAST"
            "IN6_IS_ADDR_MULTICAST"
            "multicast or broadcast address"
            " listen drop"
            " in_pcbinshash failed"
            "tcp_input: could not copy policy\n"
            " cfil_sock_attach failed"
            "recwin_conn < INT32_MAX && recwin_conn > INT32_MIN"
            " LISTEN in6_pcbconnect failed"
            " LISTEN in_pcbconnect failed"
            "connect incoming"
            "SYN_RECEIVED bad ACK"
            "SYN_SENT bad ACK"
            "SYN_SENT got RST"
            "SYN_SENT no SYN"
            "ESTABLISHED rfc5961 challenge ACK"
            "SYN_RECEIVED bad SEQ"
            "SS_NOFDREF"
            "SOF_MP_SUBFLOW SS_NOFDREF"
            "SOF_DEFUNCT"
            "SS_CANTRCVMORE"
            "rfc5961 bad SYN rate limited"
            "rfc5961 bad SYN challenge ack"
            "LIST_EMPTY(&tp->t_segq)"
            "rfc5961 rcvacktoomuch"
            "rfc5961 bad ACK"
            "INPCB_STATE_DEAD"
            "%s 5-tuple does not match: %u:%u %u:%u\n"
            "17 {curProtocol: 100, prevProtocol: 80, localPort: %hu, remotePort: %hu, tcpSeq: %u, tcpAck: %u, tcpLen: %hu, tcpFlags: 0x%02x, pid: %hu, logSeqn: %hhu}"
            "TE_SENDIPECT flag is set but TCP_L4S_ENABLED is not"
        }
        symbol = "tcp_input"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "len <= TFO_COOKIE_LEN_MAX"
        }
        symbol = "tcp_tfo_synack"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "tcp_pulloutofband @%s:%d"
            "tcp_input.c"
        }
        symbol = "tcp_pulloutofband"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s: rtt is %d - maxing it at 4 x MSL\n"
        }
        symbol = "tcp_xmit_timer"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "tp->sackhint.sack_bytes_acked >= 0"
            "tp->sackhint.sack_bytes_rexmit >= 0"
            "flight_size (%d) can't be negative (snd_nxt:%u snd_max:%u, snd_una:%u, sacked:%u lost:%u retransmitted:%u)"
        }
        symbol = "tcp_flight_size"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "no source address silently ignored"
            "recwin_announced < INT32_MAX && recwin_announced > INT32_MIN"
            "sackoptlen < UINT8_MAX"
            "nsack == 0 || tp->rcv_numsacks >= nsack"
            "(u_char *)lp - opt <= MAX_TCPOPTLEN"
            "ECN flags (0x%x) not set correctly @%s:%d"
            "tcphdr too big @%s:%d"
            "error ENOBUFS silently handled"
            "error EMSGSIZE silently handled"
            "soft error %d silently handled"
            "error %d"
            "not enough space to add any AccECN option"
            "add empty AccECN option, optlen=%u"
            "add single counter for AccECN option, optlen=%u"
            "add 2 counters for AccECN option, optlen=%u"
            "add all 3 counters for AccECN option, optlen=%u"
            "%s - %lx: snd_nxt is %u and snd_una is %u, cnt %d\n"
            "%s - %lx: offset is negative! len %d off %d\n"
        }
        symbol = "tcp_output"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "flow controlled"
            "flow suspended"
        }
        symbol = "tcp_ip_output"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "num_sack_blks <= (TCP_MAX_SACK + 1)"
        }
        symbol = "tcp_sack_doack"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: Computed sack hole not the same as cached value\n"
            "tcp_sack_output"
            "%s: Computed sack_bytes_retransmitted (%d) not the same as cached value (%d)\n"
        }
        symbol = "tcp_sack_output"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "SEQ_GEQ(snd_fack, s->rxmit)"
        }
        symbol = "tcp_sack_detect_reordering"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "tcppcb"
            "WARNING: TCB hash size not a power of 2, scaled from %d to %d.\n"
            "tcp_init @%s:%d"
            "tcptimerlist"
            "com.apple.xnu.tcp"
            "MPKL_CREATE_LOGOBJECT failed @%s:%d"
            "tcp_log"
            "tcp_init: set tcp_log_enable_flags to 0x%x"
        }
        symbol = "tcp_init"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "(MHLEN - max_linkhdr) >= (sizeof(*ip6) + sizeof(*nth))"
            "(MHLEN - max_linkhdr) >= (sizeof(*ip) + sizeof(*nth))"
        }
        symbol = "tcp_respond"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "tcp_lock: so=%p NO PCB! lr=%p lrh= %s @%s:%d"
            "tcp_lock: so=%p so_pcb=%p lr=%p ref=%x lrh= %s @%s:%d"
        }
        symbol = "tcp_lock"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "tcp_unlock: so=%p usecount=%x lrh= %s @%s:%d"
            "tcp_unlock: so=%p NO PCB usecount=%x lr=%p lrh= %s @%s:%d"
        }
        symbol = "tcp_unlock"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "tcp_getlock: so=%p usecount=%x lrh= %s @%s:%d"
            "tcp_getlock: so=%p NULL so_pcb %s @%s:%d"
        }
        symbol = "tcp_getlock"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "tcp_rxtseg_insert"
            "removed rxseg list overflow %u:%u "
        }
        symbol = "tcp_rxtseg_insert"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "tcp_notify_kao_timeout"
            "%s: dropped lport %u fport %u\n"
        }
        symbol = "tcp_notify_kao_timeout"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "SLIST_EMPTY(&tp->t_notify_ack)"
        }
        symbol = "tcp_add_notify_ack_marker"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "skip ifp no fsw"
            "add err %d\n"
        }
        symbol = "tcp_add_fsw_flow"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "err == 0 || err == ENOENT || err == ENXIO"
            "tcp_del_fsw_flow"
            "del err %d\n"
        }
        symbol = "tcp_del_fsw_flow"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "tp != NULL"
        }
        symbol = "tcp_notify"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "tp->t_pmtud_saved_maxopd > 0"
        }
        symbol = "tcp_pmtud_revert_segment_size"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "FIN wait timeout drop"
            "retransmission timeout drop"
            "persist timeout drop"
            "keep alive timeout drop"
            "SACK_ENABLED(tp)"
            "%s: tcp_output() returned %u with retransmission timer disabled for %u > %u in state %d, reset timer to %d"
        }
        symbol = "tcp_timers"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "tcp_garbage_collect"
            "%s - %lx: Still inside %d usecount %d\n"
        }
        symbol = "tcp_garbage_collect"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "tp->tentry.index == TCPT_NONE || tp->tentry.mode > 0"
        }
        symbol = "tcp_run_timerlist"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "kern.skywalk.stats.flow"
            "kernel_sysctlbyname err %d\n"
            "kernel_sysctlbyname invalid len %zu\n"
        }
        symbol = "tcp_fill_info_for_info_tuple"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: so %p inp %p ifp NULL @%s:%d"
            "%s: so %p inp %p ifp %p if_tcp_kao_cnt == 0 @%s:%d"
        }
        symbol = "tcp_clear_keep_alive_offload"
        caller = "?"
    }
    new {
        args = 3
        anchors {
            "connect outgoing"
        }
        symbol = "tcp_usr_connect_common"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "tcp_connect: inp=0x%llx err=EADDRINUSE\n"
        }
        symbol = "tcp_connect"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "!(so->so_flags & SOF_MP_SUBFLOW) || (so->so_snd.sb_flags & SB_NOCOMPRESS)"
        }
        symbol = "tcp_usr_send"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "tp->t_ccstate->cub_origin_point > 0"
        }
        symbol = "tcp_cubic_congestion_avd"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "is_incr == false"
            "/AppleInternal/Library/BuildRoots/d3a62b52-2ef5-11ef-9ecd-e2437461156c/Library/Caches/com.apple.xbs/Sources/xnu/bsd/netinet/tcp_ledbat.c"
        }
        symbol = "update_cwnd"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "tcp_rack_update_segment_acked"
            "Spurious inference as either tsecr (%u) doesn't lie between xmit_ts(%u) and now (%u) OR the rtt (%u) is less than base-rtt (%u). end_seq is:%u"
        }
        symbol = "tcp_rack_update_segment_acked"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "outgoing "
            "incoming "
            "tcp drop %s[%s:%u<->%s:%u] interface: %s (skipped: %lu)\nso_gencnt: %llu t_state: %s process: %s:%u t_state: %s so_error: %d reason: %s"
        }
        symbol = "tcp_log_drop_pcb"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "outgoing"
            "tcp control %s %s%s%s%s[%s:%u<->%s:%u] interface: %s (skipped: %lu)\n"
            "tcp control %s %s%s%s%s[%s:%u<->%s:%u] interface: %s (skipped: %lu)\nso_gencnt: %llu t_state: %s process: %s:%u SYN in/out: %u/%u "
        }
        symbol = "tcp_log_th_flags"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "com.apple.network.tcp_ccdebug"
            "failed to register tcp_cc debug control"
        }
        symbol = "tcp_ccdbg_control_register"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "failed to disconnect tcp_cc debug control"
        }
        symbol = "tcp_ccdbg_control_disconnect"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "udp_log"
            "udppcb"
            "udp_init: set udp_log_enable_flags to 0x%x"
        }
        symbol = "udp_init"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s: bad so back ptr inp=%p @%s:%d"
            "udp_input"
            "Stealth Mode connection attempt to UDP %s:%d from %s:%d\n"
        }
        symbol = "udp_input"
        caller = "?"
    }
    new {
        args = 4
        anchors {
            "outif == NULL"
            "inp->inp_boundifp != NULL"
        }
        symbol = "udp_output"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "udp_abort"
        }
        symbol = "udp_abort"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s so=%p inp=%p @%s:%d"
            "udp_attach"
        }
        symbol = "udp_attach"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "udp_detach"
        }
        symbol = "udp_detach"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "udp_unlock"
        }
        symbol = "udp_unlock"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: so=%p NULL so_pcb lrh= %s @%s:%d"
            "udp_getlock"
        }
        symbol = "udp_getlock"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s[%d, %s]: defuncting so 0x%llu drop multicast memberships"
            "udp_defunct"
        }
        symbol = "udp_defunct"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "ENOBUFS in in_gif_output %d\n"
        }
        symbol = "in_gif_output"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "NULL pointer passed to ip_ecn_egress @%s:%d"
        }
        symbol = "ip_ecn_egress"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "NULL pointer passed to ip6_ecn_ingress @%s:%d"
        }
        symbol = "ipsec6_encapsulate"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "NULL pointer passed to ip46_ecn_egress @%s:%d"
        }
        symbol = "ip46_ecn_egress"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "NULL pointer passed to ip64_ecn_ingress @%s:%d"
        }
        symbol = "ipsec64_encapsulate"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "NULL pointer passed to ip64_ecn_egress @%s:%d"
        }
        symbol = "ip64_ecn_egress"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "/AppleInternal/Library/BuildRoots/d3a62b52-2ef5-11ef-9ecd-e2437461156c/Library/Caches/com.apple.xbs/Sources/xnu/bsd/netinet/ip_encap.c"
        }
        symbol = "m_tag_kalloc_encap"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "kipf_ref overflow @%s:%d"
        }
        symbol = "ipf_ref"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "kipf_ref underflow @%s:%d"
        }
        symbol = "ipf_unref"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "g_tcp_protosw != NULL"
            "g_udp_protosw != NULL"
            "g_tcp6_protosw != NULL"
            "g_udp6_protosw != NULL"
            "com.apple.flow-divert"
            "(%u): flow_divert_kctl_init - ctl_register failed: %d\n\n"
        }
        symbol = "flow_divert_init"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "flow divert group %u is disconnecting, but no groups are active (active count = %u) @%s:%d"
            "flow divert group %u is disconnecting, but groups array is NULL @%s:%d"
            "group with unit %d (%p) != unit info (%p) @%s:%d"
            "flow divert group %u is disconnecting, but in-process group list is empty @%s:%d"
            "(%u): disconnecting group %d\n"
        }
        symbol = "flow_divert_kctl_disconnect"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "/AppleInternal/Library/BuildRoots/d3a62b52-2ef5-11ef-9ecd-e2437461156c/Library/Caches/com.apple.xbs/Sources/xnu/bsd/netinet/mp_proto.c"
        }
        symbol = "mp_dinit"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: mppi %p already in the list @%s:%d"
            "mp_pcbinfo_attach"
            "mp_pcb.c"
        }
        symbol = "mp_pcbinfo_attach"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "mpsotomppcb(so) == NULL"
        }
        symbol = "mp_pcballoc"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "mpp->mpp_state == MPPCB_STATE_DEAD"
            "mppi->mppi_count != 0"
            "mptcp_pcbdispose"
            "mpp->mpp_inside == 0"
            "mpp->mpp_socket != NULL"
            "mpp->mpp_socket->so_usecount == 0"
            "%s: No more MPTCP-flows, but cell icon counter is %u\n"
        }
        symbol = "mptcp_pcbdispose"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "mbuf invalid: %p @%s:%d"
            "mptcp.c"
            "iter == NULL || iter->m_flags & M_PKTHDR"
            "mptcp_input"
            "(mp_tp->mpt_rcvnxt - mb_dsn) <= INT_MAX"
            "mb_datalen >= 0 && mb_datalen <= USHRT_MAX"
            "%s - %lx: dropping dsn %u dlen %u rcvnxt %u rcvwnd %u todrop %lld\n"
        }
        symbol = "mptcp_input"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "!(mpte->mpte_mppcb->mpp_flags & MPP_WUPCALL)"
            "mptcp_output"
            "%s - %lx: Error = %d mpts_flags %#x\n"
        }
        symbol = "mptcp_output"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "mptcp_update_rcv_state_meat"
            "%s - %lx: Infinite Mapping.\n"
            "%s - %lx: Bad checksum %x \n"
        }
        symbol = "mptcp_update_rcv_state_meat"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "mpp->mpp_flags & flag"
        }
        symbol = "mptcp_handle_deferred_upcalls"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "ifindex != IFSCOPE_NONE"
            "mptcp_session_necp_cb"
            "slot_index >= 0 && slot_index < (int)mpte->mpte_itfinfo_size"
            "%s - %lx: action: %u ifindex %u delegated to %u usecount %u mpt_flags %#x state %u v4 %u v6 %u nat64 %u power %u\n"
            "%s - %lx: malloc failed for %u\n"
        }
        symbol = "mptcp_session_necp_cb"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "real_len >= 0"
        }
        symbol = "mptcp_validate_csum"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "mpp != NULL"
            "mpp->mpp_pcbe == NULL"
        }
        symbol = "mptcp_session_create"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "handover"
            "pure-handover"
            "j < NAT64_MAX_NUM_PREFIXES"
            "%s - %lx: not a good time for subflows, state %u flags %#x"
            "%s - %lx: %s: cell %u wifi-state %d flags %#x rxt %u first-party %u sb_cc %u ifindex %u this %u rtt %u rttvar %u rto %u\n"
            "%s - %lx: target-based: %llu now %llu wifi quality %d cell %u sostat %#x mpts_flags %#x tcp-state %u\n"
            "%s - %lx: no NAT64-prefix on itf %s, error %d\n"
            "%s - %lx: cannot synthesize this addr\n"
            "%s - %lx: asked irat to bringup cell for uuid %s, err %d\n"
            "%s - %lx: UUID is already null\n"
        }
        symbol = "mptcp_check_subflows_and_add"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "mptcp_sched_create_subflows"
        }
        symbol = "mptcp_sched_create_subflows"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "!(mpts->mpts_flags & (MPTSF_CONNECTING | MPTSF_CONNECTED | MPTSF_CONNECT_PENDING))"
            "%s - %lx: state %u\n"
            "%s - %lx: malloc subflow failed\n"
        }
        symbol = "mptcp_subflow_add"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "mpts->mpts_mpte == mpte"
            "mpte->mpte_numflows != 0"
        }
        symbol = "mptcp_subflow_del"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "mptcp_subflow_disconnect"
            "%s - %lx: sosetdefunct failed with %d\n"
        }
        symbol = "mptcp_subflow_disconnect"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "!(mpte->mpte_mppcb->mpp_flags & MPP_INSIDE_OUTPUT)"
            "!INP_WAIT_FOR_IF_FEEDBACK(sotoinpcb(so))"
            "(mpts->mpts_flags & MPTSF_MP_CAPABLE) || (mpts->mpts_flags & MPTSF_MP_DEGRADED) || (mpts->mpts_flags & MPTSF_TFO_REQD)"
            "mptcp_subflow_cwnd_space(mpts->mpts_socket) > 0"
            "sb_mb->m_pkthdr.pkt_flags & PKTF_MPTCP"
            "(mpt_mbuf == NULL) || (mpt_mbuf->m_pkthdr.pkt_flags & PKTF_MPTCP)"
            "m->m_next == NULL"
            "so_m->m_flags & M_PKTHDR"
            "so_m->m_pkthdr.pkt_flags & PKTF_MPTCP"
            "%s - %lx: No data in MPTCP-sendbuffer! smax %u snxt %u suna %u state %u flags %#x\n"
            "%s - %lx: dropping data, should have been done earlier dsn %u suna %u reinject? %u\n"
            "%s - $%lx: send-buffer is empty\n"
            "%s - %lx: dropping data in degraded mode, should have been done earlier dsn %u sndnxt %u suna %u\n"
            "%s - %lx: send-buffer is still empty\n"
            "%s - %lx: this should not happen: sndnxt %u sndmax %u\n"
            "%s - %lx: sb_cc is %d, mp_so->sb_cc %u, sndwnd %u,sndnxt %u sndmax %u cwnd %u\n"
            "%s - %lx: mlen %d mp_rlen %u off %u sb_cc %u tot_sent %u\n"
            "%s - %lx: m_copym_mode failed\n"
            "%s - %lx: %u error %d len %d subflags %#x sostate %#x soerror %u hiwat %u lowat %u\n"
        }
        symbol = "mptcp_subflow_output"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "mptcp_subflow_sosetopt"
            "%s - %lx: sopt %s val %d set error %d\n"
        }
        symbol = "mptcp_subflow_sosetopt"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "mptcp_subflow_sogetopt"
            "%s - %lx: sopt %s get error %d\n"
        }
        symbol = "mptcp_subflow_sogetopt"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "mpsofilt_hint_mask & SO_FILT_HINT_LOCKED"
            "(so->so_state & (SS_NBIO | SS_NOFDREF)) == (SS_NBIO | SS_NOFDREF)"
        }
        symbol = "mptcp_subflow_workloop"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s: so=%p so_pcb=%p lr=%p ref=%x lrh= %s @%s:%d"
        }
        symbol = "mptcp_lock"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s: so=%p NO PCB usecount=%x lr=%p lrh= %s @%s:%d"
            "%s: mpp=%p inside=%x lrh= %s @%s:%d"
        }
        symbol = "mptcp_unlock"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: so=%p NULL so_pcb %s @%s:%d"
        }
        symbol = "mptcp_getlock"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "m_pktlen(m) >= 0 && m_pktlen(m) < UINT16_MAX"
        }
        symbol = "mptcp_insert_dsn"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "!(m->m_pkthdr.pkt_flags & PKTF_MPTCP)"
        }
        symbol = "mptcp_insert_rmap"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "mptcp_get_map_for_dsn"
            "%s: %llu not found \n"
        }
        symbol = "mptcp_get_map_for_dsn"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "off >= mdss_subflow_off"
        }
        symbol = "mptcp_adj_sendlen"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "prp != NULL"
            "prp6 != NULL"
            "mppcb"
            "com.apple.xnu.net.mptcp"
        }
        symbol = "mptcp_init"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "mptcpstats_get_index"
            "%s - %lx: no ifp on subflow, state %u flags %#x\n"
        }
        symbol = "mptcpstats_get_index"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "mptcp_pure_handover_subflows_remove"
            "mptcp_remove_wifi_subflows"
            "mptcp_handover_subflows_remove"
            "%s - %lx: rxt %u sb_cc %u wifi quality %d\n"
            "%s - %lx: Found Wi-Fi: %u Found Cellular %u"
            "%s - %lx: removing wifi subflow\n"
        }
        symbol = "mptcp_check_subflows_and_remove"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "mptcp_remove_cell_subflows"
            "%s - %lx: removing cell subflow\n"
        }
        symbol = "mptcp_remove_cell_subflows"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "mptcp_create_subflows"
            "%s: bit was already cleared!\n"
        }
        symbol = "mptcp_create_subflows"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "mptcp_remove_subflows"
            "%s - %lx: itf %u close_reqd last itf %d\n"
            "%s - %lx: itf %u killing %#x\n"
        }
        symbol = "mptcp_remove_subflows"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "mptcp_subflow_necp_cb"
            "%s - %lx: Subflow on itf %u became non-viable, power %u"
        }
        symbol = "mptcp_subflow_necp_cb"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "(mpts->mpts_flags & (MPTSF_CONNECTING | MPTSF_CONNECTED)) == MPTSF_CONNECTING"
            "%s - %lx: ifindex %u dst %s:%d pended %u\n"
            "%s - %lx: connectx failed with error %d ifscope %u\n"
        }
        symbol = "mptcp_subflow_soconnectx"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "mpts->mpts_refcnt == 0"
            "mpts->mpts_mpte == NULL"
            "mpts->mpts_socket == NULL"
        }
        symbol = "mptcp_subflow_free"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "!(mpte->mpte_mppcb->mpp_flags & MPP_INSIDE_INPUT)"
            "mptcp_subflow_input"
            "%s - %lx: cid %d error %d\n"
        }
        symbol = "mptcp_handle_input"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "(n->m_flags & M_PKTHDR) && (n->m_pkthdr.pkt_flags & PKTF_MPTCP)"
            "mptcp_copy_mbuf_list"
            "n->m_flags & M_PKTHDR"
            "n->m_next == NULL"
            "n->m_pkthdr.mp_dsn == dsn"
            "n->m_pkthdr.mp_rlen == dlen"
            "n->m_pkthdr.mp_rseq == rseq"
            "n->m_len == m->m_len"
            "%s - %lx\n"
            "%s - %lx no alternate path\n"
            "%s - %lx: switched from %d to %d\n"
            "%s - %lx: m_copym_mode returned NULL\n"
            "%s - %lx: dsn %u dlen %u rseq %u fully covered with len %u\n"
            "%s - %lx: m (dsn %u len %u) is covering existing mbuf (dsn %u len %u)\n"
            "%s - %lx: prev (dsn %u len %u) covers us (dsn %u len %u)\n"
        }
        symbol = "mptcp_subflow_failover_ev"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "mp_droplen <= (UINT_MAX)"
            "mp_droplen >= tcp_droplen"
            "mp_so->so_snd.sb_mb != NULL"
            "mptcp_desynthesize_ipv6_addr"
            "%s - %lx: desynthesized to %s\n"
        }
        symbol = "mptcp_subflow_connected_ev"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "mp_tp->mpt_version == MPTCP_VERSION_0 || mp_tp->mpt_version == MPTCP_VERSION_1"
        }
        symbol = "mptcp_init_local_parms"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "mptcp_symptoms_ctl_connect"
            "%s: MPTCP kernel-control socket for Symptoms already open!"
        }
        symbol = "mptcp_symptoms_ctl_connect"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "mptcp_allow_uuid"
            "%s: kcunit %u is different from expected one %u\n"
            "%s: mbuf is %lu but need %lu\n"
            "%s: wifi new,old: %d,%d, cell new, old: %d,%d\n"
            "%s: mbuf is %lu but need %lu or %lu\n"
            "%s: mbuf_copydata returned %d\n"
            "%s - %lx: Got allowance for useApp with rssi %d\n"
        }
        symbol = "mptcp_symptoms_ctl_send"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "val < INT32_MAX"
            "%s - %lx: Cell is off, but should be at least %u\n"
            "%s - %lx: Increments is %u but want to dec by %u.\n"
            "%s - %lx: Inconsistent state! Cell refcount is zero but increments are at %u\n"
        }
        symbol = "mptcp_unset_cellicon"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "so->so_proto->pr_flags & PR_CONNREQUIRED"
            "mptcp_subflow_soreceive 2"
            "m_pktlen(m) < UINT16_MAX"
            "%s - %lx: No DSS on secondary subflow. Killing %d\n"
            "%s - %lx: Received more than 64KB without DSS mapping. Killing %d\n"
            "%s - %lx: Received incorrect second mapping: DSN: %u - %u , SSN: %u - %u, DLEN: %u - %u, DFIN: %u - %u\n"
            "%s - %lx: m_split failed dlen %u dfin %u off %d pktlen %d, killing subflow %d"
        }
        symbol = "mptcp_subflow_soreceive"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "addr == NULL"
            "uio == NULL"
            "flags == 0"
            "(so->so_flags & SOF_CONTENT_FILTER) == 0"
            "top->m_pkthdr.len > 0 && top->m_pkthdr.len <= UINT16_MAX"
            "top->m_pkthdr.pkt_flags & PKTF_MPTCP"
        }
        symbol = "mptcp_subflow_sosend"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s - %lx: skipped state [u=%d,r=%d,s=%d]\n @%s:%d"
            "mptcp_gc"
            "TAILQ_EMPTY(&mpte->mpte_subflows) && mpte->mpte_numflows == 0"
            "mptcp_session_destroy"
            "TAILQ_EMPTY(&mpte->mpte_sopts)"
            "%s - %lx: Destroying session\n"
        }
        symbol = "mptcp_gc"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "mptcpstats_get_bytes"
            "%s - %lx: cellbytes is %lld\n"
        }
        symbol = "mptcpstats_get_bytes"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "SO_LINGER"
            "SO_LINGER_SEC"
            "SO_DEBUG"
            "SO_KEEPALIVE"
            "SO_USELOOPBACK"
            "SO_TYPE"
            "SO_NREAD"
            "SO_NWRITE"
            "SO_ERROR"
            "SO_SNDBUF"
            "SO_RCVBUF"
            "SO_SNDLOWAT"
            "SO_RCVLOWAT"
            "SO_SNDTIMEO"
            "SO_RCVTIMEO"
            "SO_NKE"
            "SO_NOSIGPIPE"
            "SO_NOADDRERR"
            "SO_RESTRICTIONS"
            "SO_LABEL"
            "SO_PEERLABEL"
            "SO_RANDOMPORT"
            "SO_TRAFFIC_CLASS"
            "SO_RECV_TRAFFIC_CLASS"
            "SO_TRAFFIC_CLASS_DBG"
            "SO_PRIVILEGED_TRAFFIC_CLASS"
            "SO_DEFUNCTIT"
            "SO_DEFUNCTOK"
            "SO_ISDEFUNCT"
            "SO_OPPORTUNISTIC"
            "SO_FLUSH"
            "SO_RECV_ANYIF"
            "SO_NOWAKEFROMSLEEP"
            "SO_NOAPNFALLBK"
            "SO_CELLFALLBACK"
            "SO_FALLBACK_MODE"
            "SO_MARK_KNOWN_TRACKER"
            "SO_MARK_KNOWN_TRACKER_NON_APP_INITIATED"
            "SO_MARK_APPROVED_APP_DOMAIN"
            "SO_DELEGATED"
            "SO_DELEGATED_UUID"
            "SO_NECP_ATTRIBUTES"
            "SO_NECP_CLIENTUUID"
            "IP_TOS"
            "IPV6_TCLASS"
            "TCP_NODELAY"
            "TCP_KEEPALIVE"
            "TCP_KEEPINTVL"
            "TCP_KEEPCNT"
            "TCP_CONNECTIONTIMEOUT"
            "TCP_RXT_CONNDROPTIME"
            "PERSIST_TIMEOUT"
            "NOTSENT_LOWAT"
            "ADAPTIVE_READ_TIMEOUT"
            "ADAPTIVE_WRITE_TIMEOUT"
            "TCP_FASTOPEN_FORCE_ENABLE"
            "MPTCP_SERVICE_TYPE"
            "MPTCP_ALTERNATE_PORT"
            "MPTCP_FORCE_ENABLE"
            "MPTCP_FORCE_VERSION"
            "MPTCP_EXPECTED_PROGRESS_TARGET"
        }
        symbol = "mptcp_sopt2str"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "mpsotomppcb(mp_so) == NULL"
        }
        symbol = "mptcp_usr_attach"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "mptcp_usr_detach"
            "%s - %lx: state: %d\n"
        }
        symbol = "mptcp_usr_detach"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "mptcp_entitlement_check"
            "%s - %lx: MPTCP prohibited on svc %u\n"
        }
        symbol = "mptcp_entitlement_check"
        caller = "?"
    }
    new {
        args = 5
        anchors {
            "pcid != NULL"
            "%s - %lx: state %d\n"
            "%s - %lx: fell back to TCP\n"
            "%s - %lx: IPv4 dst len %u\n"
            "%s - %lx: IPv6 dst len %u\n"
            "%s - %lx: IPv4 src len %u\n"
            "%s - %lx: IPv6 src len %u\n"
        }
        symbol = "mptcp_usr_connectx"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "mp_so->so_snd.sb_flags & SB_NOCOMPRESS"
        }
        symbol = "mptcp_usr_send"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "mp_so->so_type == SOCK_STREAM"
            "!(mp_so->so_flags & SOF_MP_SUBFLOW)"
            "top != NULL"
            "top != NULL && *top == NULL"
            "mb->m_flags & M_PKTHDR"
            "progress == tot"
        }
        symbol = "mptcp_usr_sosend"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "sopt->sopt_level == SOL_SOCKET"
        }
        symbol = "mptcp_usr_socheckopt"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "mpo != &smpo"
            "TAILQ_EMPTY(&mpte->mpte_subflows)"
            "mpts->mpts_oldintval == 0"
            "%s - %lx: Can't set urgent activity when svctype is %u\n"
            "%s - %lx: Not ok to create subflows, state %u flags %#x\n"
            "%s - %lx: Not rescheduling timer %llu now %llu target %llu\n"
            "%s - %lx: sopt %s (%d, %d) val %d can't be issued error %d\n"
        }
        symbol = "mptcp_ctloutput"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "mptcp_usr_preconnect"
            "%s - %lx: invalid preconnect "
        }
        symbol = "mptcp_usr_preconnect"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: no space left %d \n"
            "mptcp_setup_join_ack_opts"
        }
        symbol = "mptcp_setup_join_ack_opts"
        caller = "?"
    }
    new {
        args = 3
        anchors {
            "optlen too large @%s:%d"
            "%s - %lx: no space left %d flags %x tp->t_mpflags %x len %d\n"
            "%s - %lx: not enough space in TCP option, optlen: %u, mmco_len: %d\n"
            "%s: dssoptlen %d optlen %d \n"
            "%s: nosp %d len %d opt %d %d %d\n"
        }
        symbol = "mptcp_setup_opts"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "acked <= INT_MAX"
            "mptcp_data_ack_rcvd"
            "%s - %lx: acked %u, sb_cc %u full %u suna %u state %u\n"
        }
        symbol = "mptcp_data_ack_rcvd"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "mptcp_setup_first_subflow_syn_opts"
            "%s - %lx: Not doing MPTCP due to heuristics"
        }
        symbol = "mptcp_setup_syn_opts"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "mptcp_sanitize_option"
            "mptcp_do_mpcapable_opt"
            "%s: remote key %llx local key %llx remote rand %x local rand %x \n"
            "mptcp_validate_join_hmac"
            "%s - %lx: type = %d \n"
            "%s - %lx: SYN_ACK optlen = %u, sizeof mp opt = %lu \n"
            "local version: %d > peer version %d"
            "%s - %lx: SYN_ACK: unexpected optlen = %u mp option = %lu\n"
            "%s - %lx: SYN_ACK error = %d \n"
            "%s - %lx: bad len = %d dss: %x\n"
        }
        symbol = "tcp_do_mptcp_options"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "mptcp_set_urgency_timer"
            "%s - %lx: timer at %llu now %llu usecount %u ret %u\n"
        }
        symbol = "mptcp_set_urgency_timer"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "mptcp_timer_demux"
            "%s: REXMT %d sndnxt %u\n"
        }
        symbol = "mptcp_timer"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "mp_so->so_usecount >= 0"
            "mptcp_urgency_timer"
            "%s - %lx: timer at %llu now %llu usecount %u\n"
        }
        symbol = "mptcp_urgency_timer"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "mptcp_urgency_stop"
            "%s - %lx: usecount %u\n"
        }
        symbol = "mptcp_urgency_stop"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "mptcp_cancel_urgency_timer"
            "%s - %lx: Canceled timer thread usecount %u ret %u\n"
        }
        symbol = "mptcp_cancel_all_timers"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "/AppleInternal/Library/BuildRoots/d3a62b52-2ef5-11ef-9ecd-e2437461156c/Library/Caches/com.apple.xbs/Sources/xnu/bsd/netinet6/ah_core.c"
            "ah_hmac_loop: what? @%s:%d"
            "len <= UINT_MAX"
        }
        symbol = "ah_hmac_loop"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "ah_hmac_state_init: what? @%s:%d"
            "ah_hmac_state_init: unsupported algorithm.\n"
        }
        symbol = "ah_hmac_state_init"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "ah_hmac_result: what? @%s:%d"
        }
        symbol = "ah_hmac_result"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "ah_update_mbuf: wrong offset specified @%s:%d"
        }
        symbol = "ah_update_mbuf"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "(off + sizeof(struct ah) + sizoff + siz1) <= INT_MAX"
            "/AppleInternal/Library/BuildRoots/d3a62b52-2ef5-11ef-9ecd-e2437461156c/Library/Caches/com.apple.xbs/Sources/xnu/bsd/netinet6/ah_input.c"
            "IPv4 AH input: can't pullup;dropping the packet for simplicity\n"
            "IPv4 AH input: no key association found for spi %u\n"
            "IPv4 AH input: non-mature/dying SA found for spi %u\n"
            "IPv4 AH input: unsupported authentication algorithm for spi %u\n"
            "sum length too short in IPv4 AH input (%u, should be at least %u): %s\n"
            "sum length mismatch in IPv4 AH input (%d should be %u): %s\n"
            "IPv4 AH input: can't pullup\n"
            "replay packet in IPv4 AH input: %s %s\n"
            "IPv4 AH input: couldn\\'t alloc temporary region for cksum\n"
            "IPv4 AH input: bad length ip header len %u, total len %u\n"
            "checksum mismatch in IPv4 AH input: %s %s\n"
            "ipsec tunnel protocol mismatch in IPv4 AH input: %s\n"
        }
        symbol = "ah4_input"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "ah_output.c"
            "ah4_output: assumption failed (first mbuf length) @%s:%d"
            "ah4_output: internal error: sav->replay is null: %x->%x, SPI=%u\n"
            "ah4_output: unsupported algorithm: SPI=%u\n"
            "ENOBUFS in ah4_output %d\n"
            "replay counter overflowed. %s\n"
            "IPv4 AH output: size exceeds limit\n"
            "error after ah4_calccksum, called from ah4_output"
            "ah4_finaldst: parameter mbuf wrong (not pulled up)\n"
            "ah4_finaldst: wrong optlen %d\n"
            "ip_finaldst: invalid IP option (code=%02x len=%02x)\n"
        }
        symbol = "ah4_output"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "mbuf chain? @%s:%d"
            "esp_auth: mbuf length < skip\n"
            "esp_auth: mbuf length < skip + length\n"
            "esp_auth: length is not multiple of 4\n"
            "esp_auth: NULL SA passed\n"
            "esp_auth: bad ESP auth algorithm passed: %d\n"
            "esp_auth: AH_MAXSUMSIZE is too small: siz=%u\n"
        }
        symbol = "esp_auth"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s:%d out_auth is NULL @%s:%d"
            "algo != NULL"
            "%s:%d esp auth: auth size=%zu is lesser than siz=%zu SPI 0x%08x\n"
            "%s:%d esp auth: algo init failed with error %d, SPI 0x%08x\n"
            "%s:%d esp auth: input data length %zu is not a multiple 4, SPI 0x%08x\n"
        }
        symbol = "esp_auth_data"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "com.apple.xnu.esp"
            "MPKL_CREATE_LOGOBJECT for ESP failed @%s:%d"
        }
        symbol = "key_init"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s:%d payload length %zu must be a multiple of ESP_CBC_DES_BLOCKLEN, SPI 0x%08x"
        }
        symbol = "esp_cbc_des_encrypt_data"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "esp_common_ivlen: unknown algorithm @%s:%d"
        }
        symbol = "esp_common_ivlen"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s:%d payload length %zu must be a multiple of ESP_CBC_3DES_BLOCKLEN, SPI 0x%08x"
        }
        symbol = "esp_cbc_3des_encrypt_data"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "siz <= USHRT_MAX"
            "IPv4 ESP input: packet alignment problem (off=%d, pktlen=%d)\n"
            "IPv4 ESP input: can't pullup in esp4_input\n"
            "IPv4 ESP input: invalid protocol type\n"
            "IPv4 ESP input: no key association found for spi %u (0x%08x)\n"
            "IPv4 ESP input: non-mature/dying SA found for spi %u (0x%08x)\n"
            "IPv4 ESP input: unsupported encryption algorithm for spi %u (0x%08x)\n"
            "inproper ivlen in IPv4 ESP input: %s %s\n"
            "replay packet in IPv4 ESP input: seq(%u) idx(%u) %s %s\n"
            "invalid ESP packet length %u, missing ICV\n"
            "internal error: AH_MAXSUMSIZE must be larger than %u\n"
            "auth fail in IPv4 ESP input: %s %s\n"
            "cc_cmp fail in IPv4 ESP input: %s %s\n"
            "IPv4 ESP input: packet too short\n"
            "decrypt fail in IPv4 ESP input: %s\n"
            "esp4 packet decryption ICV failure: %s\n"
            "bad pad length in IPv4 ESP input: %s %s\n"
            "IPv4 ESP input: invalid udp encapsulated ESP packet length \n"
            "ipsec tunnel unsupported address family in ESP input\n"
            "no input interface for ipsec wake packet\n"
            "IPv4 ESP input: can't pullup UDP header in esp4_input\n"
            "IPv4 ESP input: decrypted packet too short %d < %u\n"
        }
        symbol = "esp4_input_extended"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "siz <= UINT16_MAX"
            "esplen + ivlen <= UINT16_MAX"
            "esp6_input: mbuf allocation failed\n"
            "IPv6 ESP input: packet alignment problem (off=%d, pktlen=%d)\n"
            "IPv6 ESP input: ESP with IPv6 jumbogram is not supported.\n"
            "IPv6 ESP input: invalid protocol type\n"
            "IPv6 ESP input: no key association found for spi %u (0x%08x) seq %u src %s dst %s if %s\n"
            "IPv6 ESP input: non-mature/dying SA found for spi %u (0x%08x)\n"
            "IPv6 ESP input: unsupported encryption algorithm for spi %u (0x%08x)\n"
            "improper ivlen in IPv6 ESP input: %s %s\n"
            "replay packet in IPv6 ESP input: seq(%u) idx(%u) %s %s\n"
            "auth fail in IPv6 ESP input: %s %s\n"
            "IPv6 ESP input: packet too short\n"
            "decrypt fail in IPv6 ESP input: %s\n"
            "esp6 packet decryption ICV failure: %s\n"
            "bad pad length in IPv6 ESP input: %s %s\n"
            "IPv6 ESP input: invalid udp encapsulated ESP packet length\n"
        }
        symbol = "esp6_input_extended"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s:%d esp kpipe input, ipversion %u, SPI=%x"
            "%s:%d esp kpipe input, sah is NULL\n"
            "%s:%d ipsec tunnel mode not supported in kpipe mode, SPI=%x\n"
            "%s:%d sadb flag %x not supported in kpipe mode, SPI=%x\n"
            "%s:%d esp kpipe input, invalid SA state %u, SPI=%x"
            "%s:%d esp kpipe input, missing replay window, SPI=%x\n"
            "%s:%d esp kpipe input, unsupported algorithm(%d) for, SPI=%x"
            "esp kpipe input: invalid ivlen(%d) SPI=%x @%s:%d"
            "auth_size < AH_MAXSUMSIZE"
            "e_algo->decrypt_pkt"
            "%s:%d esp kpipe input, jumbogram not supported"
            "%s:%d esp kpipe input, output buffer is short(%u), compared to input buffer(%u) SPI=%x\n"
            "%s:%d esp kpipe input, invalid nxt proto %u"
            "%s:%d esp kpipe input, slen too short %u"
            "%s:%d esp kpipe input, no SA found for SPI=%x, packet %s<->%s"
            "%s:%d esp kpipe input, replay packet, seq(%u), idx(%u), SPI=%x\n"
            "%s:%d esp kpipe input, input buffer does not contain auth, SPI=%x\n"
            "%s:%d esp kpipe input, esp auth data failed, SPI=%x\n"
            "%s:%d esp kpipe input, auth compare failed, SPI=%x\n"
            "%s:%d esp kpipe input, input buffer is short(%u), to contain ivlen and esptail SPI=%x\n"
            "%s:%d esp kpipe input: decryption failed, SPI=%x\n"
            "%s:%d esp kpipe input: ICV failed, SPI=%x\n"
            "%s:%d esp kpipe input: update replay failed, SPI=%x\n"
            "%s:%d esp kpipe input: encrypted payload len %u, is invalid, taillen %zu, SPI=%x\n"
        }
        symbol = "esp_kpipe_input"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "sav->sah->saidx.mode == IPSEC_MODE_TRANSPORT"
            "(sav->flags & (SADB_X_EXT_OLD | SADB_X_EXT_DERIV | SADB_X_EXT_NATT | SADB_X_EXT_NATT_MULTIPLEUSERS | SADB_X_EXT_CYCSEQ | SADB_X_EXT_PMASK)) == 0"
            "esp kpipe output, ipversion %u, SPI=%x @%s:%d"
            "%s:%d esp kpipe output, slen(%u) <= iphlen(%zu) SPI=%x\n"
            "%s:%d esp kpipe output, missing replay window, SPI=%x\n"
            "%s:%d esp kpipe output: unsupported algorithm, SPI=%x\n"
            "invalid ivlen(%d) SPI=%x @%s:%d"
            "extendsiz <= UINT8_MAX"
            "auth size %zu greater than AH_MAXSUMSIZE @%s:%d"
            "%s:%d esp kpipe output: destination buffer too short"
            "%s:%d esp kpipe output: source buffer too short"
            "%s:%d esp kpipe output: ipv4 packet size exceeded, ip payload len %u, SPI=%x\n"
            "%s:%d esp kpipe output: ipv6 packet size exceeded, ip payload len %u, SPI=%x\n"
            "%s:%d replay counter overflowed, SPI=%x\n"
            "esp kpipe output: missing algo encrypt pkt @%s:%d"
            "%s:%d esp encrypt failed %d, SPI=%x\n"
            "%s:%d esp finalize encrypt failed %d, SPI=%x\n"
            "%s:%d esp auth data failed %d, SPI=%x\n"
        }
        symbol = "esp_kpipe_output"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "esp_output: should not reach here @%s:%d"
            "invalid ivlen @%s:%d"
            "esphlen <= INT32_MAX"
            "extendsiz <= INT_MAX"
            "(extendsiz - 2) <= UINT8_MAX"
            "internal error: no encrypt function @%s:%d"
            "assertion failed for AH_MAXSUMSIZE @%s:%d"
            "(plen + siz + extendsiz + esphlen) <= UINT16_MAX"
            "esp_output: unsupported af %d\n"
            "esp4_output: internal error: sav->replay is null: %x->%x, SPI=%u\n"
            "esp6_output: internal error: sav->replay is null: SPI=%u\n"
            "esp_output: unsupported algorithm: SPI=%u\n"
            "esp%d_output: md is not in chain\n"
            "IPv4 ESP output: size exceeds limit\n"
            "esp%d_output: can't alloc mbuf"
            "packet encryption failure\n"
            "packet encryption ICV failure\n"
            "ESP checksum generation failure\n"
            "can't alloc mbuf in esp%d_output"
            "18 {curProtocol: 80, spi: 0x%X, espSeq: %u, PayloadProtocol: 100, localPort: %hu, remotePort: %hu, tcpSeq: %u, tcpAck: %u, tcpLen: %hu, tcpFlags: 0x%02x}"
        }
        symbol = "esp_output"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "out_ivlen == AES_BLOCKLEN"
            "%s:%d payload length %zu must be multiple of AES_BLOCKLEN, SPI 0x%08x"
        }
        symbol = "esp_aes_cbc_encrypt_data"
        caller = "?"
    }
    new {
        args = 3
        anchors {
            "%s:%d ivlen(%zu) != AES_BLOCKLEN, SPI 0x%08x"
            "%s:%d input data length(%zu) must be a multiple of AES_BLOCKLEN"
        }
        symbol = "esp_aes_cbc_decrypt_data"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "esp_gcm_ivlen: unknown algorithm @%s:%d"
        }
        symbol = "esp_gcm_ivlen"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s:%d Context reset failure %d, SPI 0x%08x\n"
            "%s:%d Set IV failure %d, SPI 0x%08x\n"
            "%s:%d IV generation failure %d, SPI 0x%08x\n"
            "%s:%d Set AAD failure %d, SPI 0x%08x\n"
            "%s:%d Packet encryption IV AAD failure %d, SPI 0x%08x\n"
            "%s:%d set aad failure %d, SPI 0x%08x\n"
            "%s:%d encrypt failure %d, SPI 0x%08x\n"
        }
        symbol = "esp_aes_gcm_encrypt_data"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s:%d iv is NULL @%s:%d"
            "%s:%d set iv failure %d, SPI 0x%08x\n"
            "%s:%d decrypt failure %d, SPI 0x%08x\n"
        }
        symbol = "esp_aes_gcm_decrypt_data"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s:%d ChaChaPoly is incompatible with SADB_X_EXT_OLD, SPI 0x%08x"
            "%s:%d ChaChaPoly is incompatible with SADB_X_EXT_DERIV, SPI 0x%08x"
            "%s:%d ChaChaPoly unsupported algorithm %d, SPI 0x%08x"
            "%s:%d ChaChaPoly key is missing, SPI 0x%08x"
            "%s:%d ChaChaPoly invalid key length %d bits, SPI 0x%08x"
            "%s:%d ChaChaPoly Mature SPI 0x%08x%s %s dir %u state %u mode %u"
        }
        symbol = "esp_chachapoly_mature"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s:%d ChaChaPoly Invalid key len %u, SPI 0x%08x"
            "%s:%d ChaChaPoly chacha20poly1305_init failed %d, SPI 0x%08x"
            "%s:%d ChaChaPoly Schedule SPI 0x%08x%s %s dir %u state %u mode %u"
        }
        symbol = "esp_chachapoly_schedule"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s:%d algo is NULL @%s:%d"
            "esp_chachapoly_ivlen"
        }
        symbol = "esp_chachapoly_ivlen"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s:%d ChaChaPoly chacha20poly1305_finalize failed %d, SPI 0x%08x"
        }
        symbol = "esp_chachapoly_encrypt_finalize"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s:%d ChaChaPoly Packet too short %d < %zu, SPI 0x%08x"
            "%s:%d ChaChaPoly not enough mbufs %d %d, SPI 0x%08x"
        }
        symbol = "esp_chachapoly_encrypt"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "input_data_len != 0"
            "%s:%d esp_ccp_ctx is NULL @%s:%d"
        }
        symbol = "esp_chachapoly_encrypt_data"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s:%d chacha20poly1305_decrypt failed %d, SPI 0x%08x"
        }
        symbol = "esp_chachapoly_decrypt_data"
        caller = "?"
    }
    new {
        args = 3
        anchors {
            "ipsec4_getpolicybysock: NULL pointer was passed. @%s:%d"
            "ipsec4_getpolicybysock: so->so_pcb == NULL\n"
            "ipsec4_getpolicybysock: unsupported address family @%s:%d"
            "ipsec4_getpolicybysock: illegal direction. @%s:%d"
            "ipsec4_getpolicybysock: currsp is NULL. @%s:%d"
            "ipsec4_setspidx_inpcb: no sp_in/out found. @%s:%d"
            "fixed system default policy: %d->%d\n"
            "ipsec4_getpolicybysock: Invalid policy for PCB %d\n"
            "ipsec4_getpolicybysock: Illegal policy for non-priviliged defined %d\n"
        }
        symbol = "ipsec4_getpolicybysock"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "ipsec4_getpolicybyaddr: NULL pointer was passed. @%s:%d"
            "fixed system default policy:%d->%d\n"
        }
        symbol = "ipsec4_getpolicybyaddr"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "ipsec4_getpolicybyinterface: NULL pointer was passed. @%s:%d"
        }
        symbol = "ipsec4_getpolicybyinterface"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "ipsec6_getpolicybysock: NULL pointer was passed. @%s:%d"
            "ipsec6_getpolicybysock: illegal direction. @%s:%d"
            "ipsec6_getpolicybysock: currsp is NULL. @%s:%d"
            "ipsec6_getpolicybysock: Invalid policy for PCB %d\n"
            "ipsec6_getpolicybysock: Illegal policy for non-priviliged defined %d\n"
            "ipsec6_policybysock: Invalid policy for PCB %d\n"
        }
        symbol = "ipsec6_getpolicybysock"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "ipsec6_getpolicybyaddr: NULL pointer was passed. @%s:%d"
        }
        symbol = "ipsec6_getpolicybyaddr"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "ipsec6_getpolicybyinterface: NULL pointer was passed. @%s:%d"
        }
        symbol = "ipsec6_getpolicybyinterface"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "ipsec_init_policy: NULL pointer was passed. @%s:%d"
            "ipsec_init_policy: No more memory.\n"
        }
        symbol = "ipsec_init_policy"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "ipsec4_delete_pcbpolicy: NULL pointer was passed. @%s:%d"
        }
        symbol = "ipsec4_delete_pcbpolicy"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "ipsec6_delete_pcbpolicy: NULL pointer was passed. @%s:%d"
        }
        symbol = "ipsec6_delete_pcbpolicy"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "ipsec_get_reqlevel: NULL pointer is passed. @%s:%d"
            "ipsec_get_reqlevel: family mismatched. @%s:%d"
            "fixed system default level ip4_esp_trans_deflev:%d->%d\n"
            "fixed system default level ip4_esp_net_deflev:%d->%d\n"
            "fixed system default level ip4_ah_trans_deflev:%d->%d\n"
            "fixed system default level ip4_ah_net_deflev:%d->%d\n"
            "fixed system default level ip6_esp_trans_deflev:%d->%d\n"
            "fixed system default level ip6_esp_net_deflev:%d->%d\n"
            "fixed system default level ip6_ah_trans_deflev:%d->%d\n"
            "fixed system default level ip6_ah_net_deflev:%d->%d\n"
            "key_get_reqlevel: Unknown family. %d @%s:%d"
            "ipsec_get_reqlevel: Illegal protocol defined %u\n @%s:%d"
            "ipsec_get_reqlevel: Illegal IPsec level %u @%s:%d"
            "ipsec_get_reqlevel: still got IPCOMP - exiting\n"
        }
        symbol = "ipsec_get_reqlevel"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "ipsec4_in_reject: invalid inpcb/socket @%s:%d"
        }
        symbol = "ipsec4_in_reject"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "ipsec6_in_reject: invalid in6p/socket @%s:%d"
        }
        symbol = "ipsec6_in_reject"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "ipsec4_hdrsize: why is socket NULL but there is PCB. @%s:%d"
        }
        symbol = "ipsec4_hdrsiz"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "ipsec6_hdrsize: why is socket NULL but there is PCB. @%s:%d"
        }
        symbol = "ipsec6_hdrsiz"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "ipsec4_encapsulate: assumption failed (first mbuf length) @%s:%d"
            "IPv4 ipsec: size exceeds limit: leave ip_len as is (invalid packet)\n"
        }
        symbol = "ipsec4_encapsulate"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "src=%u.%u.%u.%u"
            " dst=%u.%u.%u.%u"
        }
        symbol = "ipsec4_logpacketstr"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "ipsec_logsastr: family mismatched. @%s:%d"
            "SA(SPI=%u "
            "src=%d.%d.%d.%d dst=%d.%d.%d.%d"
        }
        symbol = "ipsec_logsastr"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "ipsec4_output: no SA found, but required. @%s:%d"
            "IPv4 output: can't pullup UDP header\n"
        }
        symbol = "ipsec4_output"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "state == NULL in ipsec6_output_trans @%s:%d"
            "state->m == NULL in ipsec6_output_trans @%s:%d"
            "nexthdrp == NULL in ipsec6_output_trans @%s:%d"
            "mprev == NULL in ipsec6_output_trans @%s:%d"
            "sp == NULL in ipsec6_output_trans @%s:%d"
            "tun == NULL in ipsec6_output_trans @%s:%d"
            "ipsec6_output_trans: no SA found, but required. @%s:%d"
        }
        symbol = "ipsec6_output_trans"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "state == NULL in ipsec6_output_tunnel @%s:%d"
            "state->m == NULL in ipsec6_output_tunnel @%s:%d"
            "sp == NULL in ipsec6_output_tunnel @%s:%d"
            "ipsec6_output_tunnel: no SA found, but required. @%s:%d"
            "ipsec6_output_tunnel: IPv4 must be outer layer, spi=%u\n"
        }
        symbol = "ipsec6_output_tunnel"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "state == NULL in ipsec6_output @%s:%d"
            "state->m == NULL in ipsec6_output @%s:%d"
            "nexthdrp == NULL in ipsec6_output @%s:%d"
            "mprev == NULL in ipsec6_output @%s:%d"
        }
        symbol = "ipsec6_interface_output"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "ipsec4_splithdr: first mbuf too short, m_len %d, pkt_len %d, m_flag %x @%s:%d"
        }
        symbol = "ipsec4_splithdr"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "ipsec6_splithdr: first mbuf too short @%s:%d"
        }
        symbol = "ipsec6_splithdr"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "ipsec4_get_ulp: too short @%s:%d"
            "nxt <= UINT8_MAX"
        }
        symbol = "ipsec_setspidx"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "ipsec6_setspidx_in6pcb: no PCB found. @%s:%d"
            "ipsec6_setspidx_in6pcb: no in6p_sp found. @%s:%d"
            "ipsec6_setspidx_in6pcb: no sp_in/out found. @%s:%d"
        }
        symbol = "ipsec6_setspidx_in6pcb"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "ipsec4_output_internal"
            "ipsec46_encapsulate: assumption failed (first mbuf length) @%s:%d"
            "%s: family mismatched between inner and outer spi=%u\n"
            "ipsec4_output: unknown ipsec protocol %d\n"
        }
        symbol = "ipsec4_output_internal"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "af6->ip6af_off != ip6af->ip6af_off"
        }
        symbol = "frag6_input"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "pp == NULL || (pp->pr_flags & (PR_INITIALIZED | PR_ATTACHED)) == PR_ATTACHED"
            "/AppleInternal/Library/BuildRoots/d3a62b52-2ef5-11ef-9ecd-e2437461156c/Library/Caches/com.apple.xbs/Sources/xnu/bsd/netinet6/icmp6.c"
            "mld_init"
        }
        symbol = "icmp6_init"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "nicmp6 is NULL in %s, which isn't good! @%s:%d"
            "icmp6_input"
            "ICMP6 checksum error(%d|%x) %s\n"
            "icmp6_input: unknown type %d(src=%s, dst=%s, ifid=%d)\n"
        }
        symbol = "icmp6_input"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "icmp6_reflect"
            "sanity fail: off=%x, sizeof(ip6)=%x in %s:%d\n"
            "icmp6_reflect: source can't be determined: dst=%s, error=%d\n"
        }
        symbol = "icmp6_reflect"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "assumption failed in %s:%d @%s:%d"
            "icmp6_redirect_output"
        }
        symbol = "icmp6_redirect_output"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "icmp6_dgram_attach @%s:%d"
        }
        symbol = "icmp6_dgram_attach"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "ni6_input"
            "ni6_input: ignore node info to a temporary address in %s:%d"
        }
        symbol = "ni6_input"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "(src=%s dst=%s tgt=%s)"
        }
        symbol = "icmp6_redirect_diag"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "in6_control"
            "SIOCPROTODETACH_IN6: %s error=%d\n"
            "prefix ioctls are now invalidated. please use ifconfig.\n"
            "sa6 != NULL"
        }
        symbol = "in6_control"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "ifp != NULL && ifra != NULL && iar != NULL"
            "%s: pltime 0x%x > vltime 0x%x for %s\n"
            "%s: valid lifetime is 0 for %s\n"
            "%s: prefix length < 128 with explicit dstaddr.\n"
            "%s: dstaddr valid only on p2p and loopback interfaces.\n"
            "address %s already exists in automatic form"
            "address %s already exists in manual form"
        }
        symbol = "in6_update_ifa"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "in6_purgeaddr: failed to remove a route to the p2p destination: %s on %s, errno=%d\n"
        }
        symbol = "in6_purgeaddr"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "in6_are_prefix_equal"
        }
        symbol = "in6_are_prefix_equal"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "in6_prefixlen2mask"
        }
        symbol = "in6_prefixlen2mask"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: unknown link type (%d)\n"
            "in6_if2idlen"
        }
        symbol = "in6_if2idlen"
        caller = "?"
    }
    new {
        args = 3
        anchors {
            "maclen <= sizeof(in6_event_data.ia_mac)"
        }
        symbol = "in6_post_msg"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "in6_eventhdlr_callback"
            "p_addr6 != NULL"
            "%s Event %s received for %s\n"
        }
        symbol = "in6_eventhdlr_callback"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "in6_event_enqueue_nwk_wq_entry"
            "UNKNOWN_IN6_EVHDLR_CODE"
            "%s: eventhandler enqueuing event of type=in6_evhdlr_code event_code=%s"
        }
        symbol = "in6_event_enqueue_nwk_wq_entry"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "ifp != NULL && ifra != NULL"
            "%s: nd6_prelist_add okay, but no prefix.\n"
            "%s: failed to create a temporary address, error=%d\n"
        }
        symbol = "in6ctl_aifaddr"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "ifp != NULL && ia != NULL"
        }
        symbol = "in6ctl_difaddr"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "sin6 != NULL"
        }
        symbol = "in6_to_kamescope"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "%s: in6_setscope failed\n"
            "%s - %s ifp %s ia6_flags 0x%x ifaupflags 0x%x\n"
            "%s: addmulti failed for %s on %s (errno=%d)\n"
        }
        symbol = "in6_ifaupdate_aux"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "in6_ifloop_request: %s operation failed for %s (errno=%d)\n"
            "DELETE"
        }
        symbol = "in6_ifloop_request"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "in6_unlink_ifa: IPv6 address 0x%llx has no prefix\n"
        }
        symbol = "in6_unlink_ifa"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: attempt to remove wrong ia %p from ipv6 hash table @%s:%d"
            "in6_iahash_remove"
        }
        symbol = "in6_iahash_remove"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: attempt to insert wrong ia %p into hash table @%s:%d"
            "%s: attempt to double-insert ia %p into hash table @%s:%d"
        }
        symbol = "in6_ifinit"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "in6_ifaddr_free"
        }
        symbol = "in6_ifaddr_free"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "cfg != NULL"
            "n < SHA1_RESULTLEN"
        }
        symbol = "in6_cga_start"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "in6 != NULL"
            "prepare->cga_security_level < 8"
        }
        symbol = "in6_cga_generate"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "%s: mbuf %p pkt too short (%d) for IPv6 header @%s:%d"
            "inet6_cksum"
        }
        symbol = "inet6_cksum"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s: off (%u) >=  buffer_len (%u) @%s:%d"
            "%s: len == 0 OR len (%u) >=  buffer_len (%u) @%s:%d"
            "%s: off(%u), len(%u) add overflow @%s:%d"
            "%s: off(%u) + len(%u) >=  buffer_len (%u) @%s:%d"
        }
        symbol = "inet6_cksum_buffer"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "ENOBUFS in in6_gif_output %d\n"
        }
        symbol = "in6_gif_output"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "cannot forward from %s to %s nxt %d received on %s\n"
            "!IN6_IS_ADDR_MULTICAST(&ip6->ip6_dst)"
            "ip6_forward: No IPsec request specified.\n"
            "ip6_forward: Invalid policy found. %d\n"
            "rt == NULL || rt == ip6forward_rt->ro_rt"
            "cannot forward src %s, dst %s, nxt %d, rcvif %s, outif %s\n"
            "ip6_forward"
            "ip6_forward.c"
        }
        symbol = "ip6_forward"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s: in6_ifattach_prelim returned %d if=%s%d\n"
            "%s: proto_unplumb returned %d if=%s%d\n"
        }
        symbol = "in6_domifattach"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "ND_IFINFO(ifp)->initialized"
            "%s: in6_ifattach_loopback returned %d\n"
            "in6_ifattach_prelim"
            "in6_ifattach_loopback"
            "ia == NULL"
            "in6_ifattach: %s is not multicast capable, IPv6 not enabled\n"
            "%s: failed to configure loopback address %s (error=%d)\n"
        }
        symbol = "in6_ifattach_prelim"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "in6_ifattach_aliasreq"
            "%s: %s could not attach link-local address.\n"
        }
        symbol = "in6_ifattach_aliasreq"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "llcgasr != NULL"
            "in6_ifattach_llcgareq"
        }
        symbol = "in6_ifattach_llcgareq"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "ifra != NULL"
            "in6_ifattach_linklocal"
            "%s: failed to configure a link-local address on %s (errno=%d)\n"
        }
        symbol = "in6_ifattach_linklocal"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "in6_generate_tmp_iid"
            "%s: computed SHA256 value is zero.\n"
        }
        symbol = "in6_generate_tmp_iid"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "in6_event2kev_array[i].in6_event_code == i"
            "%s: Unable to find [PF_INET6,IPPROTO_RAW,SOCK_RAW] @%s:%d"
            "dp == inet6domain && dp->dom_family == PF_INET6"
            "ip6_checkinterface"
            "%s: failed to register PF_INET6 protocol: %d @%s:%d"
            "ina6ddr_nhash"
            "ip6_moptions"
        }
        symbol = "ip6_init"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "ip6_input"
            "!ours || (m->m_pkthdr.pkt_flags & PKTF_PROXY_DST)"
            "rin6.ro_rt != NULL"
        }
        symbol = "ip6_input"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "sysctl_ip6_checkinterface"
            "%s: ip6_checkinterface is now %d\n"
        }
        symbol = "sysctl_ip_checkinterface_0"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "0 == packetchain"
            "%s: Invalid policy found: %d\n"
            "assumption failed: hdr not split @%s:%d"
            "ip6obf.route_selected"
            "Double free of ip6e_hbh @%s:%d"
            "Double free of ip6e_dest1 @%s:%d"
            "Double free of ip6e_rthdr @%s:%d"
            "Double free of ip6e_dest2 @%s:%d"
        }
        symbol = "ip6_output_list"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "NULL != mptr"
        }
        symbol = "ip6_do_fragmentation"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "%s: mbuf %p pkt len (%u) < hoff+ip6_hdr (%u+%u)\n @%s:%d"
            "%s: mbuf 0x%llx proto %d IPv6 plen %d (%x) [swapped %d (%x)] doesn't match actual packet length; %d is used instead\n"
            "%s: mbuf %p pkt len (%u) < hoff+ip6_hdr+ext_hdr (%u+%u+%u)\n @%s:%d"
        }
        symbol = "in6_finalize_cksum"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "sopt != NULL"
            "ip6_getpcbopt: unexpected option @%s:%d"
        }
        symbol = "ip6_ctloutput"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s: im6o %p negative refcnt @%s:%d"
            "%s: im6o %p cannot be freed @%s:%d"
        }
        symbol = "im6o_remref"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "copypktopts: invalid argument\n"
        }
        symbol = "copypktopts"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: im6o %p has no debug structure @%s:%d"
            "im6o_trace"
        }
        symbol = "im6o_trace"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "ip6_setpktopt: impossible case\n"
            "IS_P2ALIGNED(buf, sizeof(u_int32_t))"
        }
        symbol = "ip6_setpktopt"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "in6_selectsrc_core_ifa"
            "%s:%d Returned with error: %d"
        }
        symbol = "in6_selectsrc_core_ifa"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "dstsock != NULL"
            "src_storage != NULL"
            "in6_selectsrc_core"
            "IP6S_SRCRULE_1"
            "%s out src %s dst %s ifp %s"
            "%s:%d NEXT ia %s address on ifp1 %s skipped as it is reserved for CLAT46\n"
            "%s:%d CLAT46: NEXT ia %s address on ifp1 %s skipped as it is not reserved for CLAT46\n"
            "%s:%d NEXT ia %s ifp1 %s address is not on outgoing interface \n"
            "%s:%d NEXT ia %s ifp1 %s odstzone %d != dstzone %d\n"
            "%s:%d NEXT ia %s ifp1 %s osrczone %d != srczone %d\n"
            "%s:%d NEXT ia %s ifp1 %s ia6_flags 0x%x\n"
            "%s:%d NEXT ia %s ifp1 %s IFA6_IS_DEPRECATED\n"
            "%s:%d NEXT ia %s ifp1 %s IN6_IFF_OPTIMISTIC\n"
            "%s:%d BREAK r %s ia %s ifp1 %s\n"
            "%s:%d REPLACE r %s ia %s ifp1 %s\n"
            "%s:%d NEXTSRC r %s ia %s ifp1 %s\n"
            "%s:%d Address list seems to have changed. Restarting source address selection.\n"
            "%s:%d NEXT ia %s ifp1 %s IFEF_EXPENSIVE\n"
            "%s:%d NEXT ia %s ifp1 %s last resort\n"
            "%s:%d NEXT ia %s ifp1 %s best_scope %d new_scope %d dst_scope %d\n"
            "%s out src %s dst %s dst_scope %d best_scope %d"
        }
        symbol = "in6_selectsrc_core"
        caller = "?"
    }
    new {
        args = 3
        anchors {
            "sifp != NULL"
        }
        symbol = "in6_selectsrc"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "inp->inp_flags2 & INP2_INHASHLIST"
        }
        symbol = "in6_pcbsetport"
        caller = "?"
    }
    new {
        args = 5
        anchors {
            "rt == NULL || rt == ro->ro_rt"
        }
        symbol = "in6_selectif"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "inm->in6m_st[1].iss_rec == 0"
        }
        symbol = "in6m_clear_recorded"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "im6f_purge"
        }
        symbol = "im6f_purge"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "in6m_commit"
        }
        symbol = "in6m_commit"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "in6m_purge"
        }
        symbol = "in6m_purge"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "IN6_IS_ADDR_MULTICAST(mcaddr)"
            "mcaddr->s6_addr16[1] != 0"
            "%s: in6_mc_get() failure\n"
            "ifma->ifma_addr->sa_family == AF_INET6"
            "inm->in6m_ifma == ifma"
            "in6_are_addr_equal_scoped(&inm->in6m_addr, group, inm->ifscope, ifp->if_index)"
        }
        symbol = "in6_mc_join"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s: in6m=%p negative reqcnt @%s:%d"
            "%s: Attempt to detach an unattached record in6m=%p @%s:%d"
            "%s: in6m %p is already in trash list @%s:%d"
        }
        symbol = "in6_multi_detach"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s: in6m=%p negative refcnt @%s:%d"
            "in6m_remref"
            "%s: attached in6m=%p is being freed @%s:%d"
            "%s: ifma not NULL for in6m=%p @%s:%d"
            "%s: in6m %p cannot be freed @%s:%d"
            "%s: non-zero refcount in6m=%p @%s:%d"
            "%s: non-zero reqcnt in6m=%p @%s:%d"
        }
        symbol = "in6m_remref"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: --- begin in6m 0x%llx ---\n"
            "in6m_print"
            "mli 0x%llx nsrc %lu sctimer %u scrv %u\n"
            "%s: --- end in6m 0x%llx ---\n"
        }
        symbol = "in6m_print"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "src->sin6_family == AF_INET6"
            "gidx != (size_t)-1 && gidx < imo->im6o_num_memberships"
        }
        symbol = "im6o_match_source"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s: Attempt to attach an already attached in6m=%p @%s:%d"
            "in6_multi_attach"
            "in6m->in6m_reqcnt == 1"
        }
        symbol = "in6_multi_attach"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: in6m %p has no debug structure @%s:%d"
            "in6m_trace"
        }
        symbol = "in6m_trace"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "in6m_get_source"
            "in6m_reap"
        }
        symbol = "in6m_merge"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "im6f_rollback"
        }
        symbol = "im6f_rollback"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "inm->in6m_ifp == inm->in6m_ifma->ifma_ifp"
        }
        symbol = "in6_mc_leave"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "%s: ipv6mr_interface = %d, ifp = 0x%llx\n"
            "imo->im6o_mfilters != NULL"
            "%s: new join w/o source"
            "%s: warning: no ifindex, looking up ifp for group %s.\n"
            "%s: ifp = 0x%llx\n"
            "inm == imo->im6o_membership[idx]"
        }
        symbol = "ip6_setmoptions"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "in6p == NULL || (in6p->inp_vflag & INP_IPV6)"
            "gsin6->sin6_family == AF_INET6"
        }
        symbol = "in6p_lookup_mcast_ifp"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "im6f_reap"
        }
        symbol = "im6f_reap"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: visit node 0x%llx\n"
        }
        symbol = "sysctl_ip6_mcast_filters"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: i6mm_maddr not NULL for imm=%p @%s:%d"
            "in6_multi_mship_free"
        }
        symbol = "in6_joingroup"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "!NETNS_TOKEN_VALID( &inp->inp_wildcard_netns_token)"
            "/AppleInternal/Library/BuildRoots/d3a62b52-2ef5-11ef-9ecd-e2437461156c/Library/Caches/com.apple.xbs/Sources/xnu/bsd/netinet6/in6_pcb.c"
        }
        symbol = "in6_pcbbind"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "in6p_route_copyout"
        }
        symbol = "in6p_route_copyout"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "in6p_route_copyin"
        }
        symbol = "in6p_route_copyin"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "inet6domain == NULL"
        }
        symbol = "in6_dinit"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "rip6_pr_output"
            "in6_proto.c"
        }
        symbol = "rip6_pr_output"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "sysctl_ip6_forwarding"
            "%s:%s entry: ip6_forwarding is %d"
            "%s:%s return: ip6_forwarding is %d and error is %d"
        }
        symbol = "sysctl_ip6_forwarding"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "in6_validate"
        }
        symbol = "in6_validate"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "in6_rtqdrain"
        }
        symbol = "in6_rtqdrain"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "head != (void **)&rt_tables[AF_INET6] || *head == NULL"
        }
        symbol = "in6_inithead"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "in6_rmx.c"
        }
        symbol = "in6_rtqkill"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "in6_deleteroute"
        }
        symbol = "in6_deleteroute"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "mld_domifattach"
        }
        symbol = "mld_domifattach"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "!(mli->mli_debug & IFD_ATTACHED)"
            "mld_domifreattach"
            "%s: reattached mld_ifinfo for ifp %s\n"
        }
        symbol = "mld_domifreattach"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "mld_domifdetach"
            "%s: mld_ifinfo not found for ifp %p(%s) @%s:%d"
            "mli_delete"
        }
        symbol = "mld_domifdetach"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s: mli=%p negative refcnt @%s:%d"
            "%s: attached mli=%p is being freed @%s:%d"
            "%s: ifp not NULL for mli=%p @%s:%d"
            "%s: mli %p cannot be freed @%s:%d"
            "%s: non-zero refcnt mli=%p @%s:%d"
            "%s: freeing mld_ifinfo for ifp %s\n"
        }
        symbol = "mli_remref"
        caller = "?"
    }
    new {
        args = 3
        anchors {
            "%s: called w/mbuf (0x%llx,%d)\n"
            "mld_input"
            "%s: report suppressed for %s on ifp 0x%llx(%s)\n"
            "%s: ignore v1 query on ifp %s\n"
            "%s: ignore v1 query src %s on ifp %s\n"
            "%s: process v1 general query on ifp %s\n"
            "%s: process v1 query %s on ifp %s\n"
            "%s: ignore v1 report on ifp %s\n"
            "%s: ignore v1 query dst %s on ifp %s\n"
            "%s: process v1 report %s on ifp %s\n"
        }
        symbol = "mld_input"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "mld_set_version"
            "%s: cancel v2 timers on ifp 0x%llx(%s)\n"
            "mld_v2_cancel_link_timers"
            "%s: switching to v%d on ifp %s\n"
        }
        symbol = "mld_set_version"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "mld_v1_update_group"
        }
        symbol = "mld_v1_update_group"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "%s: schedule response to SG query\n"
            "mld_v2_process_group_query"
        }
        symbol = "mld_v2_process_group_query"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "mld_v1_process_querier_timers"
            "mld_v2_dispatch_general_query"
            "mli == inm->in6m_mli"
            "%s: transition from v%d -> v%d on %s\n"
            "%s: outbound queue full"
        }
        symbol = "mld_timeout"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "inm->in6m_st[1].iss_asm == 0"
            "%s: m_adj(m, -mr)\n"
            "%s: outbound queue full\n"
            "%s: m_append() failed.\n"
            "%s: m_get*() failed\n"
        }
        symbol = "mld_v2_enqueue_group_record"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "mld_v1_transmit_report"
            "%s: v1 outbound queue full\n"
        }
        symbol = "mld_v1_transmit_report"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "mld_dispatch_queue_locked"
        }
        symbol = "mld_dispatch_queue_locked"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: warning: ia is NULL\n"
            "%s: mldreclen is %d\n"
            "%s: ip6_output(0x%llx) = %d\n"
        }
        symbol = "mld_dispatch_packet"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "mld_flush_relq"
            "inm->in6m_in_nrele == true"
            "%s: flushing inm %llx on relq ifp %s\n"
        }
        symbol = "mld_flush_relq"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "mli->mli_rv > 1"
            "IN6_IS_ADDR_MULTICAST(addr)"
            "%s: nothing to do\n"
            "%s: MLDv2 state reached, not MLDv2 mode\n @%s:%d"
            "inm->in6m_debug & IFD_ATTACHED"
            "%s: T1 now MCAST_UNDEFINED for 0x%llx/%s\n"
        }
        symbol = "mld_change_state"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "!nd6_init_done"
        }
        symbol = "nd6_init"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "ndopts == NULL in nd6_option @%s:%d"
            "uninitialized ndopts in nd6_option @%s:%d"
            "ndopts->nd_opts_last >= ndopts->nd_opts_search"
        }
        symbol = "nd6_option"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "ndopts == NULL in nd6_options @%s:%d"
            "uninitialized ndopts in nd6_options @%s:%d"
            "duplicated ND6 option found (type=%d)\n"
            "nd6_options: unsupported option %d - option ignored\n"
            "too many loop in nd opt\n"
        }
        symbol = "nd6_options"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "nd6_drain"
            "%s: draining ND6 entries\n"
        }
        symbol = "nd6_drain"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s: failed to add route for a neighbor(%s), errno=%d\n"
            "%s: failed to lookup %s (if = %s)\n"
            "unspec"
            "[%s:%d]: NDP cache entry changed from %s -> %s for address %s.\n"
        }
        symbol = "nd6_lookup"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "nd6_free"
        }
        symbol = "nd6_free"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "nd6_init_done"
            "%s: failed to join %s (errno=%d)\n"
        }
        symbol = "nd6_rtrequest"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "ifp == NULL in nd6_cache_lladdr @%s:%d"
            "from == NULL in nd6_cache_lladdr @%s:%d"
            "nd6_cache_lladdr"
            "(newstate) != ND6_LLINFO_STALE && (newstate) != ND6_LLINFO_DELAY && (newstate) != ND6_LLINFO_PROBE"
        }
        symbol = "nd6_cache_lladdr"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "nd6_output: can't allocate llinfo for %s (ln=0x%llx, rt=0x%llx)\n"
        }
        symbol = "nd6_output_list"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "in6_ifaddr_set_dadprogress"
            "%s - %s ifp %s ia6_flags 0x%x\n"
        }
        symbol = "in6_ifaddr_set_dadprogress"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "nd6_timeout_run >= 0 && nd6_timeout_run < 2"
            "nd6_service"
            "drainer"
            "%s: ln(%p) rt(%p) rt_ifp == NULL @%s:%d"
            "%s: rt_llinfo(%p) is not equal to ln(%p) @%s:%d"
            "%s: rt(%p) key is NULL ln(%p) @%s:%d"
            "((short)2) != ND6_LLINFO_STALE && ((short)2) != ND6_LLINFO_DELAY && ((short)2) != ND6_LLINFO_PROBE"
            "nd6_service_expired_default_router"
            "%s: %s duplicated (collision count %d)\n"
            "%s: %s new (collision count %d)\n"
            "%s: in6_pfx_newpersistaddr failed %d\n"
            "nd6_handle_duplicated_ip6_addr"
            "%s: found %u, aging_lazy %u, aging %u, sticky %u, killed %u\n"
            "%s: %s is blocked by %d waiters\n"
            "%s: Refreshing expired default router entry %s for interface %s\n"
        }
        symbol = "nd6_timeout"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "regen_tmpaddr: failed to create a new tmp addr,errno=%d\n"
        }
        symbol = "regen_tmpaddr"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "nd6_purge_interface_rti_entries"
        }
        symbol = "nd6_purge_interface_rti_entries"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "rt->rt_llinfo_purge == nd6_llinfo_purge && ln != NULL"
        }
        symbol = "nd6_llinfo_purge"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "nd6_llinfo_free"
            "ln->ln_rt->rt_llinfo == ln"
        }
        symbol = "nd6_llinfo_free"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "nd6_llinfo_refresh"
        }
        symbol = "nd6_llinfo_refresh"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "ND6 advertisement"
            "ND6 unsolicited announcement"
            "nd6_llreach_alloc"
            "%s: %s%s for %s iface=%s\n"
        }
        symbol = "nd6_llreach_alloc"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "nd6_dad_start: ifa->ifa_ifp == NULL @%s:%d"
            "nd6_dad_start"
            "optimistic "
            "immediately "
            "!dp->dad_attached"
            "nd6_dad_start: not a tentative or optimistic address %s(%s)\n"
            "%s: starting %sDAD %sfor %s\n"
        }
        symbol = "nd6_dad_start"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "nd6_need_cache(ifp)"
            "sdl && (void *)sa != (void *)sdl"
            "sin6 && (void *)sa != (void *)sin6"
            "sa->sa_len == sizeof *sin6"
            "sa->sa_len <= sizeof(*sdl)"
            "sdla->sdl_alen == ETHER_ADDR_LEN"
        }
        symbol = "nd6_alt_node_addr_decompose"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "rt->rt_flags & RTF_LLINFO"
            "rt->rt_llinfo"
            "%s: failed to add/update host route to %s.\n"
            "%s: Successfully added/updated host route to %s [lr=0x%llx]\n"
        }
        symbol = "nd6_alt_node_present"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "nd6_dad_find"
            "%s: a looped back NS message is detected during DAD for if=%s %s. Ignoring.\n"
        }
        symbol = "nd6_dad_find"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "dp->dad_ifa == ifa"
        }
        symbol = "nd6_dad_detach"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            ", tx unsolicited NA with O=1"
            "%s: DAD structure not found.\n"
            "%s: DAD complete for %s - duplicate found.\n"
            "%s: possible hardware address duplication detected, disabling IPv6 for interface.\n"
            "%s: manual intervention may be required.\n"
            "nd6_dad_timer: called with null parameter\n"
            "nd6_dad_timer: DAD structure not found\n"
            "nd6_dad_timer: called with duplicated address %s(%s)\n"
            "nd6_dad_timer: not a tentative or optimistic address %s(%s)\n"
            "%s: could not run DAD, driver problem?\n"
            "%s: duplicate IPv6 address %s if:%s [timer]\n"
            "%s: a looped back NS message is detected during DAD for %s. Another DAD probe is being sent on interface %s.\n"
            "%s: DAD complete for %s - no duplicates found %s\n"
            "%s: DAD completed while a looped back NS message is detected during DAD for %s om interface %s\n"
            "%s: NS in/out/loopback=%d/%d/%d, NA in=%d\n"
        }
        symbol = "nd6_dad_timer"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s: dad %p negative refcnt @%s:%d"
            "%s: attached dad=%p is being freed @%s:%d"
        }
        symbol = "dad_remref"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "ro6 == NULL"
            "in6_are_addr_equal_scoped(&ip6->ip6_dst, &ro6->ro_dst.sin6_addr, ip6_input_getdstifscope(m), ro6->ro_dst.sin6_scope_id)"
        }
        symbol = "nd6_prproxy_isours"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "rt == NULL && ro6->ro_rt == NULL"
            "rt != NULL || ro6->ro_rt == NULL"
            "%s: found incorrect prefix proxy route for dst %s on %s\n"
            "%s: found prefix proxy route for dst %s\n"
            "%s: allocated prefix proxy route for dst %s\n"
            "%s: failed to find forwarding prefix proxy entry for dst %s\n"
        }
        symbol = "nd6_proxy_find_fwdroute"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "pr_cur != NULL"
            "!(pr_up->ndpr_stateflags & NDPRF_IFSCOPE)"
        }
        symbol = "nd6_prproxy_prelist_update"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "NUD/AR"
            "!RB_EMPTY(&pr->ndpr_prproxy_sols)"
            "pr->ndpr_prproxy_sols_cnt < max_stgt"
            "pr->ndpr_prproxy_sols_cnt != 0"
            "!TAILQ_EMPTY(&soltgt->soltgt_q)"
            "soltgt->soltgt_cnt != 0"
            "%s: Forwarding NS (%s) from %s to %s who has %s, originally on %s\n"
        }
        symbol = "nd6_prproxy_ns_input"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "!IN6_IS_ADDR_UNSPECIFIED(&daddr) && fwd_ifp"
            "pr == NULL"
            "!IN6_IS_ADDR_UNSPECIFIED(&daddr)"
            "soltgt == NULL || TAILQ_EMPTY(&soltgt->soltgt_q)"
            "%s: Forwarding NA (DAD) from %s to %s tgt is %s, originally on %s\n"
            "%s: Forwarding NA (NUD/AR) from %s to %s (was %s) tgt is %s, originally on %s\n"
        }
        symbol = "nd6_prproxy_na_input"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "up->ndprl_up == NULL"
            "!prproxy || ((pr->ndpr_stateflags & NDPRF_ONLINK) && !(pr->ndpr_stateflags & NDPRF_IFSCOPE))"
            "pr_up != NULL"
            "!prproxy || ((pr_up->ndpr_stateflags & NDPRF_ONLINK) && !(pr_up->ndpr_stateflags & NDPRF_IFSCOPE))"
        }
        symbol = "nd6_prproxy_prelist_setroute"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "max_stgt != 0 || (pr->ndpr_prproxy_sols_cnt == 0 && RB_EMPTY(&pr->ndpr_prproxy_sols))"
        }
        symbol = "nd6_prproxy_sols_purge"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "soltgt->soltgt_cnt > 0"
            "TAILQ_EMPTY(&soltgt->soltgt_q)"
        }
        symbol = "nd6_soltgt_free"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "defrouter_delreq"
            "%s: removing default router %s, scoped=%d, static=%d\n"
            "%s: failed to delete default router %s on %s scoped %d (errno = %d)\n"
        }
        symbol = "defrouter_delreq"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "ndi->ndefrouters >= 0"
            "%s: freeing route to %s with gateway %s\n"
        }
        symbol = "defrtrlist_del"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "selected_dr == NULL && installed_dr == NULL"
            "nd_defrouter_busy"
            "%s:%d: Return early. NULL interface"
            "%s:%d: NULL interface passed. Setting to default interface %s.\n"
            "%s:%d: Return early. Default router select called for loopback.\n"
            "%s:%d: Return early. Default router select called for interface %s in IPV6_ROUTER_MODE_EXCLUSIVE\n"
            "%s:%d: Return early. Default router is empty.\n"
            "%s:%d: Return early. Interface %s's nd_ifinfo not initialized.\n"
            "%s:%d: Return early. %s does not have any default routers.\n"
            "Ignoring dummy entry for default router."
            "%s: Ignoring router %s that has locally hosted address.\n"
            "%s:%d: Fast forward default router selection as interface %s has learned only one default router and there's nothing else to choose from.\n"
            "defrouter_select: more than one default router is installed for interface :%s.\n"
            "%s:%d: Interface %s no longer has any default routers. Abort.\n"
            "%s:%d: Iterate default router list again for interface %s, as the list seems to have changed during release-reaquire of global nd6_mutex lock.\n"
            "%s:%d: Between release and re-acquire of global nd6_mutex lock, the list seems to have changed and it does not have any default routers for interface %s.\n"
            "%s:%d: Found a better router for interface %s. Installing new default route.\n"
            "%s:%d: Need to reinstall default route for interface %s as its scope has changed.\n"
            "%s:%d: No need to change the default route for interface %s.\n"
        }
        symbol = "defrouter_select"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "ndi->nprefixes != 0"
            "scoped"
            "non-scoped"
            "nd6_prelist_add: failed to make the prefix %s/%d on-link %s on %s (errno=%d)\n"
        }
        symbol = "nd6_prelist_add"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "ndi->nprefixes > 0"
            "%s: unexpected (missing) refcnt ndpr=%p @%s:%d"
            "prelist_remove: failed to make %s/%d offlink on %s, errno=%d\n"
            "%s: failed to make %s/%d offlink on %s, errno=%d\n"
            "%s: failed to make %s/%d onlink on %s, errno=%d\n"
            "%s: error unscoping %s/%d from %s\n"
            "%s: %s/%d unscoped, previously on %s\n"
        }
        symbol = "prelist_remove"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s: ndpr %p negative refcnt @%s:%d"
            "%s: freeing ndpr %p with outstanding address reference (%d) @%s:%d"
        }
        symbol = "ndpr_remref"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "nd_prefix_busy"
            "pfxlist_onlink_check: failed to make %s/%d offlink, errno=%d\n"
            "%s: ifnet_get_address_list_family_internal failed"
        }
        symbol = "pfxlist_onlink_check"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "prproxy"
            "nd6_prefix_offlink: %s/%d on %s scoped=%d is already off-link\n"
            "nd6_prefix_offlink: failed to delete route: %s/%d on %s, scoped %d, (errno = %d)\n"
        }
        symbol = "nd6_prefix_offlink"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "errorp != NULL"
            "%s: %s is already configured!\n"
            "%s: invalid prefix length %d for %s, ignored\n"
            "%s: no link-local address (%s)\n"
            "%s: no CGA available (%s)\n"
            "%s: no CLAT46 available (%s)\n"
            "%s: failed to make ifaddr %s on %s (errno=%d)\n"
        }
        symbol = "in6_pfx_newpersistaddr"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "newia != NULL"
            "!(ia0->ia6_flags & IN6_IFF_AUTOCONF)"
            "in6_tmpifadd: failed to find a unique random IFID\n"
            "in6_tmpifadd: failed to add address.\n"
            "in6_tmpifadd: no public address\n"
        }
        symbol = "in6_tmpifadd"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "nd6_prefix"
            "nd6_defrouter"
        }
        symbol = "nd6_rtr_init"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "defrouter_addreq"
            "%s: ignoring router %s, scoped=%d, static=%d on advertising interface\n"
            "%s: adding default router %s, scoped=%d, static=%d\n"
            "%s: ignoring router %s, rti prefix %s, scoped=%d, static=%d on advertising interface\n"
            "%s: Default router %s mapped to "
            "%s: failed to add default router %s on %s scoped %d (errno = %d)\n"
        }
        symbol = "defrouter_addreq"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "defrtrlist_update_common"
            "ndi->ndefrouters != 0"
            "%s: ignoring router addition as we have hit the max limit of %d for max default routers.\n"
            "%s: allocating defrouter %s\n"
        }
        symbol = "defrtrlist_update"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: nddr %p has no debug structure @%s:%d"
            "nddr_trace"
        }
        symbol = "nddr_trace"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s: attached nddr %p is being freed @%s:%d"
            "%s: nddr %p cannot be freed @%s:%d"
        }
        symbol = "nddr_free"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: ndpr %p has no debug structure @%s:%d"
            "ndpr_trace"
        }
        symbol = "ndpr_trace"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s: attached ndpr %p is being freed @%s:%d"
            "%s: ndpr %p cannot be freed @%s:%d"
            "%s: ndpr %p route %p not freed @%s:%d"
            "%s: ndpr %p non-zero solicitors count (%d) @%s:%d"
            "%s: ndpr %p non-empty solicitors tree @%s:%d"
        }
        symbol = "ndpr_free"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "nd6_prefix_onlink_common"
            "%s: %s/%d on %s scoped=%d is already on-link\n"
            "nd6_prefix_onlink: failed to find any ifaddr to add route for a prefix(%s/%d) on %s\n"
            "nd6_prefix_onlink: failed to add route for a prefix (%s/%d) on %s, gw=%s, mask=%s, flags=%x, scoped=%d, errno = %d\n"
        }
        symbol = "nd6_prefix_onlink_common"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "new_rti != NULL && dr != NULL"
            "nd6_rtilist_update"
        }
        symbol = "nd6_rtilist_update"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "nd6_rti_delreq"
        }
        symbol = "nd6_rti_delreq"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "nd6_rti_select"
        }
        symbol = "nd6_rti_select"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: name length err [len=%u]\n"
            "%s: input buffer size error [len=%zu]\n"
            "net.inet6.send.cga_parameters"
            "%s: mac_system_check_info denied.\n"
            "%s: could not allocate marshaling buffer.\n"
            "iov->iov_len < UINT16_MAX"
            "/AppleInternal/Library/BuildRoots/d3a62b52-2ef5-11ef-9ecd-e2437461156c/Library/Caches/com.apple.xbs/Sources/xnu/bsd/netinet6/nd6_send.c"
            "%s: marshalled data too large.\n"
            "%s: input too large [octets=%ld].\n"
            "%s: in6_cga_start error=%d.\n"
        }
        symbol = "sysctl_cga_parameters"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "bad if_index on interface from route @%s:%d"
        }
        symbol = "rip6_output"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "rip6_attach @%s:%d"
        }
        symbol = "rip6_attach"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "IN6_IFEXTRA(ifp) != NULL"
        }
        symbol = "scope6_ifattach"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "sa6_recoverscope: assumption failure (non 0 ID): %s%%%d\n"
        }
        symbol = "sa6_recoverscope"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "ntohs(in6->s6_addr16[1]) == ifscope"
        }
        symbol = "in6_verify_ifscope"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "udp6_output: IPV6_V6ONLY option was set for a connected socket\n"
            "in6p->inp_sndinprog_cnt > 0"
            "/AppleInternal/Library/BuildRoots/d3a62b52-2ef5-11ef-9ecd-e2437461156c/Library/Caches/com.apple.xbs/Sources/xnu/bsd/netinet6/udp6_output.c"
        }
        symbol = "udp6_output"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "UDP6: M_MCAST is set in a unicast packet.\n"
        }
        symbol = "udp6_input"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "udp6_abort"
            "udp6_usrreq.c"
        }
        symbol = "udp6_abort"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s[%d, %s]: defuncting so 0x%llu drop ipv6 multicast memberships"
            "%s[%d, %s]: defuncting so 0x%llu drop ipv4 multicast memberships"
        }
        symbol = "udp6_defunct"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "salt_tmp != 0"
            "/AppleInternal/Library/BuildRoots/d3a62b52-2ef5-11ef-9ecd-e2437461156c/Library/Caches/com.apple.xbs/Sources/xnu/bsd/netinet6/ip6_id.c"
        }
        symbol = "ip6_randomid"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "key_allocsp: NULL pointer is passed. @%s:%d"
            "key_allocsp: Invalid direction is passed. @%s:%d"
            "key_allocsp"
            "%s: direction mismatched (TREE=%d SP=%d), anyway continue.\n"
        }
        symbol = "key_allocsp"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "key_checkrequest: NULL pointer is passed. @%s:%d"
            "key_checkrequest: Invalid policy defined. @%s:%d"
            "key_checkrequest: error %d returned from key_acquire.\n"
        }
        symbol = "key_checkrequest"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "key_freesp: NULL pointer is passed. @%s:%d"
        }
        symbol = "key_freesp"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "key_msg2sp: NULL pointer was passed. @%s:%d"
            "key_msg2sp: invalid length. @%s:%d"
            "key_msg2sp: Invalid msg length.\n"
            "key_msg2sp: invalid ipsecrequest.\n"
            "key_msg2sp: invalid ipsecrequest length.\n"
            "key_msg2sp: invalid proto type=%u\n"
            "key_msg2sp: invalid mode=%u\n"
            "key_msg2sp: reqid=%d range violation, updated by kernel.\n"
            "key_msg2sp: invalid level=%u\n"
            "key_msg2sp: invalid request address length.\n"
            "key_msg2sp: invalid request ipsecrequest len invalid for src address.\n"
            "key_msg2sp: invalid request invalid source address length.\n"
            "key_msg2sp: invalid request ipsecrequest len invalid for dst address.\n"
            "key_msg2sp: invalid request invalid dest address length.\n"
            "key_msg2sp: becoming tlen < 0.\n"
            "key_msg2sp: invalid policy type.\n"
        }
        symbol = "key_msg2sp"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "key_sp2msg: NULL pointer was passed. @%s:%d"
            "key_getspreqmsglen returned length %u\n"
        }
        symbol = "key_sp2msg"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "key_spdacquire: NULL pointer is passed. @%s:%d"
            "key_spdacquire: called but there is request. @%s:%d"
            "key_spdacquire: policy mismathed. IPsec is expected. @%s:%d"
        }
        symbol = "key_spdacquire"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "key_delsah: NULL pointer is passed. @%s:%d"
            "key_delsah"
        }
        symbol = "key_delsah"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "key_delsav: NULL pointer is passed. @%s:%d"
        }
        symbol = "key_delsav"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "key_ismyaddr: NULL pointer is passed. @%s:%d"
        }
        symbol = "key_ismyaddr"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: total stats for %u calls\n"
            "key_timehandler"
            "%s: walked %u SPDs\n"
            "%s: walked %llu SAs: LARVAL SAs %u, MATURE SAs %u, DYING SAs %u, DEAD SAs %u\n"
            "%s: walked %u SAHs: DEAD SAHs %u, EMPTY SAHs %u\n"
            "%s: SAH search cost %d iters per call\n"
            "key_spdexpire: NULL pointer is passed. @%s:%d"
            "key_expire: NULL pointer is passed. @%s:%d"
            "key_expire: Why was SA index in SA NULL. @%s:%d"
            "key_expire: invalid proto is passed. @%s:%d"
            "key_timehandler: spbufcount overflow, ipsec policy count %u.\n"
            "key_timehandler: savbufcount overflow, ipsec sa count %u.\n"
            "key_timehandler: There is no CURRENT time, why?\n"
            "key_timehandler: invalid sav->state (queue: %d SA: %d): kill it anyway\n"
            "key_setdumpsp: packet header length > UINT16_MAX\n"
        }
        symbol = "key_timehandler"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "key_freereg: NULL pointer is passed. @%s:%d"
        }
        symbol = "key_freereg"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "key_parse: NULL pointer is passed. @%s:%d"
            "key_parse: invalid message length.\n"
            "key_parse: PF_KEY version %u is mismatched.\n"
            "key_parse: invalid type %u is passed.\n"
            "key_parse: must specify satype when msg type=%u.\n"
            "key_parse: illegal satype=%u\n"
            "key_parse: type %u isn't supported.\n"
        }
        symbol = "key_parse"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "key_sa_recordxfer called with sav == NULL @%s:%d"
        }
        symbol = "key_sa_recordxfer"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "key_sa_chgstate called with sav == NULL @%s:%d"
        }
        symbol = "key_sa_chgstate"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "key_sa_stir_iv called with sav == NULL @%s:%d"
        }
        symbol = "key_sa_stir_iv"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "sah != NULL"
            "(sah->flags & SECURITY_ASSOCIATION_CUSTOM_IPSEC) == SECURITY_ASSOCIATION_CUSTOM_IPSEC"
            "sa_present == false"
        }
        symbol = "key_release_custom_ipsec"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "key_do_allocsa_policy"
            "key_do_allocsa_policy: lifetime_current is NULL.\n @%s:%d"
            "%s: state mismatched (TREE=%d SA=%d)\n"
        }
        symbol = "key_do_allocsa_policy"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "key_do_get_translated_port"
            "key_do_get_translated_port: lifetime_current is NULL.\n @%s:%d"
        }
        symbol = "key_natt_get_translated_port"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "key_newsaidx: NULL pointer is passed. @%s:%d"
            "flags == SECURITY_ASSOCIATION_PFKEY || flags == SECURITY_ASSOCIATION_CUSTOM_IPSEC"
        }
        symbol = "key_newsah"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "key_do_allocsa_policy: invalid proto is passed. @%s:%d"
        }
        symbol = "key_send_delete"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "key_acquire: NULL pointer is passed. @%s:%d"
            "key_acquire: invalid proto is passed. @%s:%d"
            "totlen <= UINT16_MAX"
        }
        symbol = "key_acquire"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "key_getspi: NULL pointer is passed. @%s:%d"
            "key_getspi: invalid message is passed.\n"
            "key_getspi: invalid satype is passed.\n"
            "key_getspi: custom ipsec exists\n"
            "key_getspi: security association head is dead\n"
            "key_do_getnewspi: SPI %u exists already.\n"
            "key_do_getnewspi: to allocate spi is failed.\n"
        }
        symbol = "key_getspi"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "key_newsa: NULL pointer is passed. @%s:%d"
            "key_newsa: invalid message is passed.\n"
            "key_newsa: invalid hard lifetime ext len.\n"
        }
        symbol = "key_newsav"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "key_setsaval: NULL pointer is passed. @%s:%d"
            "key_setsaval: invalid message size.\n"
            "key_setsaval: natt port not set.\n"
            "key_setsaval: invalid auth key ext len. len = %d\n"
            "key_setsaval: invalid key_auth values.\n"
            "key_setsaval: invalid encryption key ext len. len = %d\n"
            "key_setsaval: invalid ESP algorithm.\n"
            "key_setsaval: invalid key_enc value.\n"
            "key_setsaval: No more memory.\n"
            "key_setsaval: invalid SA type.\n"
            "key_setsaval: invalid hard lifetime ext len.\n"
            "key_setsaval: invalid hard lifetime value %llu.\n"
            "key_setsaval: invalid soft lifetime ext len.\n"
            "key_setsaval: invalid soft lifetime value %llu.\n"
        }
        symbol = "key_setsaval"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "key_update: NULL pointer is passed. @%s:%d"
            "key_update: invalid satype is passed.\n"
            "key_update: invalid message is passed.\n"
            "key_update: no SA index found.\n"
            "key_update: no such a SA found (spi:%u)\n"
            "key_update: protocol mismatched (DB=%u param=%u)\n"
            "key_update: pid mismatched (DB:%u param:%u)\n"
            "key_update: security association head is dead\n"
            "key_update: No more memory.\n"
        }
        symbol = "key_update"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "key_getmsgbuf_x1: NULL pointer is passed. @%s:%d"
        }
        symbol = "key_getmsgbuf_x1"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "key_add: NULL pointer is passed. @%s:%d"
            "key_add: invalid satype is passed.\n"
            "key_add: invalid message is passed.\n"
            "key_add: custom ipsec exists\n"
            "key_add: SA already exists.\n"
            "key_add: security association head is dead\n"
        }
        symbol = "key_add"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "key_delete: NULL pointer is passed. @%s:%d"
            "key_delete: invalid satype is passed.\n"
            "key_delete: invalid message is passed.\n"
            "key_delete: doing delete all.\n"
            "key_delete: no SA found.\n"
            "key_delete_all: invalid sav->state (queue: %d SA: %d)\n"
        }
        symbol = "key_delete"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "key_get: NULL pointer is passed. @%s:%d"
            "key_get: invalid satype is passed.\n"
            "key_get: invalid message is passed.\n"
            "key_get: no SA found.\n"
            "key_get: there was invalid proto in SAD.\n"
        }
        symbol = "key_get"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "key_acquire2: NULL pointer is passed. @%s:%d"
            "key_acquire2: must specify sequence number.\n"
            "key_acquire2: invalid satype is passed.\n"
            "key_acquire2: invalid message is passed.\n"
            "key_acquire2: a SA exists already.\n"
            "key_acquire2: error %d returned from key_acquire.\n"
        }
        symbol = "key_acquire2"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "key_register: NULL pointer is passed. @%s:%d"
            "(*ealgo->ivlen)(ealgo, NULL) <= UINT8_MAX"
            "key_register: socket exists already.\n"
        }
        symbol = "key_register"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "key_flush: NULL pointer is passed. @%s:%d"
            "key_flush: invalid satype is passed.\n"
            "key_flush: No more memory.\n"
        }
        symbol = "key_flush"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "key_dump: NULL pointer is passed. @%s:%d"
            "key_dump: invalid satype is passed.\n"
            "key_dump: bufcount overflow, ipsec sa count %u.\n"
            "key_dump: No more memory.\n"
            "key_dump: there was invalid proto in SAD.\n"
        }
        symbol = "key_dump"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "key_promisc: NULL pointer is passed. @%s:%d"
        }
        symbol = "key_promisc"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "key_spdadd: NULL pointer is passed. @%s:%d"
            "key_spdadd: invalid message is passed.\n"
            "key_spdadd: Invalid SP direction.\n"
            "key_spdadd: Invalid policy type.\n"
            "key_spdadd: some policy requests part required.\n"
            "key_spdadd: a SP entry exists already.\n"
            "key_spdadd: invalid lifetime value %llu.\n"
            "key_spdadd: invalid use time value %llu.\n"
        }
        symbol = "key_spdadd"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "key_getsp: NULL pointer is passed. @%s:%d"
        }
        symbol = "key_getsp"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "key_spddelete: NULL pointer is passed. @%s:%d"
            "key_spddelete: invalid message is passed.\n"
            "key_spddelete: Invalid SP direction.\n"
            "key_spddelete: no SP found.\n"
        }
        symbol = "key_spddelete"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "key_spdget: NULL pointer is passed. @%s:%d"
            "key_spdget: invalid message is passed.\n"
            "key_spdget: no SP found id:%u.\n"
        }
        symbol = "key_spdget"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "key_spddump: NULL pointer is passed. @%s:%d"
            "key_spddump: bufcount overflow, ipsec policy count %u.\n"
            "key_spddump: No more memory.\n"
        }
        symbol = "key_spddump"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "key_spdflush: NULL pointer is passed. @%s:%d"
            "key_spdflush: No more memory.\n"
        }
        symbol = "key_spdflush"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "key_spddelete2: NULL pointer is passed. @%s:%d"
            "key_spddelete2: invalid message is passed.\n"
            "key_spddelete2: no SP found id:%u.\n"
        }
        symbol = "key_spddelete2"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: NULL pointer is passed. @%s:%d"
            "%s: invalid message is passed. missing session-id.\n"
            "%s: invalid message is passed. short session-id.\n"
            "%s: invalid message is passed. missing stat args.\n"
            "%s: invalid message is passed. short stat args.\n"
            "%s: No active SAs.\n"
            "%s: No more memory.\n"
            "%s: No SAs requested.\n"
            "%s: invalid message is passed. sa stat extlen shorter than requested stat length.\n"
            "%s: Error finding SAs.\n"
            "%s: No SAs found.\n"
            "%s: No bufs to dump stats.\n"
        }
        symbol = "key_getsastat"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "key_spdenable: NULL pointer is passed. @%s:%d"
            "key_spdenable: invalid message is passed.\n"
            "key_spdenable: no SP found id:%u.\n"
        }
        symbol = "key_spdenable"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "key_spddisable: NULL pointer is passed. @%s:%d"
            "key_spddisable: invalid message is passed.\n"
            "key_spddisable: no SP found id:%u.\n"
        }
        symbol = "key_spddisable"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "key_migrate: NULL pointer is passed. @%s:%d"
            "key_migrate: invalid satype is passed.\n"
            "key_migrate: invalid message is passed.\n"
            "key_migrate: no mature SAH found.\n"
            "key_migrate: custom ipsec exists\n"
            "key_migrate: Failed to migrate SA to new SAH.\n"
        }
        symbol = "key_migrate"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "key_align: NULL pointer is passed. @%s:%d"
            "invalid mbuf passed to key_align @%s:%d"
            "key_align: duplicate ext_type %u is passed.\n"
            "key_align: invalid ext_type %u is passed.\n"
            "key_align: ext type %u invalid ext length %d offset %d sadb message total len %zu is passed.\n"
        }
        symbol = "key_align"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "key_output: NULL pointer was passed. @%s:%d"
            "key_output: not M_PKTHDR ?? @%s:%d"
        }
        symbol = "key_output"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "keydomain == NULL"
        }
        symbol = "_key_dinit"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "key_usrreq: key_usrreq results %d\n"
        }
        symbol = "key_attach"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "audit_worker_cv"
            "audit_drain_cv"
            "audit_watermark_cv"
            "audit_fail_cv"
        }
        symbol = "audit_init"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Cannot get audit control port\n"
        }
        symbol = "audit_send_trigger"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Cannot get audit control port for analytics \n"
        }
        symbol = "audit_send_analytics"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "domain"
            "protocol"
            "accounting off"
            "setaudit:auid"
            "setaudit:port"
            "setaudit:machine"
            "setaudit:as_success"
            "setaudit:as_failure"
            "setaudit:asid"
            "setaudit_addr:auid"
            "setaudit_addr:as_success"
            "setaudit_addr:as_failure"
            "setaudit_addr:asid"
            "setaudit_addr:type"
            "setaudit_addr:port"
            "operation"
            "protection"
            "inherit"
            "msg ID"
            "src dir fd"
            "dst dir fd"
            "command"
            "howto"
            "sem ID"
            "which"
            "value"
            "newval"
            "new mask"
            "prev mask"
            "sflags"
            "am_success"
            "am_failure"
            "target port"
            "task port"
            "kaudit_to_bsm(): BSM conversion requested forunknown mac_audit data type %d\n"
            "setkmask:as_success"
            "setkmask:as_failure"
            "setqctrl:aq_minfree"
            "setumask:as_success"
            "setumask:as_failure"
            "setsmask:as_success"
            "setsmask:as_failure"
            "setclass:ec_event"
            "setclass:ec_class"
            "setpmask:as_success"
            "setpmask:as_failure"
            "setfsize:filesize"
            "kau_close: invalid address family @%s:%d"
            "audit_bsm.c"
        }
        symbol = "kaudit_to_bsm"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "min fd"
            "close-on-exec flag"
            "fd flags"
            "offset"
        }
        symbol = "audit_sys_fcntl"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "arg: "
        }
        symbol = "audit_arg_mac_string"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "auditpipe"
        }
        symbol = "audit_pipe_init"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "audit_pipe"
        }
        symbol = "audit_pipe_open"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "&ap->ap_cv"
        }
        symbol = "audit_pipe_read"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "auditsessions"
        }
        symbol = "audit_session_init"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "audit_sdev_cv"
        }
        symbol = "audit_sdev_open"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "&asdev->asdev_cv"
        }
        symbol = "audit_sdev_read"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "com.apple.private.audit.user"
        }
        symbol = "audit"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "com.apple.private.protected-audit-control"
        }
        symbol = "auditctl"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "&audit_drain_cv"
            "audit_rotate_vnode: Couldn\\'t close audit file.\n"
        }
        symbol = "audit_rotate_vnode"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "audit_worker_init: Couldn\\'t create audit_worker thread @%s:%d"
        }
        symbol = "audit_worker_init"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "audit_worker_process_record: BSM_FAILURE\n"
            "kaudit_to_bsm returned %d @%s:%d"
        }
        symbol = "audit_worker"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "audit_record_write: free space below size of audit queue, failing stop\n"
            "Audit store overflow; record queue drained. @%s:%d"
            "Audit log space exhausted and fail-stop set. @%s:%d"
            "audit_worker: write error %d @%s:%d"
            "audit_worker: write error %d\n"
        }
        symbol = "audit_record_write"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Re-initialisation of pthread kext callbacks. @%s:%d"
            "pthread_kext_register called without callbacks pointer. @%s:%d"
        }
        symbol = "pthread_kext_register"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "workq_mark_exiting called twice @%s:%d"
        }
        symbol = "workq_mark_exiting"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "Quantum expired for thread that doesn't support cooperative workqueue @%s:%d"
            "Thread should not have workq bucket of QoS UN @%s:%d"
        }
        symbol = "workq_kern_quantum_expiry_reevaluate"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "failed to allocate devpath string! @%s:%d"
        }
        symbol = "bsd_rooted_ramdisk"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "kdebug: PAST EVENT: debugid %#8x: time %lld from CPU %u (barrier at time %lld)\n"
            "kdebug: RETRO EVENT: debugid %#8x: time %lld from CPU %u (barrier at time %lld)\n"
            "kdebug: invalid kdebug mode %d @%s:%d"
            "kdebug_common.c"
        }
        symbol = "kernel_debug_read"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "create_buffers_triage shouldn't be called once we have inited the triage system. @%s:%d"
            "kdebug_triage.c"
        }
        symbol = "create_buffers_triage"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "ktriage_extract: kernel_debug_read failed with %d\n"
            "KTriage Error: Subsystem code %u is invalid\n"
            "KTriage: Subsystem %d reported %u with argument 0x%lx\n"
            "%s(arg = 0x%lx) %s"
        }
        symbol = "ktriage_extract"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "ktriage_register_subsystem_strings: set subsystem %u strings\n"
        }
        symbol = "ktriage_register_subsystem_strings"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "IOP-???"
        }
        symbol = "kernel_debug_register_callback"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "kdebug: invalid name for coprocessor: %p @%s:%d"
            "kdebug: invalid name for coprocessor: %s @%s:%d"
            "kdebug: no callback for coprocessor `%s' @%s:%d"
        }
        symbol = "kdebug_register_coproc"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "start_kern_tracing"
            "kdebug: allocation failed, kernel tracing not started: %d\n"
            "kernel tracing started with %u events, filter = %s\n"
            "kdebug: unexpected filter type `%c'\n"
            "kdebug: cannot parse `%s' as integer\n"
            "kdebug: class 0x%lx is invalid\n"
            "kdebug: C 0x%lx\n"
            "kdebug: class-subclass 0x%lx is invalid\n"
            "kdebug: S 0x%lx\n"
            "kernel_debug_early_end() not call on boot processor @%s:%d"
            "early trace done"
        }
        symbol = "kdebug_trace_start"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "kdebug: invalid procfilt flags %x @%s:%d"
        }
        symbol = "kernel_debug_internal"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "kdbg_wait() called with interrupts disabled @%s:%d"
        }
        symbol = "kdbg_wait"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Accounting resumed\n"
            "Accounting suspended\n"
        }
        symbol = "acctwatch"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "aio_close"
        }
        symbol = "_aio_close"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "aio_exit"
        }
        symbol = "_aio_exit"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Negative total AIO count! @%s:%d"
            "proc %p: p_aio_total_count accounting mismatch @%s:%d"
        }
        symbol = "aio_proc_remove_done_locked"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "aio_workq_entry %p being freed while still enqueued @%s:%d"
        }
        symbol = "aio_free_request"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Close and exit flags set at the same time @%s:%d"
        }
        symbol = "do_aio_cancel_locked"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Trying to remove an entry from a work queue, but it is not on a queue @%s:%d"
        }
        symbol = "aio_work_thread"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "lio_pending accounting mistake @%s:%d"
        }
        symbol = "do_aio_completion_and_unlock"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "auth against NULL credential @%s:%d"
        }
        symbol = "kauth_authorize_generic"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "KAUTH_PROCESS_CANSIGNAL not implemented @%s:%d"
        }
        symbol = "kauth_authorize_process_callback"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "tvotohz: negative time difference %ld sec %ld usec\n"
        }
        symbol = "tvtohz"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "com.apple.private.custom-coredump-location"
            "%s/%s"
            "/cores/core.%d"
        }
        symbol = "coredump"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "kauth external resolver %d failed to de-register.\n"
        }
        symbol = "kauth_resolver_identity_reset"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "com.apple.private.identitysvc"
            "kauth_resolver: memberd is not setting valid result codes (assuming always successful)\n"
            "%s: resolver %d died, waiting for a new one\n"
            "%s: resolver reported transient failure for request %d\n"
            "%s: resolver returned unexpected status %d\n"
        }
        symbol = "identitysvc"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "external resolver died"
        }
        symbol = "kauth_resolver_getwork"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: external resolver died\n"
            "int kauth_resolver_getwork_continue(int)"
        }
        symbol = "kauth_resolver_getwork_continue"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "kauth data structure corrupted. kauth identity 0x%p with %u groups, greater than max of %d @%s:%d"
            "can't allocate kauth identity with both uid and gid @%s:%d"
            "can't allocate kauth identity with both gid and supplementary groups @%s:%d"
        }
        symbol = "kauth_cred_cache_lookup"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "kauth_identity: can't insert record with both UID and GID as key @%s:%d"
            "kauth_identity: can't insert record without UID or GID as key @%s:%d"
        }
        symbol = "kauth_identity_register_and_free"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "kauth external resolver timed out (%d timeout(s) of %d seconds).\n"
        }
        symbol = "kauth_resolver_submit"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s: kauth external resolver died while while waiting for work to complete\n"
            "int __KERNEL_IS_WAITING_ON_EXTERNAL_CREDENTIAL_RESOLVER__(struct kauth_resolver_work *)"
        }
        symbol = "__KERNEL_IS_WAITING_ON_EXTERNAL_CREDENTIAL_RESOLVER__"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "current_cached_proc_cred(%p) called but current_proc() is %p @%s:%d"
        }
        symbol = "current_cached_proc_cred_panic"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "kauth_cred_t backref mismatch: cred:%p cred->cr_rw:%p cred_rw:%p @%s:%d"
        }
        symbol = "kauth_cred_verify_panic"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "kauth_cred_ref: cred %p over-retained @%s:%d"
        }
        symbol = "kauth_cred_panic_over_retain"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "kauth_cred_unref: cred %p over-released @%s:%d"
        }
        symbol = "kauth_cred_panic_over_released"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Over-release of the kernel credentials @%s:%d"
            "%s: freeing credential with active long-term ref @%s:%d"
            "kauth_cred_free"
        }
        symbol = "kauth_cred_free"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "ucred_rw backref mismatch: cred_rw:%p cred_rw->crw_cred:%p cred: %p @%s:%d"
        }
        symbol = "kauth_cred_rw_verify_panic"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "cs_enforcement_disable"
            "cs_relax_platform_task_ports"
            "cs_library_val_enable"
        }
        symbol = "cs_init"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "CODE SIGNING: cs_allow_invalid() not allowed: pid %d\n"
            "CODE SIGNING: cs_allow_invalid() allowed: pid %d\n"
            "CODE SIGNING: cs_allow_invalid() not allowed by pmap: pid %d\n"
        }
        symbol = "cs_allow_invalid"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "CODE SIGNING: cs_invalid_page(0x%llx): p=%d[%s]\n"
            "CODE SIGNING: cs_invalid_page(0x%llx): p=%d[%s] final status 0x%x, %s page%s\n"
            "denying"
            "allowing (remove VALID)"
            " sending SIGKILL"
        }
        symbol = "cs_invalid_page"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "CoreEntitlements: This API is no longer supported\n @%s:%d"
        }
        symbol = "csblob_entitlements_dictionary_set"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "/chosen/asmb"
            "lp-sip0"
            "lp-sip1"
            "lp-sip2"
            "unexpected size %xu for uint64 property '%s' @%s:%d"
            "internal-use-only-unit"
            "/chosen/manifest-properties"
            "csr-allow-device-configuration"
        }
        symbol = "csr_bootstrap"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "vn_open_auth(fmode: %d, cmode: %d) failed with error: %d\n"
            "kern_write_file() failed with error: %d\n"
            "kern_direct_file(%s): vp size %qd, alloc %qd, mp free %qd, keep free %qd\n"
            "kern_direct_file(%s): Not backed by block device.\n"
            "max io 0x%qx bytes\n"
        }
        symbol = "kern_open_file_for_direct_io"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "kern_close_file_for_direct_io(%p)\n"
            "vnode_close(%d)\n"
            "%s: unlink1(%d)\n"
            "kern_close_file_for_direct_io"
        }
        symbol = "kern_close_file_for_direct_io"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "_DKIOCCSPINEXTENT(%d) 0x%qx, 0x%qx\n"
            "_DKIOCCSUNPINEXTENT(%d) 0x%qx, 0x%qx\n"
        }
        symbol = "kern_ioctl_file_extents"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "file %d/%p in flux during exec of %p @%s:%d"
        }
        symbol = "fdt_exec"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "fdfree: found fp with UF_RESERVED @%s:%d"
        }
        symbol = "fdt_invalidate"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s: pid %d refc: %u != 0 @%s:%d"
            "fileproc_free"
        }
        symbol = "fileproc_free"
        caller = "?"
    }
    new {
        args = 3
        anchors {
            "%s: called with fileproc in flux (%d/:%p) @%s:%d"
            "fp_close_and_unlock"
            "bad wait queue for waitq_wakeup64_all %p (%sfp:%p) @%s:%d"
            "guarded "
            "bad select_conflict_queue @%s:%d"
            "fpdrain"
        }
        symbol = "fp_close_and_unlock"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "CODE SIGNING: Failed to find original file for supplemental signature attachment\n"
        }
        symbol = "sys_fcntl_nocancel"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "ftbl_waitfd"
        }
        symbol = "dup2"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "kq(%p) invalid refcount %d @%s:%d"
        }
        symbol = "kqworkloops_dealloc"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: proc mismatch (kq->kq_p=%p != p=%p) @%s:%d"
            "knote_fdclose"
        }
        symbol = "knote_fdclose"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s: - bad wait_result (%d) @%s:%d"
            "kqueue_scan"
        }
        symbol = "kqueue_scan"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "unknown kqwl thread qos update operation: %d @%s:%d"
        }
        symbol = "kqworkloop_update_threads_qos"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Unexpected wait result: %d @%s:%d"
        }
        symbol = "filt_wlwait_continue"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "knote lock context not found: %p @%s:%d"
        }
        symbol = "knote_lock_slow"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s[%d](%p, %ld) @%s:%d"
            "filt_bad_event"
        }
        symbol = "filt_bad_event"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "filt_bad_touch"
        }
        symbol = "filt_bad_touch"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "filt_bad_process"
        }
        symbol = "filt_bad_process"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "KNOTE() called concurrently on knote %p @%s:%d"
        }
        symbol = "knote_post"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "filter %d cannot change QoS @%s:%d"
        }
        symbol = "knote_adjust_qos"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s: - invalid wait_result (%d) @%s:%d"
            "kqueue_scan_continue"
        }
        symbol = "kqueue_scan_continue"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s: so=%p so_pcb=%p lr=%p ref=%d lrh= %s @%s:%d"
        }
        symbol = "event_lock"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s: so=%p NO PCB usecount=%d lr=%p lrh= %s @%s:%d"
            "so->so_flags & SOF_PCBCLEARING"
        }
        symbol = "event_unlock"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: so=%p NULL NO so_pcb %s @%s:%d"
        }
        symbol = "event_getlock"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "pid %d (tid:%llu): copyout of return_to_kernel ast flags failed with ast_addr = %llu\n"
        }
        symbol = "kevent_ast"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "ctl_enqueuembuf"
        }
        symbol = "ctl_enqueuembuf"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: %u:%u m_pkthdr.len is 0"
        }
        symbol = "ctl_enqueuembuf_list"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: m_allocpacket_internal(%lu) failed\n"
        }
        symbol = "ctl_enqueuedata"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "ctl_deregister"
        }
        symbol = "ctl_deregister"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "ctl_ctloutput: ctl %s returned len (%lu) > sopt_valsize (%lu)\n"
        }
        symbol = "ctl_ctloutput"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "ctl_bind so_pcb null @%s:%d"
            "ctl_bind kctl null @%s:%d"
        }
        symbol = "ctl_bind"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "ctl_setup_kctl so_pcb null @%s:%d"
        }
        symbol = "ctl_setup_kctl"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "ctl_connect so_pcb null @%s:%d"
            "ctl_connect kctl null @%s:%d"
        }
        symbol = "ctl_connect"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "kcb->usecount"
        }
        symbol = "ctl_disconnect"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s - shrunk to %d\n"
            "ctl_sbrcv_trim"
        }
        symbol = "ctl_usr_rcvd"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "ctl_lock: so=%p NO PCB! lr=%p lrh= %s @%s:%d"
            "ctl_lock: so=%p so_pcb=%p lr=%p ref=%x lrh= %s @%s:%d"
        }
        symbol = "ctl_lock"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "ctl_unlock: so=%p usecount=%x lrh= %s @%s:%d"
            "ctl_unlock: so=%p NO PCB usecount=%x lr=%p lrh= %s @%s:%d"
        }
        symbol = "ctl_unlock"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "ctl_getlock: so=%p usecount=%x lrh= %s @%s:%d"
            "ctl_getlock: so=%p NULL NO so_pcb %s @%s:%d"
        }
        symbol = "ctl_getlock"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s - grown to %d error %d\n"
            "ctl_rcvbspace"
        }
        symbol = "ctl_rcvbspace"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s no space in table @%s:%d"
            "%s %p for %p\n"
            "kctl_tbl_growing"
            "%s kctl_tbl_size %lu too big\n"
            "kctl_tbl_grow"
        }
        symbol = "ctl_register"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "kcb_find_socket"
        }
        symbol = "kcb_find_socket"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "invalid mac policy extension data @%s:%d"
        }
        symbol = "exec_spawnattr_getmacpolicyinfo"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "com.apple.private.spawn-subsystem-root"
            "com.apple.private.spawn-panic-crash-behavior"
            "com.apple.private.spawn-driver"
        }
        symbol = "posix_spawn"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "exe_boothash_salt"
        }
        symbol = "exe_boothash_salt_generate"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "load_init_program: attempting to load %s\n"
            "load_init_program: failed loading %s: errno %d\n"
            "Process 1 exec of %s failed, errno %d @%s:%d"
            "/sbin/launchd"
        }
        symbol = "load_init_program"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: disallowing arm64e binary with invalid RO range\n"
            "%s: disallowing arm64e binary with invalid dynlinker RO range\n"
            "%s: allowing binary \"%s\" built against preview arm64e ABI\n"
            "%s: (customer builds will need custom boot-args to run this binary!)\n"
            "%s: not running binary \"%s\" built against preview arm64e ABI\n"
            "%s: (to allow this, add \"-arm64e_preview_abi\" to boot-args)\n"
            "%s: disallowing arm64 platform driverkit binary \"%s\", should be arm64e\n"
            "%s: disallowing emulated x86 driverkit binary \"%s\", should be arm64\n"
            "com.apple.developer.web-browser-engine.host"
            "com.apple.developer.web-browser-engine.rendering"
            "com.apple.pac.shared_region_id"
            "setting hardened runtime with entitlement mask= 0x%x on task: pid = %d\n"
            "setting platform binary on task: pid = %d\n"
            "clearing platform binary on task: pid = %d\n"
            "Disabling some mach hardening on task due to 3P plugins: pid = %d\n"
            "com.apple.private.enable-coredump-on-panic-seed-privacy-approved"
            "com.apple.private.enable-coredump-on-panic"
            "%.9s-%d"
        }
        symbol = "exec_mach_imgact"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "/Library/Apple/usr/libexec/oah/libRosettaRuntime"
        }
        symbol = "is_rosetta_supported"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "/dev/fd/%d"
        }
        symbol = "exec_extract_strings"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "/dev/null"
        }
        symbol = "exec_handle_sugid"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "pfz=0x%llx"
            "pfz=0x%x"
            "Failed to add the pfz string with error %d\n"
            "MallocNanoZone=1"
            "stack_guard="
            "malloc_entropy="
            "ptr_munge="
            "main_stack="
            "main_stack=0x%llx,0x%llx,0x%llx,0x%llx"
            "executable_file="
            "executable_file=0x%llx,0x%llx"
            "dyld_file="
            "dyld_file=0x%llx,0x%llx"
            "executable_cdhash="
            "executable_boothash="
            "subsystem_root_path="
            "subsystem_root_path=%s"
            "ptrauth_disabled=1"
            "arm64e_abi="
            "th_port="
            "th_port=0x%x"
            "MallocExperiment="
            "MallocExperiment=0x%llx"
            "Failed to add the libmalloc experiment factors string with error %d\n"
            "dyld_hw_tpro=1"
            "Failed to add dyld hw tpro setting with error %d\n"
            "dyld_hw_tpro_pagers=1"
            "Failed to add dyld hw tpro pager setting with error %d\n"
            "HardenedRuntime=0x%x"
            "Failed to add hardened runtime flag with error %d\n"
        }
        symbol = "exec_add_apple_strings"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s0x%llx"
            ",0x%llx"
        }
        symbol = "exec_add_entropy_key"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "com.apple.developer.kernel.extended-virtual-addressing"
            "com.apple.security.cs.jit-write-allowlist"
            "com.apple.developer.cs.jit-write-allowlist"
            "com.apple.security.cs.jit-write-allowlist-freeze-late"
            "com.apple.developer.cs.jit-write-allowlist-freeze-late"
        }
        symbol = "proc_apply_jit_and_vm_policies"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "exec_resettextvp: expected valid vp @%s:%d"
        }
        symbol = "exec_resettextvp"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "Allowing spawn of iOS binary %s since correct platform was passed in spawn\n"
            "ignoring detached code signature on '%s' with cdhash '%s' because it is invalid, or not a simple adhoc signature.\n"
            "CS Platform Exec Logging: Executing platform signed binary '%s' with cdhash %s\n"
        }
        symbol = "process_signature"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "exit_thread failed to exit @%s:%d"
        }
        symbol = "exit_with_reason"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Process[%d] has no vm space for corpse info.\n"
            "Process[%d] was destined to be corpse. But corpse is disabled by config.\n"
            "Process[%d] has been terminated before it could be converted to a corpse.\n"
            "Process[%d] crashed: %s. Too many corpses being created.\n"
            "pid %d exited -- no exit reason available -- (signal %d, exit %d)\n"
            "pid %d exited -- exit reason namespace %d subcode 0x%llx, description %s\n"
            "preinit"
            "LTE preinit process exited"
            "initproc exited"
            "initproc failed to start"
            "%s[%d] exited"
            "%s -- no exit reason available -- (signal %d, exit status %d %s)"
            "%s %s -- exit reason namespace %d subcode 0x%llx description: %.800s"
            "panic-on-crash disabled via boot-arg\n"
            "proc_memorystatus_remove"
            "Text page corruption detected in dying process %d\n"
            "memorystatus_remove: Process[%d] tried to exit while being frozen. Blocking exit until freeze completes."
        }
        symbol = "proc_prepareexit"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "proc_prepareexit_wait"
            "proc_sigdrain"
            "parent child linkage broken @%s:%d"
        }
        symbol = "proc_exit"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "waitidcoll"
        }
        symbol = "waitid_nocancel"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "Warning : lost p_ru for %s\n"
        }
        symbol = "reap_child_locked"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "exception type %d without a valid proc @%s:%d"
            "[%s%s] sending signal %d to process\n"
            ": killed"
            "[%s: killed] sending signal %d and force exiting process\n"
        }
        symbol = "exit_with_mach_exception"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "cycle in wakelock list @%s:%d"
        }
        symbol = "lf_clearlock"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "fork1 called with unknown kind %d @%s:%d"
        }
        symbol = "fork1"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "Proc_ro_task for newly created proc %p is not NULL @%s:%d"
            "%s: task_create_internal failed.  Code: %d\n"
            "%s: thread_create failed. Code: %d\n"
        }
        symbol = "fork_create_child"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Unable to allocate a new pid @%s:%d"
            "forkproc: persona_proc_inherit failed (persona %d being destroyed?)\n"
        }
        symbol = "forkproc"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "_MALLOC: kalloc returned NULL (potential leak), size %llu @%s:%d"
        }
        symbol = "_MALLOC_external"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "OSMalloc_Tagfree():'%s' has bad state 0x%08X @%s:%d"
        }
        symbol = "OSMalloc_Tagfree_external"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "OSMalloc_Tagrele():'%s' has refcnt 0 @%s:%d"
        }
        symbol = "OSMalloc_Tagrele"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "[%d] code signing monitor denies JIT mapping\n"
        }
        symbol = "mmap"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "** %s: %d[%s] failing madvise(0x%llx,0x%llx,%s)\n"
            "MADV_FREE_REUSABLE"
            "MADV_FREE"
        }
        symbol = "madvise"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s:%d '%s': user_addr 0x%llx user_size 0x%llx cryptid 0x%x ignored\n"
            "%s: unable to create decrypter %s, kr=%d\n"
            "%s: mapping failed with %d\n"
        }
        symbol = "mremap_encrypted"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "persona ref count underflow! @%s:%d"
        }
        symbol = "persona_lookup_and_invalidate"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "persona count underflow! @%s:%d"
        }
        symbol = "persona_put_and_unlock"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "<persona>"
            "ERROR: PID:%d hit proc rlimit in new persona(%d): %s"
        }
        symbol = "persona_proc_adopt"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "chgproccnt: lost user @%s:%d"
        }
        symbol = "chgproccnt"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "proc_parentdropref  -ve ref @%s:%d"
        }
        symbol = "proc_parentdropref"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "proc being freed and unexpected refcount %p:%d:0x%x @%s:%d"
        }
        symbol = "proc_checkdeadrefs"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Unknown format character %c in `%s'\n"
            "pid %ld (%s), uid (%u): unexpected end of string after %% token\n"
        }
        symbol = "proc_core_name"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: callout =%d for zombie %d @%s:%d"
        }
        symbol = "proc_iterate"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "proc_childrenwalk"
        }
        symbol = "proc_childrenwalk"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "pgrp_iterate"
        }
        symbol = "pgrp_iterate"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "low swap: throttling pid %d (%s)\n"
            "low swap: suspending pid %d (%s)\n"
            "low swap: killing pid %d (%s)\n"
        }
        symbol = "proc_dopcontrol"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "low swap: unthrottling pid %d (%s)\n"
            "low swap: resuming pid %d (%s)\n"
            "low swap: attempt to unkill pid %d (%s) ignored\n"
        }
        symbol = "proc_resetpcontrol"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "low swap: triggering no paging space action\n"
            "low swap: killing largest compressed process with pid %d (%s) and size %llu MB\n"
            "low swap: unable to find any eligible processes to take action on\n"
        }
        symbol = "no_paging_space_action"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s: proc_ro already has an owning task @%s:%d"
            "proc_ro_ref_task"
        }
        symbol = "proc_ro_ref_task"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "com.apple.system-task-ports.name.safe"
        }
        symbol = "task_name_for_pid"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "com.apple.private.debug_port"
        }
        symbol = "debug_control_port_for_pid"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "CODE SIGNING: marked invalid by pid %d: p=%d[%s] honoring CS_KILL, final status 0x%x\n"
        }
        symbol = "csops_internal"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "proc_ro->proc backref mismatch: p=%p, ro=%p, ro->pr_proc(ro)=%p @%s:%d"
        }
        symbol = "panic_proc_ro_proc_backref_mismatch"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "proc_limitblock"
        }
        symbol = "setrlimit"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "com.apple.private.vfs.authorized-access"
            "com.apple.private.vfs.skip-mtime-updates"
            "com.apple.private.vfs.allow-low-space-writes"
        }
        symbol = "iopolicysys"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "unknown error %#x @%s:%d"
        }
        symbol = "proc_rlimit_control"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "Quick reboot...\n"
            "syncing disks... "
            "audit_shutdown"
            "/var/log/shutdown/shutdown.trace"
            "shutdown.trace"
            "system_shutdown cluster_push_err failed with ENOSPC %d times\n @%s:%d"
            "kern_shutdown.c"
            "giving up\n"
            "done\n"
            "bufferclean"
            "if_down_all"
        }
        symbol = "reboot_kernel"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "userspace panic: %s"
        }
        symbol = "panic_kernel"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Killing all processes "
            "continuing\n"
        }
        symbol = "proc_shutdown"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "/var/log/kernel-shutdown.log"
            "Failed to open %s: error %d\n"
            "Process shutdown log.  Current time is %lu (in seconds).\n\n"
        }
        symbol = "sd_log"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s[%d] had to be forced closed with exit1().\n"
        }
        symbol = "sd_callback3"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "sigwait with no signal wakeup @%s:%d"
        }
        symbol = "__sigwait_nocancel"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "exc handler"
        }
        symbol = "threadsignal"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "build_signal_reason: unable to allocate signal reason structure.\n"
            "build_signal_reason: unable to allocate signal reason buffer.\n"
            "build_signal_reason: exceeded space in signal reason buf, unable to log PID\n"
            "build_signal_reason: exceeded space in signal reason buf, unable to log procname\n"
        }
        symbol = "build_signal_reason"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "psignal: bad signal number %d @%s:%d"
            "unexpected SIGKILL of %s %s (no reason provided)"
            "unexpected SIGKILL of %s %s with reason -- namespace %d code 0x%llx description %.800s"
        }
        symbol = "psignal_internal"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "filt_signal: detected NOTE_EXIT event @%s:%d"
        }
        symbol = "filt_signal"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "ureadc: non-positive resid @%s:%d"
        }
        symbol = "ureadc"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: bad uio_max_iovs @%s:%d"
            "uio_free"
        }
        symbol = "uio_free"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Sched info changed?! @%s:%d"
            "kern_sysctl.c"
        }
        symbol = "sysctl_sched_stats"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "com.apple.private.read-environment-variables"
        }
        symbol = "sysctl_procargsx"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "com.apple.private.roots-installed-read-write"
            "com.apple.private.roots-installed-read-only"
        }
        symbol = "sysctl_roots_installed"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "Error: Invalid value passed to darkwake sysctl. Acceptable: 0 or 1.\n"
        }
        symbol = "sysctl_toggle_darkwake_mode"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "trying to register a node %p with an invalid oid_number: %d @%s:%d"
            "Use sysctl_register_oid_early to register permanent nodes @%s:%d"
        }
        symbol = "sysctl_register_oid"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Trying to unregister permanent sysctl %p @%s:%d"
        }
        symbol = "sysctl_unregister_oid"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "attempting to register a sysctl at previously registered slot : %d @%s:%d"
        }
        symbol = "sysctl_register_oid_locked"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "NodeExt"
            "Int    "
            "String "
            "Quad   "
            "Opaque "
            "%*s%-3d[%c%c%c%c%c] %s %s\n"
        }
        symbol = "sysctl_sysctl_debug_dump_node"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "com.apple.private.write-kr-experiment-factors"
        }
        symbol = "sysctl_root"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "memorystatus"
            "Could not allocate memorystatus_jetsam_snapshot @%s:%d"
            "fast_jetsam_enabled"
            "max_jetsam_threads"
            "Could not create memorystatus_thread %d @%s:%d"
        }
        symbol = "memorystatus_init"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Active"
            "Inactive"
            "fatal"
            "non-fatal"
            "EXC_RESOURCE -> %s[%d] exceeded mem limit: %s%s %d MB (%s)\n"
        }
        symbol = "memorystatus_log_exception"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "com.apple.private.memorystatus"
        }
        symbol = "memorystatus_control"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "healthy"
            "unhealthy"
            "memorystatus: System is %s. memorystatus_available_pages: %llu compressor_size:%u\n"
            "memorystatus: zone_map_is_exhausted=%d\n"
        }
        symbol = "memorystatus_log_system_health"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "_memstat_schedule_idle_demotion_locked"
            "%s: scheduling demotion to idle band for pid %d (dirty:0x%x).\n"
        }
        symbol = "_memstat_schedule_idle_demotion_locked"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "VM_memorystatus_%d"
            "killing_idle_process_aggressive"
            "killing_top_process_aggressive"
            "memorystatus_sort_by_largest_coalition_locked"
            "memorystatus: c_segment_count=%u major compaction occurred %u seconds ago\n"
            "memorystatus_do_action: Waking up swap thread. memorystatus_available_pages: %llu\n"
            "memorystatus_do_action: Processing swapin queue of length: %u memorystatus_available_pages: %llu\n"
            "memorystatus_kill_hiwat_proc: failed to allocate exit reason\n"
            "memorystatus_kill_processes_aggressive: failed to allocate exit reason\n"
            "memorystatus: aggressively killing up to %d processes below band %d.\n"
            "memorystatus: aggressive%d: rewinding band %d, %s(%d) moved or exiting.\n"
            "memorystatus: aggressive%d: skipping %d [%s] (exiting?)\n"
            "memorystatus: killing %s [%d] in band %d with high relaunch probability\n"
            "memorystatus: %s%d pid %d [%s] (%s %d) - memorystatus_available_pages: %llu\n"
            "memorystatus: giving up aggressive kill after killing %d processes below band %d.\n"
            "%s: WARNING: more than %d leaders in priority band [%d]\n"
        }
        symbol = "memorystatus_thread"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "killing_highwater_process"
            "killing_idle_process"
            "killing_top_process"
            "memorystatus: reclaimed %llu pages (%llu purged, %llu unsecluded) from pid %d [%s] and avoided %s\n"
            "%lu.%03d memorystatus: %s pid %d [%s] (%s %d) %lluKB - memorystatus_available_pages: %llu compressor_size:%u\n"
        }
        symbol = "memorystatus_kill_proc"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "FOREGROUND"
            "AUDIO_AND_ACCESSORY"
            "CONDUCTOR"
            "DRIVER_APPLE"
            "EXECUTIVE"
            "IMPORTANT"
            "CRITICAL"
            "memorystatus: killing process %d [%s] in high band %s (%d) - memorystatus_available_pages: %llu\n"
        }
        symbol = "memorystatus_do_kill"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Caught sending pid %d a critical warning for a fatal limit. @%s:%d"
        }
        symbol = "memorystatus_warn_process"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Unexpected non-jetsam pressure level %d @%s:%d"
            "memorystatus: issuing %s jetsam pressure notification to %d waiters"
        }
        symbol = "memorystatus_broadcast_jetsam_pressure"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "ephemeral-storage"
            "use-recovery-securityd"
        }
        symbol = "sysctl_load_devicetree_entries"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "iPad8,6"
        }
        symbol = "sysctl_hw_generic"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "kernelmanagerd"
        }
        symbol = "sysctl_use_kernelmanagerd"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: invalid size (%ld) for cluster %p @%s:%d"
            "%s: freeing jumbo cluster to an empty pool @%s:%d"
        }
        symbol = "mbuf_freecluster"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "tag->m_tag_len >= sizeof(*p)"
            "p->da_length > 0 && p->da_length <= MBUF_DRVAUX_MAXLEN"
        }
        symbol = "mbuf_find_drvaux"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "(*flagsp & (MBUF_PKTAUXF_INET_RESOLVE_RTR | MBUF_PKTAUXF_INET6_RESOLVE_RTR)) != (MBUF_PKTAUXF_INET_RESOLVE_RTR | MBUF_PKTAUXF_INET6_RESOLVE_RTR)"
        }
        symbol = "mbuf_pkthdr_aux_flags"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "WARNING: preposterous time in Real Time Clock"
            " -- CHECK AND RESET THE DATE!\n"
        }
        symbol = "inittodr"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "image4 interface not available @%s:%d"
            "amfi interface not available @%s:%d"
            "amfi interface is stale: %u @%s:%d"
        }
        symbol = "trust_cache_runtime_init"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "unable to load trust cache (type: %u): no img4_object provided\n"
            "overflow on the img4 object: %p | %lu @%s:%d"
            "unable to load trust cache (type: %u): img4_ext_manifest expected\n"
            "overflow on the ext manifest: %p | %lu @%s:%d"
            "unable to load trust cache (type: %u): img4_aux_manifest expected\n"
            "unable to extract payload and manifest from object\n"
            "unable to find payload within img4 object\n"
            "unable to find manifest within img4 object\n"
            "unable to load trust cache: invalid type: %u\n"
            "unable to load trust cache: unknown type: %u\n"
            "unable to load trust cache (type: %u): unsatisfied entitlement\n"
            "disallowed to load multiple kTCTypeCryptex1BootOS trust caches\n"
            "disallowed to load multiple kTCTypeCryptex1BootApp trust caches\n"
            "unable to load trust cache (type: %u): %d\n"
            "successfully loaded trust cache of type: %u\n"
        }
        symbol = "load_trust_cache_with_type"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "unable to load legacy trust cache: no module provided\n"
            "overflow on the module: %p | %lu @%s:%d"
            "legacy trust caches are not supported on this platform @%s:%d"
        }
        symbol = "load_legacy_trust_cache"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "unable to query trust caches: no cdhash provided\n"
        }
        symbol = "query_trust_cache"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "unable to load static trust cache: interface not supported\n"
            "unable to find chosen/memory-map in the device tree: %d\n"
            "unexpected size for TrustCache property: %u != %zu @%s:%d"
            "trust cache segment is zero length but trust caches are available: %u @%s:%d"
            "no external trust caches found (segment length is zero)\n"
            "trust cache segment isn't zero but no trust caches available: %lu @%s:%d"
            "trust cache segment length smaller than required: %lu | %lu @%s:%d"
            "attempting to load %u external trust cache modules\n"
            "trust cache module start overflows: %u | %lu | %u @%s:%d"
            "trust cache module begins after segment ends: %u | %lx | %lx @%s:%d"
            "skipping engineering trust cache module: %u\n"
            "failed to load static trust cache module: %u @%s:%d"
            "completed loading external trust cache modules\n"
        }
        symbol = "load_static_trust_cache"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "attempted to query static trust cache capabilities without init @%s:%d"
            "unable to get static trust cache capabilities: interface not supported\n"
        }
        symbol = "static_trust_cache_capabilities"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "overflow on pmap img4 payload: %lu @%s:%d"
            "unable to allocate memory for pmap image4 payload: %d\n"
            "unable to allocate memory for auxiliary image4 manifest: %d\n"
        }
        symbol = "ppl_load_trust_cache"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: unable to allocate %lu bytes\n"
            "%s: invalid allocation\n"
        }
        symbol = "code_signing_allocate"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: invalid pointer provided @%s:%d"
            "%s: address provided: %p @%s:%d"
        }
        symbol = "code_signing_deallocate"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "attempted to disable a code signing feature invalidly: %u @%s:%d"
        }
        symbol = "disable_code_signing_feature"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "coretrust interface not available @%s:%d"
            "initialized XNU provisioning profile data\n"
        }
        symbol = "csm_initialize_provisioning_profiles"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "unable to register profile with monitor: %d\n"
        }
        symbol = "csm_register_provisioning_profile"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "unable to associate profile: %d\n"
        }
        symbol = "csm_associate_provisioning_profile"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s: provided a NULL process\n"
            "address_space_debugged"
        }
        symbol = "address_space_debugged"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "[%s] code-signing-violation at %p\n"
        }
        symbol = "csm_code_signing_violation"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "image4 dispatch: no input data: %llu\n"
            "image4_ dispatch: overflow on input: %p | %lu @%s:%d"
            "image4 dispatch: invalid input: %llu | %lu\n"
            "image4 dispatch: pin root not supported on this platform\n"
            "image4 dispatch: evaluate trust not supported on this platform\n"
        }
        symbol = "kernel_image4_monitor_trap"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "unable to unregister profile from monitor: %d | %p\n @%s:%d"
        }
        symbol = "csm_free_provisioning_profiles"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "entered lockdown mode policy for the PPL"
        }
        symbol = "csm_check_lockdown_mode"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "attempted to load a too-large profile: %lu bytes @%s:%d"
            "ppl.c"
            "unable to allocate memory for pmap profile payload: %d\n"
        }
        symbol = "ppl_register_provisioning_profile"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "invalid object execution request: no payload\n"
            "unable to allocate memory for image4 payload: %d\n"
            "unable to execute image4 object: %d\n"
        }
        symbol = "ppl_image4_execute_object"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "invalid object copy request: no object input buffer\n"
            "invalid object copy request: no object input length\n"
            "unable to allocate memory for image4 object: %d\n"
            "unable to copy image4 object: %d\n"
        }
        symbol = "ppl_image4_copy_object"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "explicit monitor-exports-get not required for the PPL\n"
        }
        symbol = "kernel_image4_get_monitor_exports"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "explicit release-type-set set not required for the PPL\n"
        }
        symbol = "kernel_image4_set_release_type"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "explicit BNCH-shadow-set not required for the PPL\n"
        }
        symbol = "kernel_image4_set_release_type_0"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "user space RB_PANIC message copyin failed"
        }
        symbol = "reboot"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "user space panic_with_data message copyin failed"
            "Panic called from Process: %s Message: %s"
        }
        symbol = "sys_panic_with_data"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "lockdown_mode: error getting state from nvram\n"
            "lockdown_mode: lockdown mode in nvram is %s\n"
        }
        symbol = "lockdown_mode_init"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "get_lockdown_mode_state"
        }
        symbol = "get_lockdown_mode_state"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "sshot-entitlement-report"
            "sshot-entitlement-refuse"
        }
        symbol = "atboot_stackshot_entitlement"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "com.apple.private.stackshot"
        }
        symbol = "stack_snapshot_with_config"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "com.apple.private.stackshot.stats"
        }
        symbol = "sysctl_stackshot_stats"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Firehose disabled: Logging disabled by ATM\n"
            "firehose_chunk_count"
            "firehose_io_pages"
            "illegal firehose configuration %u/%u, using defaults\n"
            "Firehose configured: %u chunks, %u io pages\n"
        }
        symbol = "oslog_init_firehose"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "log_dmesg: unable to allocate memory\n"
        }
        symbol = "log_dmesg"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Cannot resize system message buffer: Not enough memory\n"
            "System message buffer configured: %lu bytes\n"
        }
        symbol = "sysctl_kern_msgbuf"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "OSLog stream disabled: Logging disabled by ATM\n"
            "OSLog stream configured: stream: %lu bytes, cache: %lu bytes\n"
        }
        symbol = "oslog_stream_init"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Time 0x%lx Message "
            "PMRD: PowerChangeDone: %s->%s\n"
            "use _calendarWakeAlarmUTC\n"
            "accelerate _aotWakeTime for exit\n"
            "accelerate _aotWakeTime for assertion\n"
            "aotSleep at %04d/%02d/%d %02d:%02d:%02d sched: %04d/%02d/%d %02d:%02d:%02d\n"
            "PMRD: Updated sleepDelaysReport %lu %lu\n"
            "PMRD: System %sSleep\n"
            "gIOLastWakeAbsTime: %lld\n"
            "aotWake at %04d/%02d/%d %02d:%02d:%02d sched: %04d/%02d/%d %02d:%02d:%02d\n"
            "PMRD: System %sWake\n"
            "SafeSleep "
            "RTC debug alarm"
            "hibernate user wake"
            "PMRD: Force re-evaluating aggressiveness\n"
            "PMRD: clamshell closed %d, disabled %d/%x, desktopMode %d, ac %d\n"
        }
        symbol = "__ZN14IOPMrootDomain15powerChangeDoneEm"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "com.apple.private.getprivatesysid"
        }
        symbol = "gethostuuid"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "ledger syscall logic error -- command type %d @%s:%d"
        }
        symbol = "ledger"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "fp_iocount overdecrement! @%s:%d"
        }
        symbol = "seldrop_locked"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "com.apple.private.coredump-encryption-key"
            "Failed to handle the new encryption key. Error 0x%x"
        }
        symbol = "sysctl_coredump_encryption_key_update"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "size greater than LONG_MAX @%s:%d"
            "Expected pipe buffer wraparound disappeared @%s:%d"
            "Expected wraparound bad @%s:%d"
            "Pipe buffer overflow @%s:%d"
            "pipewr"
        }
        symbol = "pipe_write"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "pipecl"
            "double free of pipe %p in pair %p @%s:%d"
        }
        symbol = "pipeclose"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "com.apple.private.record_system_event"
        }
        symbol = "_sys_record_system_event"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "systemdomain == NULL"
        }
        symbol = "systemdomain_init"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "unknown coalition policy suppress value %d @%s:%d"
            "sys_coalition.c"
        }
        symbol = "sys_coalition_policy_get"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: Invalid ulock opcode %d addr %p @%s:%d"
            "kdp_ulock_find_owner"
            "sys_ulock.c"
        }
        symbol = "kdp_ulock_find_owner"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s>thread_max=%d, ull_hash_buckets=%d\n"
            "ulock_initialize"
        }
        symbol = "ulock_initialize"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "ttywai"
        }
        symbol = "ttywait"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "ttyin"
            "ttyhup"
            "ttybg3"
        }
        symbol = "ttread"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "ttydcd"
            "ttywri"
        }
        symbol = "ttwrite"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "load: %d.%02d "
            "not a controlling terminal\n"
            "no foreground process group\n"
            "foreground process without thread\n"
            " cmd: %s %d %s %ld.%02du %ld.%02ds\n"
        }
        symbol = "ttyinfo_locked"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "        "
        }
        symbol = "ttyoutput"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "ttyrub: would panic c = %d, val = %d\n"
        }
        symbol = "ttyrub"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "tty kevent: unexpected filter: %d, kn = %p, tty = %p @%s:%d"
        }
        symbol = "filt_tty_common"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "ptsopen"
        }
        symbol = "ptsopen"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "ptcread"
        }
        symbol = "ptcread"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "ptcwrite"
        }
        symbol = "ptcwrite"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "/dev/%s"
        }
        symbol = "_devfs_setattr"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "ptmx_init: failed to obtain /dev/ptmx major number\n"
            "Failed to set flags on ptmx cdevsw entry. @%s:%d"
        }
        symbol = "ptmx_init"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "ttys%03d"
            "devfs_make_node() call failed for ptmx_get_ioctl()!!!!\n"
        }
        symbol = "ptmx_get_ioctl"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "/dev/ttys%03d"
        }
        symbol = "ptmx_get_name"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "tty%c%x"
            "pty%c%x"
            "Can't mark ptc as kqueue ok @%s:%d"
            "Can't mark pts as kqueue ok @%s:%d"
        }
        symbol = "pty_init"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "/dev/tty%c%x"
        }
        symbol = "pty_get_name_0"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "CODE SIGNING: CS Blob length overflow for addr: %p @%s:%d"
            "CODE SIGNING: CS Blob length overflow for blob at: %p @%s:%d"
            "CODE SIGNING: CS Blob length overflow for code directory blob at: %p @%s:%d"
        }
        symbol = "csblob_find_blob_bytes"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "ubc_setsize: ubc_create_upl (error = %d) @%s:%d"
            "ubc_setsize: invalidate failed (error = %d)\n"
        }
        symbol = "ubc_setsize_ex"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s : VNODE_REF_FORCE failed @%s:%d"
        }
        symbol = "ubc_map"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "ubc_unmap"
        }
        symbol = "ubc_unmap"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "unable to create a validated cs_blob object: %d\n"
            "validation of code signature failed through MACF policy: %d\n"
            "dyld simulator runtime is not apple signed: proc: %d\n"
            "CODE SIGNING: proc %d(%s) loaded %s signatures for file (%s) range 0x%llx:0x%llx flags 0x%x\n"
            "detached"
            "embedded"
            "check_signature[pid: %d]: error = %d\n"
            "reconstitution required when code signing monitor is enabled\n"
            "unable to register code signature with monitor: %d\n"
            "unable to verify code signature with monitor: %d\n"
            "unable to disassociate profile from code signature: %d\n"
            "unable to associate OSEntitlements with monitor: %d\n"
        }
        symbol = "ubc_cs_blob_add"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "malformed code signature supplement blob: %d\n"
            "CODE SIGNING: proc %d(%s) supplemental signature for file (%s) is not a supplemental.\n"
            "CODE SIGNING: proc %d(%s) supplemental signature for file (%s) does not match any attached cdhash (error: %d).\n"
            "check_supplemental_signature[pid: %d], error = %d\n"
            "csb_next does not match expected NULL value @%s:%d"
            "CODE SIGNING: proc %d(%s) loaded supplemental signature for file (%s) range 0x%llx:0x%llx\n"
            "ubc_cs_blob_add_supplement[pid: %d]: error = %d\n"
        }
        symbol = "ubc_cs_blob_add_supplement"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "csvnode: name: %s\n"
            "csvnode: range: %lu -> %lu flags: 0x%08x platform: %s path: %s team: %s\n"
            "<NO-TEAM>"
        }
        symbol = "csvnode_print_debug"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "CODESIGNING: can not re-validate a previously invalidated blob, reboot or create a new file.\n"
            "CODESIGNING: revalidate: not inline revalidating reconstituted signature.\n"
            "revalidate: check_signature[pid: %d], error = %d\n"
        }
        symbol = "ubc_cs_blob_revalidate"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Reseting cs_blob cache from all vnodes. \n"
        }
        symbol = "cs_blob_reset_cache"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "ubc_info_init: memory_object_create_named returned %d @%s:%d"
        }
        symbol = "ubc_info_init_internal"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "validated CodeDirectory but unsupported type @%s:%d"
        }
        symbol = "cs_blob_init_validated"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "cs_blob vnode backref mismatch: blob=%p, vp=%p, blob->csb_vnode=%p @%s:%d"
        }
        symbol = "panic_cs_blob_backref_mismatch"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "unable to reconstitute code signature through monitor: %d\n"
            "validated cs_blob has no code directory @%s:%d"
            "unable to allocate memory for 2nd stage reconstitution: %d\n"
            "unable to validate code signature after 2nd stage reconstitution: %d\n"
        }
        symbol = "reconstitute_code_signature_2nd_stage"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "unable to validate security-critical blob: %d [%u|%u]\n"
        }
        symbol = "validate_auxiliary_signed_blobs"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "unable to accelerate entitlements through the monitor: %d\n"
            "unable to adjust OSEntitlements context with monitor: %d\n"
            "unable to adjust OSEntitlements context without monitor: %d\n"
        }
        symbol = "accelerate_entitlement_queries"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "found team-id %s in cdblob\n"
        }
        symbol = "csblob_parse_teamid"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "CodeDirectory type %d rank %d at slot 0x%x index %d\n"
            "using CodeDirectory type %d (rank %d)\n"
            "multiple hash=%d CodeDirectories in signature; rejecting\n"
            "multiple entitlements blobs\n"
            "multiple der entitlements blobs\n"
            "multiple self constraint blobs\n"
            "multiple parent constraint blobs\n"
            "multiple responsible process constraint blobs\n"
            "multiple library constraint blobs\n"
        }
        symbol = "cs_validate_csblob"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "disallowing unsupported code signature page shift: %u\n"
        }
        symbol = "cs_validate_codedirectory"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "unknown hash type ? @%s:%d"
            "hash size too large @%s:%d"
            "offset not aligned to cshash boundary @%s:%d"
            "CODE SIGNING: cs_validate_page: mobj %p off 0x%llx: no hash to validate !?\n"
            "CODE SIGNING: cs_validate_page: mobj %p off 0x%llx size 0x%lx: actual [0x%x 0x%x 0x%x 0x%x 0x%x] != expected [0x%x 0x%x 0x%x 0x%x 0x%x]\n"
            "CODE SIGNING: cs_validate_page: mobj %p off 0x%llx size 0x%lx: SHA1 OK\n"
            "CODE SIGNING: Scatter extends past Code Directory\n"
            "CODE SIGNING: unordered Scatter, prev base %d, cur base %d\n"
        }
        symbol = "cs_validate_hash"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: domain (%d,%s) already exists for %s @%s:%d"
            "%s: domain %p (%d,%s) is already associated with %p (%d,%s)\n @%s:%d"
            "%s: domain (%d,%s) protocols need to added via net_add_proto\n @%s:%d"
        }
        symbol = "net_add_domain_old"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "dp1->dom_old != NULL"
        }
        symbol = "net_del_domain_old"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "%s: domain (%d,%s), proto %d has non-NULL pr_domain! @%s:%d"
        }
        symbol = "_net_add_proto$XNU_INTERNAL"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: domain (%d,%s), proto %d: pr_fasttimo is deprecated and won't be called\n"
            "%s: domain (%d,%s), proto %d: pr_slowtimo is deprecated and won't be called\n"
            "%s: domain (%d,%s), proto %d: failed to attach, error %d\n"
        }
        symbol = "net_add_proto_old"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "protoctl_event_enqueue_nwk_wq_entry"
            "p_laddr->sa_len <= sizeof(p_protoctl_ev->protoctl_ev_arg.laddr)"
            "p_raddr->sa_len <= sizeof(p_protoctl_ev->protoctl_ev_arg.raddr)"
            "%s: eventhandler enqueuing event of type=protoctl_event event_code=%d"
        }
        symbol = "protoctl_event_enqueue_nwk_wq_entry"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "dp->dom_flags & DOM_OLD"
            "dp->dom_old != NULL"
        }
        symbol = "dom_init_old"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "pp->pr_domain == dp"
            "pp->pr_protosw == pp"
        }
        symbol = "detach_proto"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "pp->pr_domain == NULL"
            "pp->pr_protosw == NULL"
        }
        symbol = "attach_proto"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "pp->pr_flags & PR_OLD"
            "pp->pr_old != NULL"
        }
        symbol = "pr_init_old"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "mbuf_class_under_pressure"
            "%s memory-pressure on mbuf due to class %u, total %llu free %llu max %u"
        }
        symbol = "mbuf_class_under_pressure"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "nmbclusters != 0 && !(nmbclusters & 0x1)"
            "m_minlimit(m_class(m)) == 0 || m_total(m_class(m)) >= m_minlimit(m_class(m))"
            "%s: done [%d MB total pool size, (%d/%d) split]\n"
            "mbinit"
            "bigcl"
            "mbuf_cl"
            "mbuf_bigcl"
            "16kcl"
            "mbuf_16kcl"
        }
        symbol = "mbinit"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "!(MEXT_FLAGS(m) & EXTF_PAIRED) && MEXT_PMBUF(m) == NULL"
            "m->m_type != MT_FREE"
        }
        symbol = "m_clattach"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "MBUF_IS_COMPOSITE(m) && m_get_ext_free(m) == NULL"
        }
        symbol = "m_getcl"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "to->m_flags & M_PKTHDR"
        }
        symbol = "m_copy_classifier"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "bufsize != m_maxsize(MC_16KCL) || njcl > 0"
            "%s: File a radar related to <rdar://10146739>. \t\t\tneeded = %u, pnum = %u, num_needed = %u \n"
            "m_getpackets_internal"
        }
        symbol = "m_getpackets_internal"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "njcl > 0"
            "m_free_func == NULL || m_free_func == m_bigfree || m_free_func == m_16kfree"
            "m_allocpacket_internal *numlist is 0"
            "m_allocpacket_internal wantsize unsupported"
            "m_allocpacket_internal nsegs > *maxsegments"
        }
        symbol = "m_allocpacket_internal"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "len <= MHLEN"
            "len <= MLEN"
        }
        symbol = "m_prepend"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "m_copym: invalid offset %d or len %d @%s:%d"
            "(mode != M_COPYM_MUST_COPY_HDR && mode != M_COPYM_MUST_MOVE_HDR) || (m->m_flags & M_PKTHDR)"
            "m_copym: len != M_COPYALL @%s:%d"
            "m_copym_mode"
        }
        symbol = "m_copym_mode"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "m_copym_with_hdrs"
        }
        symbol = "m_copym_with_hdrs"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: n == NULL @%s:%d"
            "%s: failed negative len %d"
            "%s: failed len %d too big"
            "%s: m_data out of bounds"
        }
        symbol = "m_pullup"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "len >= 0 && dstoff >= 0"
        }
        symbol = "m_copyup"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "(copyhdr == 1 && m->m_len <= MHLEN) || (copyhdr == 0 && m->m_len <= MLEN)"
        }
        symbol = "m_dup"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "!(m->m_flags & M_PKTHDR)"
            "%s: cannot set M_PKTHDR on altered mbuf %llx, m_data %llx (expected %llx), m_len %d (expected 0)\n"
            "m_reinit"
            "(m->m_flags & M_EXT) || m->m_data == (uintptr_t)m->m_dat"
        }
        symbol = "m_reinit"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "MEXT_REF(m) == MEXT_MINREF(m)"
            "MEXT_PREF(m) == MEXT_MINREF(m)"
            "extbuf != NULL && rfa != NULL"
        }
        symbol = "m_ext_paired_activate"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Invalid attempt to modify guarded module-private area: mbuf %p, pkt_flags 0x%x\n"
        }
        symbol = "m_scratch_init"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Invalid attempt to access guarded module-private area: mbuf %p, pkt_flags 0x%x\n"
        }
        symbol = "mbuf_get_driver_scratch"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "m_get_rfa(m) != NULL && MBUF_IS_COMPOSITE(m)"
        }
        symbol = "mz_composite_build"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "(m->m_flags & M_EXT) && (MEXT_FLAGS(m) & EXTF_PAIRED)"
            "m_free_func != NULL"
        }
        symbol = "m_free_paired"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "remain <= MLEN"
        }
        symbol = "m_split0"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "mp0 != NULL"
            "*mp0 != NULL"
            "(flags & M_COPYBACK0_PRESERVE) == 0 || cp == NULL"
            "(flags & M_COPYBACK0_COPYBACK) == 0 || cp != NULL"
            "tspace > 0"
            "off == 0 || eatlen >= mlen"
            "len >= mlen"
            "flags & M_COPYBACK0_EXTEND"
        }
        symbol = "m_copyback0"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "len > 0"
        }
        symbol = "m_normalize"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "mbuf_watchdog_defunct"
            "%s: defuncting all sockets from %s.%d"
        }
        symbol = "mbuf_watchdog_defunct"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "len >= 0 && off >= 0"
            "m == NULL in m_pulldown() @%s:%d"
        }
        symbol = "m_pulldown"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "t != NULL"
        }
        symbol = "m_tag_delete"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "(to->m_flags & M_PKTHDR) && (from->m_flags & M_PKTHDR)"
        }
        symbol = "m_tag_copy_chain"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: invalid mbuf chain %p [off %u, len %u] @%s:%d"
            "m_adj_sum16"
        }
        symbol = "m_adj_sum16"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "IS_P2ALIGNED(tag, sizeof(uint64_t))"
            "len == 0"
            "len != 0"
            "IS_P2ALIGNED(tag->m_tag_data, sizeof(uint64_t))"
        }
        symbol = "m_tag_alloc"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "localdomain == NULL"
        }
        symbol = "pre_unp_init"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "socketinit: already called...\n"
            "socache zone"
        }
        symbol = "socketinit"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "aso != NULL"
            "so_pcb not NULL after pru_attach error %d for dom %d, proto %d, type %d"
        }
        symbol = "socreate_internal"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "sobindlock"
        }
        symbol = "sobindlock"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "solisten"
        }
        symbol = "solisten"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "sofree: not queued\n"
        }
        symbol = "sofreelastref"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "soclose: so=%p refcount=0 @%s:%d"
            "%s sp %p in so_incomp but !SS_INCOMP @%s:%d"
            "%s sp %p in so_comp but !SS_COMP @%s:%d"
            "soclose"
            "soclose: usecount is zero so=%p @%s:%d"
            "soclose: NOFDREF @%s:%d"
        }
        symbol = "soclose_locked"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "soclose: retaincnt non null and so=%p usecount=%d\n @%s:%d"
        }
        symbol = "soclose"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "soaccept: !NOFDREF @%s:%d"
        }
        symbol = "soacceptlock"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "soconnectlock"
        }
        symbol = "soconnectlock"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "soconnectxlocked"
        }
        symbol = "soconnectxlocked"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s:%d so %llx ignore SS_CANTSENDMORE\n"
        }
        symbol = "sosendcheck"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "sosend so %p resid %lld > orig_resid %lld proc %s:%d @%s:%d"
            "sosend: so_gencnt %llu resid %lld > orig_resid %lld proc %s:%d"
        }
        symbol = "sosend"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "top != NULL && (control == NULL || top->m_flags & M_PKTHDR)"
        }
        symbol = "sosend_reinject"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s:%d so %llx ignore SS_CANTRCVMORE\n"
            "%s: after 2nd sblock so=%p ref=%d on socket @%s:%d"
            "%s: post-control !sync so=%p m=%p nextrecord=%p\n @%s:%d"
        }
        symbol = "soreceive"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "sooptcopyin_bindtodevice"
            "%s: sopt_valsize %lu > maxlen %lu"
        }
        symbol = "sooptcopyin_bindtodevice"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "%s[%d, %s]: so 0x%llu [%s %s:%d -> %s:%d] is now marked as %seligible for defunct\n"
            "%s[%d, %s]: so 0x%llu [%d,%d] is now marked as %seligible for defunct\n"
            "setsockopt: SO_APPLICATION_ID - wrong uid"
            "setsockopt: SO_APPLICATION_ID - failed to set e_uuid"
        }
        symbol = "sosetoptlock"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "soopt_mcopyin @%s:%d"
        }
        symbol = "soopt_mcopyin"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%p:%p "
        }
        symbol = "solockhistory_nr"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: SB_DROP not set @%s:%d"
            "%s[%d, %s]: (target pid %d name %s level %d) so 0x%llu [%d,%d] is not eligible for defunct (%d)\n"
            "%s[%d, %s]: (target pid %d name %s level %d) so 0x%llu [%d,%d] defunct by force (%d)\n"
            "%s[%d, %s]: (target pid %d name %s level %d) so 0x%llu [%d,%d] extend bk idle (%d)\n"
            "%s[%d, %s]: (target pid %d name %s level %d) so 0x%llu [%d,%d] %s defunct%s\n"
            "is already"
            "marked as"
            " extbkidle"
        }
        symbol = "sosetdefunct"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s improperly called @%s:%d"
            "%s[%d, %s]: (target pid %d name %s level %d) so 0x%llu [%s %s:%d -> %s:%d] is now defunct [rcv_si 0x%x, snd_si 0x%x, rcv_fl 0x%x,  snd_fl 0x%x]\n"
            "%s[%d, %s]: (target pid %d name %s level %d) so 0x%llu [%d,%d] is now defunct [rcv_si 0x%x, snd_si 0x%x, rcv_fl 0x%x, snd_fl 0x%x]\n"
        }
        symbol = "sodefunct"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s[%d, %s]: (target pid %d name %s) so 0x%llu [%d,%d] resumed from bk idle\n"
            "soresume"
        }
        symbol = "soresume"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s[%d, %s]: so 0x%llu [%d,%d] %s marked for extended bk idle\n"
            "so_set_extended_bk_idle"
        }
        symbol = "so_set_extended_bk_idle"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s[%d, %s]: so 0x%llu [%d,%d]\n"
            "so_check_extended_bk_idle_time"
        }
        symbol = "so_check_extended_bk_idle_time"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "%s[%s,%d]: so 0x%llx [%d,%d] epid %d (%s) euuid %s%s\n"
            "%s[%s,%d]: so 0x%llx [%d,%d] epid %d (%s) ERROR (%d)\n"
            "PROC_NULL"
        }
        symbol = "so_set_effective_pid"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s[%s,%d]: so 0x%llx [%d,%d] epid %d euuid %s%s\n"
            "%s[%s,%d]: so 0x%llx [%d,%d] euuid %s ERROR (%d)\n"
        }
        symbol = "so_set_effective_uuid"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "assertion failed: %s, file: %s, line: %d @%s:%d"
        }
        symbol = "assfail"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "*mp != NULL"
            "sosend_list: so->so_type != SOCK_DGRAM error %d"
            "sosend_list: atomic == 0 error %d"
            "sosend_list: SS_ISCONNECTED not set error: %d"
            "sosend_list: flags 0x%x error %d"
            "sosend_list: sosendcheck error %d"
            "sosend_list: sflt_data_out error %d"
            "sosend_list: cfil_sock_data_out error %d"
            "sosend_list: pru_send_list error %d"
            "sosend_list: pru_send error %d"
            "sosend_list: m_freem_list(top) with error %d"
        }
        symbol = "sosend_list"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: about to create invalid socketbuf @%s:%d"
            "soreceive_addr"
        }
        symbol = "soreceive_addr"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "cm->cmsg_len <= rights->m_len"
        }
        symbol = "soreceive_ctl"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "sbwait_nointr"
            "%s: 2 sb=%p sb_flags=0x%x sb_so=%p usecount=%d lr=%p lrh= %s\n @%s:%d"
        }
        symbol = "sbwait"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s[%d, %s]: defunct so 0x%llu [%d,%d] si 0x%x, fl 0x%x [%s]\n"
            "sowakeup"
        }
        symbol = "sowakeup"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "sbappendstream: nexpkt %p || mb %p != lastrecord %p @%s:%d"
            "sbappendstream"
            "sbappendstream 1"
            "sbappendstream 2"
        }
        symbol = "sbappendstream"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "sblastrecordchk: mb 0x%llx lastrecord 0x%llx last 0x%llx\n"
            "packet chain:\n"
            "\t0x%llx\n"
            "sblastrecordchk from %s @%s:%d"
        }
        symbol = "sblastrecordchk"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "sblastmbufchk: mb 0x%llx mbtail 0x%llx last 0x%llx\n"
            "packet tree:\n"
            "0x%llx "
            "sblastmbufchk from %s @%s:%d"
        }
        symbol = "sblastmbufchk"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "sbconcat_mbufs @%s:%d"
        }
        symbol = "sbconcat_mbufs"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "sbappendchain"
            "sbappendadddr 2"
        }
        symbol = "sbappendchain"
        caller = "?"
    }
    new {
        args = 4
        anchors {
            "sbappendaddrorfree @%s:%d"
            "sbappendaddr"
            "sbappendadddr 1"
        }
        symbol = "sbappendaddr"
        caller = "?"
    }
    new {
        args = 3
        anchors {
            "sbappendcontrol"
            "sbappendcontrol @%s:%d"
            "sbappendcontrol 1"
            "sbappendcontrol_internal"
            "sbappendcontrol 2"
        }
        symbol = "sbappendcontrol"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "m == NULL || (m->m_flags & M_PKTHDR)"
            "(sb->sb_flags & (SB_RECV | SB_NOCOMPRESS)) == (SB_RECV | SB_NOCOMPRESS)"
            "%s: nexpkt %p || mb %p != lastrecord %p @%s:%d"
        }
        symbol = "sbappendmptcpstream_rcv"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "sbdrop - count not zero\n"
        }
        symbol = "sbdrop"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "(flags & SBL_VALID) == flags"
            "sb_lock_nointr"
            "sb_lock"
        }
        symbol = "sblock"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "(sb->sb_flags & SB_LOCK) || (so->so_state & SS_DEFUNCT) || (so->so_flags1 & SOF1_DEFUNCTINPROG)"
        }
        symbol = "sbunlock"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "soevent"
            "%s[%d]: so %llu [%d,%d] epid %llu euuid %s%s has %d redundant events supressed\n"
            "%s[%d]: so %llu [%d,%d] epid %llu euuid %s%s event posted\n"
            "%s: SO_FILT_HINT_WAKE_PKT so %p"
        }
        symbol = "soevent"
        caller = "?"
    }
    new {
        args = 3
        anchors {
            "sbappend 1"
            "sbappend 2"
            "sbappend 3"
        }
        symbol = "sbappend_common"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "sbappendrecord 1"
            "sbappendrecord 2"
            "sbappendrecord 3"
        }
        symbol = "sbappendrecord_common"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "semi-panic: sbcompress\n"
            "sbcompress"
        }
        symbol = "sbcompress"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "accept: head=%p refcount=%d @%s:%d"
            "accept: 2 head=%p refcount=%d @%s:%d"
        }
        symbol = "accept_nocancel"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "buflen <= SOCK_MAXADDRLEN"
        }
        symbol = "sockargs"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "connectitx"
        }
        symbol = "connectx"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "connectit"
        }
        symbol = "connect_nocancel"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "cp_size > buflen, something wrong with alignment! @%s:%d"
        }
        symbol = "copyout_control"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "alloc_sendpkt"
            "%s: blocking allocation returned NULL @%s:%d"
        }
        symbol = "alloc_sendpkt"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "peer is connected but has no socket? @%s:%d"
        }
        symbol = "uipc_ctloutput"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "unknown socket type %d in unp_connect2 @%s:%d"
        }
        symbol = "unp_connect2"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "unp_lock: so=%p NO PCB! lr=%p ref=0x%x @%s:%d"
            "unp_lock: so=%p so_pcb=%p lr=%p ref=0x%x @%s:%d"
        }
        symbol = "unp_lock"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "unp_unlock: so=%p usecount=%x @%s:%d"
            "unp_unlock: so=%p NO PCB usecount=%x @%s:%d"
        }
        symbol = "unp_unlock"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "unp_getlock: so=%p usecount=%x @%s:%d"
            "unp_getlock: so=%p NULL so_pcb @%s:%d"
        }
        symbol = "unp_getlock"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "unpdisconnect"
            "unp_conn became NULL after sleep @%s:%d"
            "unknown socket type %d @%s:%d"
        }
        symbol = "unp_disconnect"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "uipc_accept"
            "%s: peer disconnected unp_gencnt %llu"
        }
        symbol = "uipc_accept"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "unp_attach @%s:%d"
        }
        symbol = "uipc_attach"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "uipc_rcvd DGRAM? @%s:%d"
            "uipc_rcvd unknown socktype @%s:%d"
        }
        symbol = "uipc_rcvd"
        caller = "?"
    }
    new {
        args = 4
        anchors {
            "uipc_send connected but no connection? socket state: %x socket flags: %x socket flags1: %x. @%s:%d"
            "uipc_send"
            "uipc_send unknown socktype @%s:%d"
            "rp[i]->fg_lflags & FG_INSMSGQ"
            "fg_insertuipc"
            "%s[mDNSResponder] pid=%d (%s): op=0x%x"
        }
        symbol = "uipc_send"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "so->so_rcv.sb_flags & SB_LOCK"
        }
        symbol = "unp_gc"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "fg->fg_lflags & FG_RMMSGQ"
        }
        symbol = "unp_discard"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "vsock_domain == NULL"
        }
        symbol = "vsock_dinit"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "vsock_connect"
        }
        symbol = "vsock_connect"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "vsock_unlock"
            "vsock_domain.c"
        }
        symbol = "vsock_unlock"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "shmseg free count inconsistent @%s:%d"
            "sysv_shm.c"
        }
        symbol = "shmget"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "semop - can't undo undos @%s:%d"
        }
        symbol = "semsys"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "semexit - semid not allocated @%s:%d"
            "semexit - semnum out of range @%s:%d"
        }
        symbol = "semexit"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "semu_alloc - second attempt failed @%s:%d"
        }
        symbol = "semundo_adjust"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "msg_cbytes is messed up @%s:%d"
            "msg_qnum is messed up @%s:%d"
        }
        symbol = "msgsys"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "msg_perm.mode & MSG_LOCKED @%s:%d"
            "segs_needed > nfree_msgmaps @%s:%d"
            "msgsz + msg_cbytes > msg_qbytes @%s:%d"
            "no more msghdrs @%s:%d"
            "not enough msgmaps @%s:%d"
            "nil free_msgmaps @%s:%d"
            "next too low #1 @%s:%d"
            "next out of range #1 @%s:%d"
            "next too low #2 @%s:%d"
            "next out of range #2 @%s:%d"
            "didn't use all the msg segments @%s:%d"
        }
        symbol = "msgsnd_nocancel"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "msg_first/last messed up #1 @%s:%d"
            "msg_first/last messed up #2 @%s:%d"
            "msg_first/last messed up #3 @%s:%d"
            "next too low #3 @%s:%d"
            "next out of range #3 @%s:%d"
        }
        symbol = "msgrcv_nocancel"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "msginfo.msgssz=%d (0x%x) not a small power of 2; resetting to %d\n"
            "msginfo.msgseg=%d (> 32767); resetting to %d\n"
            "msginit: can't allocate msgpool"
            "msginit: can't allocate msgmaps"
            "msginit: can't allocate msghdrs"
            "msginit: can't allocate msqids"
        }
        symbol = "msginit"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "msghdr->msg_spot out of range @%s:%d"
            "msghdr->msg_spot != -1 @%s:%d"
        }
        symbol = "msg_freehdr"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "com.apple.private.security.override-plugin-host-detection"
            "com.apple.security.cs.disable-library-validation"
            "com.apple.private.cs.automator-plugins"
            "com.apple.perl5"
            "com.apple.perl"
            "org.python.python"
            "com.apple.expect"
            "com.tcltk.wish"
            "com.tcltk.tclsh"
            "com.apple.ruby"
            "com.apple.bash"
            "com.apple.zsh"
            "com.apple.ksh"
            "%s: running binary \"%s\" in keys-off mode due to posix_spawnattr_disable_ptr_auth_a_keys_np"
            "%s: running binary \"%s\" in keys-off mode due to entitlement: %s"
            "%s: running binary \"%s\" in keys-off mode due to identity: %s"
        }
        symbol = "load_machfile"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "pagezero boundary at 0x%llx; adjust slide from 0x%llx to 0x%llx%s\n"
            "page-unaligned X-W boundary at 0x%llx; adjust slide from 0x%llx to 0x%llx%s\n"
            "PAGEZERO"
            "proc %d: load code signature error %d for file \"%s\"\n"
            "validating initial pages of %s\n"
            "CODE SIGNING: %s[%d]: invalid initial page at offset %lld validated:%d tainted:%d csflags:0x%x\n"
            "proc %d: set_code_unprotect() error %d for file \"%s\"\n"
        }
        symbol = "parse_machfile"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "+++ load_segment %s vm[0x%llx:0x%llx] file[0x%llx:0x%llx] prot %d/%d flags 0x%x\n"
            "section outside code signature\n"
            "vmaddr too large\n"
            "++++++ load_segment: page_zero up to 0x%llx\n"
            "++++++ load_segment: mapping at vm [0x%llx:0x%llx] of file [0x%llx:0x%llx]\n"
            "++++++ load_segment: delta mapping vm [0x%llx:0x%llx]\n"
        }
        symbol = "load_segment"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "__DATA_DIRTY"
            "__all_image_info"
        }
        symbol = "note_all_image_info_section"
        caller = "?"
    }
    new {
        args = 3
        anchors {
            "load_code_signature: %s\n"
            "load_code_signature: revalidation failed: %d\n"
            "success, but no blob! @%s:%d"
            "mach_loader.c"
            "load_code_signature: %s: failure to allocate exit reason for validation failure: %s\n"
            "load_code_signature: %s: failed to copy reason string (kcdata_memcpy error: %d, length: %ld)\n"
            "load_code_signature: %s: failed to allocate space for reason string (os_reason_alloc_buffer error: %d, kcdata error: %d, length: %ld)\n"
        }
        symbol = "load_code_signature"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s:%d '%s': cryptoff 0x%llx cryptsize 0x%llx cryptid 0x%x ignored\n"
            "set_code_unprotect"
            "set_code_unprotect: unable to create decrypter %s, kr=%d\n"
            "+++ set_code_unprotect: vm[0x%llx:0x%llx]\n"
            "set_code_unprotect(): mapping failed with %x\n"
        }
        symbol = "set_code_unprotect"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "/usr/lib/dyld"
        }
        symbol = "load_dylinker"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "/usr/libexec/rosetta/runtime"
        }
        symbol = "load_rosetta"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: Error %d removing all semaphores: %ld remain!\n"
            "psem_cache_purge_all"
        }
        symbol = "psem_cache_purge_all"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "pshm_cache_add() found %p @%s:%d"
        }
        symbol = "pshm_cache_add"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "negative usecount in pshm_close @%s:%d"
        }
        symbol = "pshm_deref"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "sock_connect"
        }
        symbol = "sock_connect"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "sock_connectwait"
        }
        symbol = "sock_connectwait"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: sosetopt SO_TRAFFIC_CLASS failed %d\n"
            "sock_settclassopt"
        }
        symbol = "sock_settclassopt"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: negative retain count (%d) for sock=%p @%s:%d"
            "sock_release"
            "kpi_socket.c"
            "sock->so_usecount > 1"
            "/AppleInternal/Library/BuildRoots/d3a62b52-2ef5-11ef-9ecd-e2437461156c/Library/Caches/com.apple.xbs/Sources/xnu/bsd/kern/kpi_socket.c"
        }
        symbol = "sock_release"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "sock_accept"
        }
        symbol = "sock_accept_common"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "OSDecrementAtomic64(&net_api_stats.nas_sfltr_register_os_count) > 0"
            "OSDecrementAtomic64(&net_api_stats.nas_sfltr_register_count) > 0"
        }
        symbol = "sflt_unregister"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "sflt_cleanup"
        }
        symbol = "sflt_cleanup_thread"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s : EACCES returned by vnode_lookup for uid %d\n"
            "proc_pidpathinfo_internal"
            "%s : EACCES returned by vnode_lookup for uid 0\n"
        }
        symbol = "proc_pidpathinfo_internal"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "kern.msgbuf"
        }
        symbol = "proc_kernmsgbuf"
        caller = "?"
    }
    new {
        args = 3
        anchors {
            "com.apple.private.cryptexd-rsr-write"
        }
        symbol = "sysctl_proc_rsr_in_progress"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "shouldn't be applying exception notification to process! @%s:%d"
            "process_policy.c"
        }
        symbol = "proc_apply_resource_actions"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "evthdlr_lists_ctxt != NULL"
        }
        symbol = "eventhandler_lists_ctxt_init"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "eventhandler_init"
            "%s: init"
        }
        symbol = "eventhandler_init"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "evhrm"
            "%s: removing item %p from \"%s\""
            "%s: marking item %p from \"%s\" as dead"
            "%s: removing all items from \"%s\""
            "%s: marking all items from \"%s\" as dead"
        }
        symbol = "eventhandler_deregister"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "eventhandler_prune_list"
            "%s: pruning list \"%s\""
        }
        symbol = "eventhandler_prune_list"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "TAILQ_EMPTY(&list->el_entries)"
        }
        symbol = "eventhandler_lists_ctxt_destroy"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "strlen(name) <= (sizeof(new_list->el_name) - 1)"
            "evthdlr_lists_ctxt->eventhandler_lists_initted"
            "%s: registering event_type=%s\n"
            "%s: creating list \"%s\""
            "%s: adding item %p (function %p to \"%s\""
        }
        symbol = "eventhandler_register"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "os_reason failed to allocate @%s:%d"
            "os_reason failed to get data address @%s:%d"
            "os_reason failed to copy description data @%s:%d"
        }
        symbol = "os_reason_set_description_data"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "recount: unexpected thread_selfcounts kind: %d @%s:%d"
            "sys_recount.c"
        }
        symbol = "thread_selfcounts"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "com.apple.private.ip-domain-table"
            "TRACKER - %s:%d Process (%d) does not hold the necessary entitlement\n"
            "TRACKER - %s:%d Failed to allocate buffer, size exceeded max allowed\n"
            "TRACKER - %s:%d Failed to copy parameters\n"
            "TRACKER - %s:%d Could not retrieve address family TLV from parameters\n"
            "TRACKER - %s:%d Could not retrieve address TLV from parameters\n"
            "TRACKER - %s:%d Address family parameter and address parameter family mismatch <%d != %d>\n"
            "TRACKER - %s:%d Could not retrieve flags TLV from parameters\n"
            "TRACKER - %s:%d Could not retrieve APP UUID TLV from parameters\n"
            "TRACKER - %s:%d Could not retrieve domain TLV from parameters\n"
            "TRACKER - %s:%d Could not retrieve domain owner TLV from parameters\n"
        }
        symbol = "tracker_action"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "tracker_lookup"
            "is not"
            "Lookup entry"
            "Failed to copy metadata"
            "TRACKER - %s:%d Failed lookup - remote %s null, app_uuid %s null\n"
        }
        symbol = "tracker_lookup"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "com.apple.xnu.kern.tracker_db"
            "tracker_db"
            "%s: Can't create Tracker GC thread"
            "g_tracker_gc_thread != NULL"
            "/AppleInternal/Library/BuildRoots/d3a62b52-2ef5-11ef-9ecd-e2437461156c/Library/Caches/com.apple.xbs/Sources/xnu/bsd/kern/tracker.c"
            "TRACKER - %s:%d Failed to initialize\n"
            "TRACKER - %s:%d Initialized: hashsize %d hashmask %lX\n"
        }
        symbol = "tracker_db_init"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "TRACKER_GC"
        }
        symbol = "tracker_gc_thread_func"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Deleting entry - IDLE TO"
            "tracker_entry_expire"
            "TRACKER - %s:%d Garbage Collection done...(deleted %d - total count %d)\n"
        }
        symbol = "tracker_entry_expire"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Dumped entry"
            "tracker_entry_dump_size"
            "TRACKER - %s:%d Could not dump entries, null output buffer\n"
            "TRACKER - %s:%d Could not dump entries, failed to calculate total size needed\n"
            "TRACKER - %s:%d Could not dump entries, failed to calculate total size needed for memory used)\n"
            "TRACKER - %s:%d Could not dump entries, failed to add 4-bytes size to start of buffer\n"
            "TRACKER - %s:%d Could not dump entries, output buffer too small %lu (needed %lu)\n"
            "TRACKER - %s:%d Could not dump entries, failed to allocate buffer\n"
            "TRACKER - %s:%d Could not dump entry, exceeded entry tlv buffer size\n"
            "TRACKER - %s:%d Could not dump entries, failed to calculate total memory used\n"
            "TRACKER - %s:%d Total memory size %zu\n"
            "TRACKER - %s:%d Failed to copy out dump buffer (%lu bytes)\n"
            "TRACKER - %s:%d Could not calculate entry dump size - invalid addr family %d\n"
            "TRACKER - %s:%d Could not dump entry - invalid addr family %d\n"
            "TRACKER - %s:%d Dumping domain <%s> len <%zu>\n"
            "TRACKER - %s:%d Dumping domain owner <%s> len <%zu>\n"
        }
        symbol = "tracker_dump"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "Matched entry"
            "Updated entry"
            "Failed to Update entry, deleting found entry"
            "TRACKER - %s:%d Max link count %d (hash 0x%X)\n"
            "TRACKER - %s:%d Total entries %d (hashmask 0x%lX)\n"
        }
        symbol = "tracker_search_and_insert"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "copy_metadata"
            "TRACKER - %s:%d Failed to copy metadata, dst buffer size too small\n"
        }
        symbol = "copy_metadata"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "MATCHED only entry for featureID"
            "Looking at entry"
            "Found entry by feature context id"
            "soflow_db_lookup_by_feature_context_id"
            "SOFLOW - %s:%d <pid %d so %llx> No entry found for featureID %llu <count %d hash %X %X>\n"
        }
        symbol = "soflow_db_get_feature_context"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "soflow_db_free"
            "Remove entry"
            "db->soflow_db_count == 0"
            "SOFLOW - %s:%d <pid %d so %llx> <db %p> freeing db (count == %d)\n"
        }
        symbol = "soflow_db_free"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "soflow_db_remove_entry"
            "SOFLOW - %s:%d <pid %d so %llx> <Close nstat> - context %lX\n"
        }
        symbol = "soflow_db_remove_entry"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "soflow_entry_log"
            "SOFLOW - %s:%d <pid %d so %llx> <%s>: %s <%s(%d) entry %p, featureID %llu> outifp %d lport %d fport %d laddr %s faddr %s hash %X <rx p %llu b %llu, tx p %llu b %llu>\n"
        }
        symbol = "soflow_entry_log"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Looking for entry"
            "Found entry v6"
            "Found entry v4"
            "Entry not found"
        }
        symbol = "soflow_db_lookup_entry_internal"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "Updated outifp"
            "Updated address"
            "Updated port"
            "soflow_udp_get_address_from_control"
            "SOFLOW - %s:%d <pid %d so %llx> Check control type %d\n"
        }
        symbol = "soflow_entry_update_local"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "soflow_db_add_entry"
            "SOFLOW - %s:%d <pid %d so %llx> Failed to add entry\n"
            "SOFLOW - %s:%d <pid %d so %llx> <Open nstat> - context %lX\n"
            "SOFLOW - %s:%d <pid %d so %llx> total count %d\n"
        }
        symbol = "soflow_get_flow"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "soflow_nstat_provider_request_extensions"
            "SOFLOW - %s:%d <pid %d so %llx> Collected NSTAT domain_info:pid %d domain <%s> owner <%s> ctxt <%s> bundle id <%s> is_tracker %d is_non_app_initiated %d is_silent %d\n"
        }
        symbol = "soflow_nstat_provider_request_extensions"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "com.apple.xnu.net.soflow"
            "%s: Can't create SOFLOW GC thread"
            "soflow_init"
            "soflow_gc_thread != NULL"
        }
        symbol = "soflow_init"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "SOFLOW_GC"
        }
        symbol = "soflow_gc_thread_func"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "soflow_gc_expire"
            "GC Idle Timeout detected"
            "GC cleanup entry"
            "SOFLOW - %s:%d <pid %d so %llx> <GC cleaned %d flows>\n"
        }
        symbol = "soflow_gc_expire"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "vmm-present"
        }
        symbol = "sysctl_vmm_present"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Data/Stack execution not permitted: %s[pid %d] at virtual address 0x%qx, protections were %s\n"
        }
        symbol = "vm_map_lookup_and_lock_object"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s[%d] triggered unnest of range 0x%qx->0x%qx of DYLD shared region in VM map %p. While not abnormal for debuggers, this increases system memory footprint until the target exits.\n"
        }
        symbol = "log_unnest_badness"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "shared_region: %p [%d(%s)] -> check_np(0x%llx)\n"
            "shared_region: %p [%d(%s)] check_np(0x%llx) vm_shared_region_start_address() failed\n"
            "shared_region: %p [%d(%s)] check_np(0x%llx) vm_shared_region_auth_remap() failed\n"
            "shared_region: %p [%d(%s)] check_np(0x%llx) copyout(0x%llx) error %d\n"
            "shared_region: %p [%d(%s)] check_np(0x%llx) <- 0x%llx %d\n"
        }
        symbol = "shared_region_check_np"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "shared_region: %p [%d(%s)] map(): no files\n"
            "shared_region: %p [%d(%s)] map(): too many files (%d) max %d\n"
            "shared_region: %p [%d(%s)] map(): no mappings\n"
            "shared_region: %p [%d(%s)] map(): too many mappings (%d) max %d\n"
            "shared_region: %p [%d(%s)] map(): mapping count argument was too small\n"
        }
        symbol = "shared_region_map_and_slide_2_np"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s: [%d(%s)]: map__with_linking() was disabled\n"
            "%s: [%d(%s)]: region_count == 0\n"
            "%s: [%d(%s)]: region_count too big %d\n"
            "%s: [%d(%s)]: link_info_size too small\n"
            "%s: [%d(%s)]: link_info_size too big %d\n"
            "%s: [%d(%s)]: failed to allocate regions\n"
            "%s: [%d(%s)]: failed to copyin regions kr=%d\n"
            "%s: [%d(%s)]: failed to allocate link_info\n"
            "%s: [%d(%s)]: failed to copyin link_info kr=%d\n"
            "%s: [%d(%s)]: unrecognized mwli_version=%d\n"
            "%s: [%d(%s)]: mwli_binds_offset too large %d\n"
            "%s: [%d(%s)]: mwli_binds_count too large %d\n"
            "%s: [%d(%s)]: mwli_chains_offset too large %d\n"
            "%s: [%d(%s)]: mwli_chains_size too small %d\n"
            "%s: [%d(%s)]: mwli_chains_size too large %d\n"
            "%s: [%d(%s)]: mwlr_fd mismatch %d and %d\n"
            "%s: [%d(%s)]: mwlr_protections EXECUTE not allowed\n"
            "%s: [%d(%s)]: region %d, found VM_PROT_ZF not allowed\n"
            "%s: [%d(%s)]: region %d, found VM_PROT_TPRO without VM_PROT_WRITE\n"
            "%s: [%d(%s)]: fp_get_ftype() failed, error %d\n"
            "%s: [%d(%s)]: not readable\n"
            "%s: [%d(%s)]: failed to get vnode, error %d\n"
            "%s: [%d(%s)]: vnode not VREG\n"
            "%s: [%d(%s)]: no memory object\n"
            "%s: [%d(%s)]: mac_file_check_mmap() failed, region %d, error %d\n"
            "%s: [%d(%s)]: region %d, not code signed\n"
        }
        symbol = "map_with_linking_np"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Failed attempt to set vm.enforce_shared_cache_dir sysctl\n"
        }
        symbol = "sysctl_scdir_enforce"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "shared_region: %p [%d(%s)] map(): copyin(0x%llx, %ld) failed (error=%d)\n"
        }
        symbol = "shared_region_copyin"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "shared_region: %p [%d(%s)] map(): vm_shared_region_map_file() failed kr=0x%x\n"
            "shared_region: %p [%d(%s)] <- map\n"
        }
        symbol = "_shared_region_map_and_slide"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "shared_region: %p [%d(%s)] -> map\n"
            "shared_region: %p [%d(%s)] map(): no shared region\n"
            "shared_region: map(%p) root_dir mismatch\n"
            "shared_region: %p [%d(%s)] map data >1 mapping\n"
            "shared_region: %p [%d(%s)] map data destination 0x%llx not aligned\n"
            "shared_region: %p [%d(%s)] map data size 0x%llx not aligned\n"
            "shared_region: %p [%d(%s)] map: fd=%d lookup failed (error=%d)\n"
            "shared_region: %p [%d(%s)] map: fd=%d not readable\n"
            "shared_region: %p [%d(%s)] map: fd=%d getwithref failed (error=%d)\n"
            "shared_region: %p [%d(%s)] map(%p:'%s'): not a file (type=%d)\n"
            "shared_region: %p [%d(%s)] map(%p:'%s'): missing CS blob\n"
            "shared_region: %p [%d(%s)] map(%p:'%s'): not in trust cache\n"
            "shared_region: %p [%d(%s)] map(%p:'%s'): vnode_getattr(%p) failed (error=%d)\n"
            "shared_region: %p [%d(%s)] map(%p:'%s'): owned by uid=%d instead of 0\n"
            "shared_region: %p [%d(%s)] map(%p:'%s'), vnode is not SIP-protected. \n"
            "shared_region: %p [%d(%s)]: vnode_lookup(%s) failed (error=%d)\n"
            "shared_region: %p [%d(%s)] map(%p:'%s'): shared cache file not in expected directory\n"
            "shared_region: %p [%d(%s)] map(%p:'%s'): vnode_size(%p) failed (error=%d)\n"
            "shared_region: %p [%d(%s)] map(%p:'%s'): no memory object\n"
            "shared_region: %p [%d(%s)] map(%p:'%s'): mapping #%d/%d [0x%llx:0x%llx:0x%llx:0x%x:0x%x] is not code-signed\n"
        }
        symbol = "shared_region_map_and_slide_setup"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "compressor_store_stop_compaction = FALSE\n"
        }
        symbol = "macx_triggers"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "Failed to open swap file %d\n"
        }
        symbol = "vm_swapfile_open"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "vnode_setsize for swap files failed: %d\n"
            "vnode_size (new file) for swap file failed: %d\n"
            "pin for swap files failed: %d,  file_size = %lld\n"
        }
        symbol = "vm_swapfile_preallocate"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "vm_map_create_upl failed with %d @%s:%d"
            "vm_compressor_backing_file.c"
            "vm_swapfile_io: vnode_pagein failed with %d.\n"
            "vm_swapfile_io: vnode_pageout failed with %d.\n"
        }
        symbol = "vm_swapfile_io"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: Invalid URL scheme for %s @%s:%d"
            "imageboot_needed"
        }
        symbol = "imageboot_needed"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "not supported @%s:%d"
            "%s: image file not found or couldn\\'t be read: %d\n"
            "%s: attached disk image %s as %s\n"
            "/dev/"
            "%s: attempting to mount as hfs...\n"
            "mount failed: %d\n"
            "%s: attempting to mount as apfs...\n"
            "%s: failed to mount pivot image(%d)! @%s:%d"
            "%s: failed to lookup pivot root (%d) ! @%s:%d"
            "BS-DMG failed to authenticate intra-FS \n"
            "%s: could not authenticate the pivot image: %d. giving up. @%s:%d"
            "%s: vfs_switch_root failed: %d @%s:%d"
        }
        symbol = "imageboot_pivot_image"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: root device 0x%x\n"
            "vfs_mountroot() failed. @%s:%d"
            "invalid imageboot type: %d @%s:%d"
        }
        symbol = "imageboot_mount_image"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "imageboot_setup: rootvnode is NULL. @%s:%d"
            "%s: no valid path to image. @%s:%d"
            "%s: second level root image url is %s\n"
            "-rootdmg-ramdisk"
            "%s: container image url is %s\n"
            "imageboot_setup_new"
            "%s specified without %s or %s? @%s:%d"
            "%s: root image URL is '%s'\n"
            "Failed to mount root image (err=%d, auth=%d, ramdisk=%d) @%s:%d"
            "imageboot path allocation failed - cannot allocate %d bytes @%s:%d"
            "Bogus imageboot path URL - missing path @%s:%d"
            "%s: failed: imageboot_read_file_pageable() = %d\n"
            "%s: failed: di_root_ramfile_buf() = %d\n"
            "%s: failed: vfs_mountroot() = %d\n"
        }
        symbol = "imageboot_setup"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: namei failed (%s) - %d\n"
            "%s: failed to get vnode size of %s - %d\n"
            "negative file size @%s:%d"
            "%s: negative file offset\n"
            "%s: failed to open %s - %d\n"
            "rootdmg-maxsize"
            "%s: file is too large (%lld > %lld)\n"
            "%s: file is too large for non-pageable (%lld)\n"
            "%s: Found resource fork for %s\n"
            "%s: Cannot read %lld bytes at offset %lld from %s - %d\n"
        }
        symbol = "imageboot_read_file_internal"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "kpc_init not called @%s:%d"
            "kern_kpc.c"
        }
        symbol = "kpc_sysctl"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "kern.profiling_data"
        }
        symbol = "grab_pgo_data"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "nullfs_pagein: ubc_upl_map() failed with (%d) @%s:%d"
            "nullfs_pagein: ubc_upl_unmap() failed with (%d) @%s:%d"
        }
        symbol = "nullfs_pagein"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "__netns_inited == 0"
            "netns.ns_reservation"
            "netns_init"
            "netns.ns_token"
            "netns.ns_flow_info"
        }
        symbol = "netns_init"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "(nt->nt_flags & NETNS_OWNER_MASK) <= NETNS_OWNER_MAX"
        }
        symbol = "netns_release"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "(nt->nt_flags & NETNS_OWNER_MASK) == NETNS_BSD"
            "old_namespace != NULL"
        }
        symbol = "netns_change_addr"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "!((set_flags | clear_flags) & NETNS_RESERVATION_FLAGS)"
        }
        symbol = "netns_change_flags"
        caller = "?"
    }
    new {
        args = 3
        anchors {
            "netns_get_local_ports"
        }
        symbol = "netns_get_local_ports"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "RB_EMPTY(&namespace->ns_reservations)"
        }
        symbol = "netns_ns_free"
        caller = "?"
    }
    new {
        args = 5
        anchors {
            "(flags & NETNS_OWNER_MASK) <= NETNS_OWNER_MAX"
            "proto == IPPROTO_TCP || proto == IPPROTO_UDP"
            "hport != 0"
            "nt->nt_addr_len == addr_len"
            "memcmp(nt->nt_addr, addr, addr_len) == 0"
            "nt->nt_proto == proto"
            "nt->nt_port == hport"
            "(nt->nt_flags & NETNS_RESERVATION_FLAGS | NETNS_PRERESERVED) == (flags & NETNS_RESERVATION_FLAGS)"
            "Request to overwrite valid netns token @%s:%d"
            "nt->nt_flow_info != NULL"
        }
        symbol = "_netns_reserve_kpi_common"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "res != NULL"
            "NETNS_REF_COUNT(res, flags) > 0"
        }
        symbol = "_netns_release_common"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "port != 0"
            "_netns_reserve_common: invalid owner 0x%x @%s:%d"
            "NETNS_REF_COUNT(res, flags) != 0"
        }
        symbol = "_netns_reserve_common"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "token->nt_addr_len == sizeof(struct in_addr) || token->nt_addr_len == sizeof(struct in6_addr)"
        }
        symbol = "__netns_get_if_local_ports_block_invoke"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "__protons_inited == 0"
        }
        symbol = "protons_init"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "pflowid != NULL"
            "pflow_key != NULL"
            "domain >= FLOWIDNS_DOMAIN_MIN && domain <= FLOWIDNS_DOMAIN_MAX"
            "failed to allocate flowid node\n"
            "retry_cnt <= FLOWIDNS_MAX_FLOWID_GEN_RETRY"
            "flowidns_domain_array[domain].fd_nallocs != 0"
        }
        symbol = "flowidns_allocate_flowid"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "flowid != 0"
            "flowid 0x%x not found in domain %d\n"
            "flowidns_domain_array[domain].fd_nreleases != 0"
        }
        symbol = "flowidns_release_flowid"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "__flowidns_inited == 0"
        }
        symbol = "flowidns_init"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "n_records <= UINT32_MAX"
            "n_records > 0"
            "n_records == 0"
        }
        symbol = "flowidns_stats_sysctl"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "!__sk_inited"
        }
        symbol = "skywalk_init"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "__u._u64 != 0"
        }
        symbol = "sk_gen_guard_id"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "p != kernproc"
        }
        symbol = "skywalk_kill_process"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "leaked skoid sub-node detected %p %s @%s:%d"
            "skywalk_sysctl.c"
        }
        symbol = "skoid_destroy"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "csi->csi_flags & CSI_DESTROYED"
            "tcall != NULL"
        }
        symbol = "csi_destroy"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "port != NEXUS_PORT_ANY"
        }
        symbol = "ch_open"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "(ch->ch_flags & CHANF_EVENT_RING) != 0"
        }
        symbol = "filt_che_event"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "(ch->ch_last[NR_EV] - ch->ch_first[NR_EV]) == 1"
        }
        symbol = "ch_event"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "ch->ch_flags & CHANF_KERNEL"
        }
        symbol = "ch_close_common"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "hw_kring != NULL"
        }
        symbol = "kern_channel_tx_refill_common"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "err == 0 && ph_cnt == (uint32_t)ph_needed"
        }
        symbol = "kr_txfinalize"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "!sk_is_sync_protected()"
        }
        symbol = "__channel_sync"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "h %zu add_called %zu tmp_h %zu @%s:%d"
            "cuckoo_hashtable.c"
            "__resize_begin"
        }
        symbol = "cuckoo_resize"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "net_filter_event_callback"
            "net_filter_event: new state (0x%x) %s"
            "%s: eventhandler saw event type=net_filter_event_state event_code=%s"
        }
        symbol = "net_filter_event_callback"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "socket "
            "interface "
            "application-firewall "
            "parental-controls "
        }
        symbol = "net_filter_event_description"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "net_filter_event_enqueue"
            "%s: eventhandler enqueuing event of type=net_filter_event_state event_code=%s"
        }
        symbol = "net_filter_event_mark"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "/AppleInternal/Library/BuildRoots/d3a62b52-2ef5-11ef-9ecd-e2437461156c/Library/Caches/com.apple.xbs/Sources/xnu/bsd/skywalk/lib/net_filter_event.c"
            "eventhandler_invoke(\"net_filter_event\")"
        }
        symbol = "net_filter_event_enqueue_callback"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "skmem_dump_buf != NULL"
            "Region %p\n  | Mode         : 0x%b\n  | Memory       : [%llu in use [%llu wired]] / [%llu total]\n  | Transactions : [%llu segment allocs, %llu frees]\n\n"
            "Cache %p\n  | Mode         : 0x%b\n  | Memory       : [%llu in use] / [%llu total]\n  | Transactions : [%llu alloc failures]\n  |                [%llu slab creates, %llu destroys]\n  |                [%llu slab allocs,  %llu frees]\n\n"
            "VM Pages\n  | Free         : %u [%u speculative]\n  | Active       : %u\n  | Inactive     : %u\n  | Wired        : %u [%u throttled, %u lopage_free]\n  | Purgeable    : %u [%u purged]\n"
        }
        symbol = "skmem_dump"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "sk_sys_region == NULL"
            "failed to allocate global sysctls region @%s:%d"
            "failed to allocate global sysctls object (%u bytes) @%s:%d"
        }
        symbol = "skmem_init"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "nexus"
            "nxv->flowswitch_nxv_adv->nxadv_ver == NX_FLOWSWITCH_ADVISORY_CURRENT_VERSION"
            "nxv->netif_nxv_adv->nna_version == NX_NETIF_ADVISORY_CURRENT_VERSION"
            "%s: invalid advisory type %d"
            "skmem_arena_create_for_nexus"
            "schema.%.*s"
            "ring.%.*s"
        }
        symbol = "skmem_arena_create_for_nexus"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "kstats.%s"
        }
        symbol = "skmem_arena_create_for_necp"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s_ksd.%.*s"
        }
        symbol = "skmem_arena_sd_setup"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "ar->ar_refcnt > 1"
            "ar->ar_maprdrcnt != 0"
        }
        symbol = "skmem_arena_munmap_common"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "skywalk.skm"
        }
        symbol = "skmem_cache_pre_init"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "skmem_debug"
            "bufctl.audit"
            "bufctl"
            "%s: bad alignment %d @%s:%d"
            "mg.%d"
            "skmem_cache_magsize_last->mt_minbuf == 0"
            "skmem_cache_magsize_last->mt_maxbuf == 0"
            "%s: thread_call_allocate failed @%s:%d"
        }
        symbol = "skmem_cache_init"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "powerof2(bufalign)"
            "!(cflags & SKMEM_CR_BATCH)"
            "region->skr_c_obj_size >= P2ROUNDUP(bufsize, bufalign)"
            "objalign == region->skr_align"
            "IS_P2ALIGNED(skm, CHANNEL_CACHE_ALIGN_MAX)"
            "!(region->skr_mode & SKR_MODE_MMAPOK)"
            "!(region->skr_mode & SKR_MODE_PSEUDO)"
            "region->skr_c_obj_size >= sizeof(struct skmem_obj)"
            "%s.%s"
            "%s: (bufsize %lu, chunksize %lu) > objsize %lu @%s:%d"
            "skmem_cache_create"
            "IS_P2ALIGNED(ccp, CHANNEL_CACHE_ALIGN_MAX)"
        }
        symbol = "skmem_cache_create"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s: '%s' (%p) not empty (%llu unfreed) @%s:%d"
            "skmem_cache_destroy"
        }
        symbol = "skmem_cache_destroy"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: %s failed to get object info for %p @%s:%d"
            "skmem_cache_get_obj_info"
        }
        symbol = "skmem_cache_get_obj_info"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "ncpu != 0"
            "chunksize > 0"
            "mtp <= skmem_cache_magsize_last"
        }
        symbol = "skmem_cache_magazine_max"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: %s failed to get bufctl for %p @%s:%d"
            "skmem_audit_buf"
        }
        symbol = "skmem_audit_buf"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "skmem_seg_size"
            "skmem_seg_size != 0 && (skmem_seg_size % SKMEM_PAGE_SIZE) == 0"
            "skmem_md_seg_size"
            "skmem_drv_buf_seg_size"
            "(skmem_drv_buf_seg_eff_size % SKMEM_MIN_SEG_SIZE) == 0"
            "skmem_drv_buf_seg_eff_size >= skmem_drv_buf_seg_size"
            "skmem_usr_buf_seg_size"
        }
        symbol = "skmem_region_init"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "align != 0 && (align % SKMEM_CACHE_ALIGN) == 0"
            "powerof2(align)"
            "seglim != 0 && (seglim % SKMEM_PAGE_SIZE) == 0"
        }
        symbol = "skmem_region_params_config"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s.reg.%s"
        }
        symbol = "skmem_region_create"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "(skmflag & (SKMEM_NOSLEEP | SKMEM_FAILOK)) != (SKMEM_NOSLEEP | SKMEM_FAILOK)"
            "\"%s\": failed to allocate segment (sleeping mode) after %u retries\n\n%s"
            "skmflag & (SKMEM_NOSLEEP | SKMEM_FAILOK)"
            "(skmflag & (SKMEM_NOSLEEP | SKMEM_FAILOK)) == SKMEM_NOSLEEP"
            "\"%s\": skr 0x%p unable to satisfy mandatory allocation\n"
            "sg != NULL"
            "sg->sg_index == sg0->sg_index"
        }
        symbol = "skmem_region_alloc"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: '%s' (%p) not empty (%u unfreed) @%s:%d"
            "skmem_region_destroy"
        }
        symbol = "skmem_region_destroy"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: '%s' (%p) idx %u (out of %u) is already allocated @%s:%d"
            "sksegment_alloc_with_idx"
            "!bit_test(skr->skr_seg_bmap[idx / BMAPSZ], idx % BMAPSZ)"
        }
        symbol = "sksegment_alloc_with_idx"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "sg->sg_md == md"
            "Fail to unwire md %p, err %d @%s:%d"
            "Fail to discard md %p, err %d @%s:%d"
        }
        symbol = "skmem_region_free"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "\"%s\": skr 0x%p sg 0x%p (idx %u) unable to satisfy mandatory allocation\n"
            "Fail to reclaim md %p, err %d @%s:%d"
            "Fail to wire md %p, err %d @%s:%d"
            "Fail to set md %p, err %d @%s:%d"
        }
        symbol = "sksegment_freelist_remove"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "\"%s\": boff_total counter overflows\n"
            "\"%s\": failed to allocate slab (sleeping mode) after %llu msec, %u retries\n\n%s"
            "boff > 0 && ((uint32_t)boff <= (SKMEM_SLAB_BACKOFF_THRES * 2))"
        }
        symbol = "skmem_slab_alloc_locked"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "IS_P2ALIGNED(buf, skm->skm_bufalign)"
        }
        symbol = "skmem_slab_alloc_pseudo_locked"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "%s: attempt to free invalid or already-freed obj %p on skm %p @%s:%d"
            "skmem_slab_free_locked"
            "skmem_slab.c"
            "SKMEM_SLAB_MEMBER(sl, buf)"
        }
        symbol = "skmem_slab_free_locked"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "IS_P2ALIGNED(obj, skm->skm_bufalign)"
        }
        symbol = "skmem_slab_free_pseudo_locked"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "nx_port_info_size(npi->npi_info, &sz) == 0"
        }
        symbol = "nx_port_unbind"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "nx_port_info_size(info, &sz) == 0"
        }
        symbol = "__nx_port_free_all_block_invoke"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "struct nx_port_info"
        }
        symbol = "nx_port_free_all"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "fae->fae_flowid == flowid"
        }
        symbol = "na_flowadv_entry_free"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "ALLOC"
            "LARGE ALLOC"
        }
        symbol = "na_rings_mem_setup"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "sd_idle || defunct"
            "internalized packet 0x%llx in htbl @%s:%d"
            "nexus_adapter.c"
        }
        symbol = "na_kr_teardown_common"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "com.apple.private.skywalk.traffic_rule.write"
            "com.apple.private.skywalk.traffic_rule.read"
        }
        symbol = "nxioctl"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "nxdom_attach_all"
        }
        symbol = "nxdom_attach_all"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "!(nxdom_prov->nxdom_prov_flags & NXDOMPROVF_ATTACHED)"
            "!(nxdom_prov->nxdom_prov_flags & NXDOMPROVF_INITIALIZED)"
            "builtin && nxdom_prov_default[type] == NULL"
        }
        symbol = "nxdom_prov_add"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "nxdom_prov_default[type] == nxdom_prov"
            "!nxdom_prov_release_locked(nxdom_prov)"
        }
        symbol = "nxdom_prov_del"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "(tmp4xpipes == 0) || (rx_rings == tx_rings)"
            "CHANNEL_SCHEMA_SIZE(tmpsumrings) <= UINT32_MAX"
        }
        symbol = "nxprov_params_adjust"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "nxprov_detacher"
        }
        symbol = "nxprov_detacher"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "nxprov_detacher_cont"
        }
        symbol = "nxprov_detacher_cont"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "nx_pktq_empty(q)"
            "/AppleInternal/Library/BuildRoots/d3a62b52-2ef5-11ef-9ecd-e2437461156c/Library/Caches/com.apple.xbs/Sources/xnu/bsd/skywalk/nexus/nexus_pktq.c"
        }
        symbol = "nx_netif_filter_fini"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "com.apple.skywalk.nexus.traffic_rule"
        }
        symbol = "nexus_init"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "/AppleInternal/Library/BuildRoots/d3a62b52-2ef5-11ef-9ecd-e2437461156c/Library/Caches/com.apple.xbs/Sources/xnu/bsd/skywalk/nexus/nexus_traffic_rule.c"
            "strlcmp(ntr->ntr_ifname, ifname, sizeof(ntr->ntr_ifname)) == 0"
        }
        symbol = "inet_traffic_rule_match"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "/AppleInternal/Library/BuildRoots/d3a62b52-2ef5-11ef-9ecd-e2437461156c/Library/Caches/com.apple.xbs/Sources/xnu/bsd/skywalk/nexus/flowswitch/nx_flowswitch.c"
        }
        symbol = "nx_fsw_prov_params_adjust"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s_%llu:%u"
        }
        symbol = "nx_fsw_dom_connect"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "__nx_fsw_ifnet_eventhandler_tag != NULL"
            "__nx_fsw_protoctl_eventhandler_tag != NULL"
            "fsw_use_dual_sized_pool"
        }
        symbol = "fsw_init"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "if_input_netem_%s@fsw"
        }
        symbol = "fsw_ctl"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "fsw_ifnet_event_callback"
            "%s: eventhandler saw event type=intf_event event_code=%s"
        }
        symbol = "fsw_ifnet_event_callback"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "fsw_protoctl_event_callback"
            "%s: eventhandler saw event type=protoctl_event event_code=%d"
        }
        symbol = "fsw_protoctl_event_callback"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "fsw_detach"
            "fsw->fsw_detach_flags != 0"
            "fsw->fsw_detach_flags == FSW_DETACHF_DETACHED"
            "_detached"
        }
        symbol = "fsw_detach"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "fsw_%s[%u]_%s.%d"
        }
        symbol = "fsw_vp_na_create"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "fsw_ring_enqueue_tail_drop"
        }
        symbol = "fsw_ring_enqueue_tail_drop"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s_%llu"
            "fsw_dp_ctor"
            "fsw->fsw_reap_thread != NULL"
        }
        symbol = "fsw_dp_ctor"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "_fsw_receive_locked"
        }
        symbol = "fsw_receive"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "dp_flow_tx_route_process"
        }
        symbol = "dp_flow_tx_process"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "invalid tso flags: 0x%x\n @%s:%d"
            "fsw_dp.c"
            "_pkt_copypkt_sum(sph, soff, dph, doff, len, partial, do_csum)"
        }
        symbol = "fsw_ring_flush"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "!(fsw->fsw_reap_flags & FSW_REAPF_RUNNING)"
        }
        symbol = "fsw_reap_thread_func"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "fe->fe_flags & FLOWENTF_ABORTED"
            "i == cnt && cnt >= freed"
        }
        symbol = "fsw_reap_thread_cont"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "/AppleInternal/Library/BuildRoots/d3a62b52-2ef5-11ef-9ecd-e2437461156c/Library/Caches/com.apple.xbs/Sources/xnu/bsd/skywalk/nexus/flowswitch/fsw_ip_frag.c"
        }
        symbol = "ipf_pkt2mbuf"
        caller = "?"
    }
    new {
        args = 3
        anchors {
            "ln->ln_state > ND6_LLINFO_INCOMPLETE"
        }
        symbol = "fsw_ethernet_resolve"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "fsw_flow_add"
        }
        symbol = "fsw_flow_add"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "fsw_flow_del"
        }
        symbol = "fsw_flow_del"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "/AppleInternal/Library/BuildRoots/d3a62b52-2ef5-11ef-9ecd-e2437461156c/Library/Caches/com.apple.xbs/Sources/xnu/bsd/skywalk/nexus/flowswitch/fsw_classq.c"
        }
        symbol = "fsw_classq_kpkt_to_mbuf"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: QoS Marking mode invalid! @%s:%d"
            "fsw_qos.c"
        }
        symbol = "fsw_qos_mark"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "flow.owner"
            "flow_init"
            "flow.c"
            "flow.entry"
            "sk_fadv_nchunks != 0"
            "flow.adv.bmap"
        }
        symbol = "flow_init"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "pkt_len >= cls_len"
            "af != AF_UNSPEC"
        }
        symbol = "flow_pkt_classify"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "/AppleInternal/Library/BuildRoots/d3a62b52-2ef5-11ef-9ecd-e2437461156c/Library/Caches/com.apple.xbs/Sources/xnu/bsd/skywalk/nexus/flowswitch/flow/flow_entry.c"
        }
        symbol = "flow_entry_alloc"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "RB_EMPTY(&flow_mgr_head)"
        }
        symbol = "nx_fsw_dom_terminate"
        caller = "?"
    }
    new {
        args = 3
        anchors {
            "NETNS_TOKEN_VALID(&fe->fe_port_reservation) || !(fe->fe_key.fk_mask & FKMASK_SPORT) || req->nfr_flags & NXFLOWREQF_ASIS || (fe->fe_flags & FLOWENTF_CHILD)"
            "(req->nfr_flags & NXFLOWREQF_FLOWADV) ^ (req->nfr_flowadv_idx == FLOWADV_IDX_NONE)"
            "err != 0"
            "saddr->sa.sa_family == AF_INET || saddr->sa.sa_family == AF_INET6"
        }
        symbol = "flow_mgr_flow_add"
        caller = "?"
    }
    new {
        args = 3
        anchors {
            "nx_port != NEXUS_PORT_ANY"
            "nx_port_na != NULL"
            "fo_cnt <= 1"
        }
        symbol = "flow_owner_activate_nexus_port"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "fo->fo_num_flowadv == fo->fo_flowadv_max"
        }
        symbol = "flow_owner_flowadv_index_alloc"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "fe->fe_nx_port == fo->fo_nx_port"
        }
        symbol = "flow_owner_bucket_activate_nx_port_common"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "flow.route"
        }
        symbol = "flow_route_init"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "fr->fr_usecnt > 0"
        }
        symbol = "flow_route_release"
        caller = "?"
    }
    new {
        args = 3
        anchors {
            "src_ifp != NULL"
        }
        symbol = "flow_route_select_laddr"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "!(fr->fr_flags & FLOWRTF_ATTACHED)"
            "fr->fr_usecnt == 0"
            "fr->fr_rt_dst == NULL"
            "fr->fr_rt_evhdlr_tag == NULL"
        }
        symbol = "fr_free"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "!uuid_is_null(ee_arg.ee_fm_uuid)"
            "!uuid_is_null(ee_arg.ee_fr_uuid)"
            "flow_route_ev_callback"
            "%s: eventhandler saw event type=route_event event_code=%s"
        }
        symbol = "flow_route_ev_callback"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "gencnt != NULL"
            "ip_v == IPVERSION || ip_v == IPV6_VERSION"
        }
        symbol = "_flow_route_laddr_validate"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "flow.stats"
            "flow_stats_init"
            "flow_stats.c"
        }
        symbol = "flow_stats_init"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "os_ref_get_count(&fs->fs_refcnt) == 0"
            "/AppleInternal/Library/BuildRoots/d3a62b52-2ef5-11ef-9ecd-e2437461156c/Library/Caches/com.apple.xbs/Sources/xnu/bsd/skywalk/nexus/flowswitch/flow/flow_stats.c"
        }
        symbol = "flow_stats_free"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "m != 0"
            "/AppleInternal/Library/BuildRoots/d3a62b52-2ef5-11ef-9ecd-e2437461156c/Library/Caches/com.apple.xbs/Sources/xnu/bsd/skywalk/nexus/flowswitch/flow/flow_track.c"
        }
        symbol = "flow_track_abort_quic"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "(currm != NULL || currp != NULL) && ((currm != NULL) != (currp != NULL))"
        }
        symbol = "copy_pkt_csum_packed"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "kern_buflet_set_data_length(dbuf->dba_buflet[i], tmplen + buf_off) == 0"
        }
        symbol = "_copy_data_sum_dbuf"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "stcp->th_off << 2 == pkt->pkt_flow_tcp_hlen"
        }
        symbol = "flow_agg_merge_hdr"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "kern_buflet_set_data_length(dbuf->dba_buflet[0], kern_buflet_get_data_length(dbuf->dba_buflet[0]) + copied_len) == 0"
        }
        symbol = "copy_pkt_csum"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "spkt->pkt_headroom == 0 && spkt->pkt_l2_len == 0"
        }
        symbol = "flow_rx_agg_channel"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s%s/%s%s%s"
        }
        symbol = "nx_monitor_na_find"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "na_arena->arn_rx_pp->pp_md_type == NEXUS_META_TYPE_PACKET"
        }
        symbol = "nx_mon_na_activate_common"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "IS_P2ALIGNED(len, 64)"
            "IS_P2ALIGNED(dbuf, sizeof(uint64_t))"
            "len <= UINT16_MAX"
        }
        symbol = "nx_mon_quantum_copy_64x"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "netif_%llu"
        }
        symbol = "nx_netif_prov_nx_ctor"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "qset_ext->qe_prov_ctx != NULL"
            "qset_ext->qe_notify_steering_info != NULL"
        }
        symbol = "nx_netif_notify_steering_info"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "if_ns->ifn_rx_mit_cfg_idx < mit->mit_cfg_idx_max"
        }
        symbol = "nx_netif_copy_stats"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "ring != NULL"
        }
        symbol = "netif_ring_tx_refill"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "llink_init != NULL"
        }
        symbol = "kern_nexus_netif_llink_add"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "netif:%llu:%.*s"
        }
        symbol = "nx_netif_dom_connect"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "drop_lim != 0"
        }
        symbol = "nx_netif_attach"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "capab.kncia_config != NULL"
            "capab.kncia_provider_context != NULL"
            "capab.cqe_notify_steering_info != NULL"
            "capab.cqe_prov_ctx != NULL"
            "PP_BUF_SIZE_DEF(nif->nif_nx->nx_tx_pp) >= max(tso_v4_mtu, tso_v6_mtu)"
        }
        symbol = "na_netif_finalize"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s: ifp=%p couldn\\'t get a poll  thread; err=%d"
            "nx_netif_compat_na_activate"
            "ifp->if_poll_thread != NULL"
            "netif_poll_thread_exit"
        }
        symbol = "nx_netif_compat_na_activate"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "Failed to activate mbuf ring cluster 0x%llx (%d) @%s:%d"
            "nx_netif_compat.c"
        }
        symbol = "nx_netif_compat_na_txsync"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "(poff + len) <= (PP_BUF_SIZE_DEF(pp) * pp->pp_max_frags)"
        }
        symbol = "nx_netif_host_output"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "skywalk_%s_tx_%u"
            "skywalk_mit_%s_tx_%u"
            "tx_%u"
            "skywalk_%s_rx_%u"
            "skywalk_mit_%s_rx_%u"
            "rx_%u"
            "mit->mit_cfg != NULL && mit->mit_cfg_idx < mit->mit_cfg_idx_max"
            "mit->mit_thread != NULL"
        }
        symbol = "nx_netif_mit_init"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "!(mit->mit_flags & (NETIF_MITF_READY | NETIF_MITF_RUNNING))"
        }
        symbol = "nx_netif_mit_thread_func"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "NetIf"
        }
        symbol = "nx_netif_agent_init"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "nx_netif_filter_remove"
        }
        symbol = "nx_netif_filter_remove"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "com.apple.private.skywalk.default-drop"
        }
        symbol = "nx_netif_default_drop_sysctl"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "tc < MBUF_TC_MAX"
        }
        symbol = "nx_netif_filter_tx_processed_mbuf_enqueue"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "i >= 0 && i < MBUF_TC_MAX"
        }
        symbol = "nx_netif_tx_processed_mbuf_get_len"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "i >= 0 && i < KPKT_TC_MAX"
            "/AppleInternal/Library/BuildRoots/d3a62b52-2ef5-11ef-9ecd-e2437461156c/Library/Caches/com.apple.xbs/Sources/xnu/bsd/skywalk/nexus/nexus_pktq.h"
        }
        symbol = "nx_netif_tx_processed_pkt_get_len"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s_filter:%d"
            "%s_netif_filter_pp"
        }
        symbol = "netif_filter_na_create"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "(ft = nif->nif_flow_table) != NULL"
            "/AppleInternal/Library/BuildRoots/d3a62b52-2ef5-11ef-9ecd-e2437461156c/Library/Caches/com.apple.xbs/Sources/xnu/bsd/skywalk/nexus/netif/nx_netif_flow.c"
        }
        symbol = "nx_netif_flow_match"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "nx_netif_flow_remove"
        }
        symbol = "nx_netif_flow_remove"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "netif_vp:%d"
        }
        symbol = "netif_vp_na_create"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "(fpkt->pkt_pflags & PKT_F_TRUNCATED) != 0"
            "(fpkt->pkt_pflags & PKT_F_TRUNCATED) == 0"
        }
        symbol = "nx_netif_mbuf_to_filter_pkt_chain"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "(fpkt->pkt_pflags & PKT_F_MBUF_DATA) != 0 || (fpkt->pkt_pflags & PKT_F_PKT_DATA) != 0"
            "pkt != NULL"
            "filter packet has no mbuf or packet attached: pkt_pflags 0x%llx\n @%s:%d"
            "nx_netif_util.c"
        }
        symbol = "fill_vlan_info"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "skywalk_netif_poller_%s"
            "!(ifp->if_poll_flags & (IF_POLLF_READY | IF_POLLF_RUNNING))"
        }
        symbol = "netif_rxpoll_compat_thread_func"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "(m_cnt > 0) || ((m_head == NULL) && (m_tail == NULL))"
        }
        symbol = "netif_rxpoll_compat_thread_cont"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "gso_flags < GSO_END_OF_TYPE"
        }
        symbol = "netif_gso_dispatch"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "((uintptr_t)state->hdr.ip6 & (uintptr_t)0x1) == 0"
            "((uintptr_t)state->hdr.ip & (uintptr_t)0x1) == 0"
            "m->m_pkthdr.tso_segsz != 0"
        }
        symbol = "netif_gso_ip_tcp_init_state"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "total_len > state->hlen"
            "((tx_headroom + state->mac_hlen) & 0x1) == 0"
            "(tx_headroom + state->hlen + mss) <= PP_BUF_SIZE_DEF(pp)"
            "__packet_finalize(SK_PKT2PH(pkt)) == 0"
        }
        symbol = "netif_gso_tcp_segment_mbuf"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "lasthdr_off <= UINT8_MAX"
        }
        symbol = "netif_gso_ipv6_tcp"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "c == cnt"
            "b == bytes"
        }
        symbol = "netif_qset_enqueue"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "llink->nll_state == NETIF_LLINK_STATE_DESTROYED"
        }
        symbol = "nx_netif_llink_free"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "drvq->nq_qset->nqs_llink->nll_state == NETIF_LLINK_STATE_DESTROYED"
            "KPKTQ_EMPTY(&drvq->nq_pktq)"
        }
        symbol = "nx_netif_qset_free"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "llink->nll_default_qset == NULL"
            "llink->nll_default_qset != NULL"
        }
        symbol = "nx_netif_llink_create_locked"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "qset->nqs_num_tx_queues == _NETIF_QSET_MAX_TXQS"
        }
        symbol = "nx_netif_qset_init"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "SKYWALK_NATIVE(ifp)"
            "nif->nif_default_llink_params != NULL"
        }
        symbol = "nx_netif_llink_init"
        caller = "?"
    }
    new {
        args = 3
        anchors {
            "%s}%d"
        }
        symbol = "nx_upipe_na_find"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "upipe:%llu:%.*s"
        }
        symbol = "nx_upipe_dom_connect"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "/AppleInternal/Library/BuildRoots/d3a62b52-2ef5-11ef-9ecd-e2437461156c/Library/Caches/com.apple.xbs/Sources/xnu/bsd/skywalk/nexus/upipe/nx_user_pipe.c"
        }
        symbol = "nx_upipe_na_activate"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "kpipe:%llu:%.*s"
        }
        symbol = "nx_kpipe_dom_connect"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "/AppleInternal/Library/BuildRoots/d3a62b52-2ef5-11ef-9ecd-e2437461156c/Library/Caches/com.apple.xbs/Sources/xnu/bsd/skywalk/nexus/kpipe/nx_kernel_pipe.c"
        }
        symbol = "nx_kpipe_na_activate"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "(doff + len) <= PP_BUF_SIZE_DEF(dpkt->pkt_qum.qum_pp)"
        }
        symbol = "pkt_copy_from_pkt"
        caller = "?"
    }
    new {
        args = 6
        anchors {
            "(doff + len) <= (PP_BUF_SIZE_DEF(dpkt->pkt_qum.qum_pp) * __packet_get_buflet_count(dph))"
        }
        symbol = "pkt_copy_multi_buflet_from_pkt"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "__buflet_set_data_offset(dbuf, doff) == 0"
        }
        symbol = "_pkt_copypkt_sum"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: mbuf too large %p [off %d, len %d] @%s:%d"
        }
        symbol = "m_copypkt_sum"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s: bad packet, 0x%llx [off %d, len %d] @%s:%d"
            "_pkt_copyaddr_sum"
        }
        symbol = "_pkt_copyaddr_sum"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "SK_PTR_TYPE(ph1) == NEXUS_META_TYPE_PACKET"
            "p1->pkt_bufs_cnt == 1"
        }
        symbol = "kern_packet_clone_internal"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "PKT_ADDR(ph) && bnew && (bnew != bprev)"
            "PP_HAS_BUFFER_ON_DEMAND(PKT_ADDR(ph)->pkt_qum.qum_pp)"
            "(bprev != NULL || bcnt == 0) && (bcnt < PKT_ADDR(ph)->pkt_bufs_max)"
        }
        symbol = "kern_packet_add_buflet"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "pkt.opt"
            "pkt.flow"
            "pkt.compl"
        }
        symbol = "pp_init"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "srp_array[SKMEM_REGION_TXKMD].srp_c_obj_cnt != 0"
            "kmd_srp->srp_c_obj_size != 0"
            "buf_srp->srp_c_obj_cnt != 0"
            "buf_srp->srp_c_obj_size != 0"
            "kbft_srp->srp_c_obj_cnt != 0"
            "kbft_srp->srp_c_obj_size != 0"
            "skywalk.pp.%s"
            "(kbft_srp != NULL) && (kbft_srp->srp_c_obj_cnt > 0)"
            "(ubft_srp != NULL) && (ubft_srp->srp_c_obj_cnt > 0)"
            "kmd.%s"
            "kbft_def.%s"
            "kbft_large.%s"
            "buf_def.%s"
            "buf_large.%s"
        }
        symbol = "pp_create"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "pp != NULL && baddr != NULL"
            "(seg != NULL) == (idx != NULL)"
        }
        symbol = "pp_alloc_buffer"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "bufcnt == 1"
        }
        symbol = "pp_metadata_construct"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "(init->kbi_max_frags != 0) && (init->kbi_max_frags <= UINT16_MAX)"
        }
        symbol = "kern_pbufpool_create"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "-enable_uexc"
        }
        symbol = "register_uexc_handler"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "unix_syscall: unknown return type @%s:%d"
        }
        symbol = "arm_prepare_syscall_return"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "product-soc-name"
        }
        symbol = "sysctl_load_brand_string"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "size mismatch @%s:%d"
            "sysctl.c"
        }
        symbol = "arm_host_info"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "ARM architecture"
            "%s processor"
            "Apple"
        }
        symbol = "make_brand_string"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "FPU VME DE PSE TSC MSR PAE MCE CX8 APIC SEP MTRR PGE MCA CMOV PAT PSE36 CLFSH DS ACPI MMX FXSR SSE SSE2 SS HTT TM PBE SSE3 PCLMULQDQ DTSE64 MON DSCPL VMX EST TM2 SSSE3 CX16 TPR PDCM SSE4.1 SSE4.2 AES SEGLIM64"
        }
        symbol = "cpu_features"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "dtrace_user_probe() should be calling aston()\n"
        }
        symbol = "dtrace_user_probe"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "Detected attempt to place DTrace probe on exclusive memory instruction (pc = 0x%llx); refusing to trace (or exclusive operation could never succeed).\n"
            "dtrace: fasttrap init64: Unrecognized instruction: %08x at %08llx\n"
        }
        symbol = "fasttrap_tracepoint_init"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Should never get here! @%s:%d"
            "An instruction DTrace doesn't expect: %d @%s:%d"
        }
        symbol = "fasttrap_pid_probe"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "current thread doesn't own the lock (%p) @%s:%d"
            "bsd_stubs.c"
        }
        symbol = "devsw_unlock"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s\nBacktrace 0x%lx 0x%lx 0x%lx 0x%lx 0x%lx 0x%lx 0x%lx\n"
        }
        symbol = "OSReportWithBacktrace"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "OSMetaClass: preModLoad() wasn't called for class %s (runtime internal error)."
        }
        symbol = "__ZN11OSMetaClassC2EPKcPKS_j"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "OSMetaClass: Can't record classes for kext %s - kext not found."
            "OSMetaClass: Kext %s class %s is a duplicate;kext %s already has a class by that name."
        }
        symbol = "__ZN11OSMetaClass11postModLoadEPv"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "OSMetaClass: Class %s - bad retain (%d)"
        }
        symbol = "__ZNK11OSMetaClass18instanceDestructedEv"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            ">maxDepth @%s:%d"
        }
        symbol = "__ZN11OSMetaClass16applyToInstancesEP12OSOrderedSetPFbPK8OSObjectPvES5_"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s::_RESERVED%s%d called. @%s:%d"
        }
        symbol = "__ZNK11OSMetaClass14reservedCalledEi"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%24s count: %03d x 0x%03x = 0x%06x\n"
        }
        symbol = "__ZN11OSMetaClass19printInstanceCountsEv"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "OSMetaClass::getClassDictionary() is obsoleted. @%s:%d"
        }
        symbol = "__ZN11OSMetaClass18getClassDictionaryEv"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "OSMetaClass::serialize(): Obsoleted @%s:%d"
        }
        symbol = "__ZNK11OSMetaClass9serializeEP11OSSerialize"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Classes"
        }
        symbol = "__ZN11OSMetaClass24serializeClassDictionaryEP12OSDictionary"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Unexpected cast fail: from %p to %p @%s:%d"
        }
        symbol = "__ZL21panic_crash_fail_castPK15OSMetaClassBasePK11OSMetaClass"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "OSMetaClass: Failed to record class in kext."
            "OSMetaClass: Duplicate class encountered."
            "OSMetaClass: Kext not found for metaclass."
        }
        symbol = "__ZN11OSMetaClass8logErrorEi"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "A kext releasing a(n) %s has corrupted the registry. @%s:%d"
        }
        symbol = "__ZNK8OSObject13taggedReleaseEPKvi"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s is not serializable"
        }
        symbol = "__ZNK8OSObject9serializeEP11OSSerialize"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "<true/>"
            "<false/>"
        }
        symbol = "__ZNK9OSBoolean9serializeEP11OSSerialize"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Trying to change a collection in the registry @%s:%d"
            "OSCollection.cpp"
            "Trying to change a collection in the registry"
        }
        symbol = "__ZN12OSCollection11haveUpdatedEv"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
        }
        symbol = "__ZNK6OSData9serializeEP11OSSerialize"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "<key>"
        }
        symbol = "__ZNK12OSDictionary9serializeEP11OSSerialize"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "OSValueObject<void*>"
        }
        symbol = "_GLOBAL__sub_I_OSCollection.cpp_1"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "OSValueObject<OSKextRequestResourceCallback>"
        }
        symbol = "_GLOBAL__sub_I_OSCollection.cpp_0"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "OSKext"
            "OSKextSavedMutableSegment"
            "OSDextStatistics"
            "OSDextCrash"
        }
        symbol = "_GLOBAL__sub_I_OSKext.cpp"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: Unsupported kmod_info->id (%d) @%s:%d"
            "allocAndInitFakeKext"
            "CFBundleName"
        }
        symbol = "__ZN6OSKext20allocAndInitFakeKextEP9kmod_info"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Kernel kext log filter 0x%x per kextlog boot arg."
            "-nokcmismatchpanic"
            "OSKernelCPUType"
            "OSKernelCPUSubtype"
            "__kmod_info"
            "com.apple.iokit.IOSurface"
            "Kext system initialized."
        }
        symbol = "__ZN6OSKext10initializeEv"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Jettisoning kext bootstrap segments."
            "__PRELINK"
            "__symtab"
            "keepsyms boot arg specified; keeping linkedit segment for symbols."
        }
        symbol = "__ZN6OSKext19removeKextBootstrapEv"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Flushing dependency info for non-loaded kexts."
            "Checking for unused kexts to autounload."
            "Request Stale"
        }
        symbol = "__Z22_OSKextConsiderUnloadsPvS_"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Can't get kernelmanagerd port."
            "kernelmanagerd ping failed (0x%x)."
        }
        symbol = "__ZN6OSKext15pingIOKitDaemonEv"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "System shutdown; requesting immediate kernelmanagerd exit."
        }
        symbol = "__ZN6OSKext12willShutdownEv"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Autounloading for kext %s now %sabled."
        }
        symbol = "__ZN6OSKext20setAutounloadEnabledEb"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Dext %s DextUniqueIdentifier too long."
            "Dext %s does not have a DextUniqueIdentifier"
        }
        symbol = "__ZN6OSKext17parseDextUniqueIDEP12OSDictionaryPKc"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Kext %s can't find prelinked kext executable size."
            "Failed to allocate space for prelinked kext %s."
            "Kext %s failed to create executable wrapper."
            "Kext %s can't find prelinked kext kmod_info address."
            "ModuleIndex"
            "OSMutableSegmentCopy"
            "Saving kext %s mutable segment %.*s %llx->%llx."
            "Kext %s failed to save mutable segment %llx->%llx."
        }
        symbol = "__ZN6OSKext25initWithPrelinkedInfoDictEP12OSDictionaryb7kc_kind"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Requested codeless kext dictionary does not contain the '%s' key"
            "Refusing to register codeless kext that declares an executable/kernel component: %s"
        }
        symbol = "__ZN6OSKext20initWithCodelessInfoEP12OSDictionary"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "No booter-provided data for kext device tree entry %s."
            "No kext info dictionary for booter device tree entry %s."
            "Can't translate physical address 0x%x of kext info dictionary for device tree entry %s."
            "Error unserializing info dictionary for device tree entry %s: %s."
            "Can't translate physical address 0x%x of kext bundle path for device tree entry %s."
            "Failed to create wrapper for device tree entry %s kext path %s."
            "Can't translate physical address 0x%x of kext executable for device tree entry %s."
            "Failed to create executable wrapper for device tree entry %s."
            "Failed to set kext executable for device tree entry %s."
        }
        symbol = "__ZN6OSKext18initWithBooterDataEP8OSStringP6OSData"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "New dext %s, v%s requested does not have a unique dext identifier\n"
            "Found a dext %s, v%s: with no unique dext identifier\n"
            "Refusing new dext %s, v%s:a dext v %s with the same unique dext identifier (%s) already exists\n"
            "Dext %s, v%s , unique dext identifier %s Upgraded to v%s, unique dext identifier %s \n"
            "Upgrade delayed for %s v%s, unique dext identifier %s with v%s, unique dext identifier %s.\n"
            "Notice - new kext %s, v%s matches a %s dextwith the same bundle ID, v%s."
            "Notice - new kext %s, v%s matches %s kext but can't determine if executables are the same (no UUIDs)."
            "Refusing new kext %s, v%s: a %s copy is already present (same version and executable)."
            "Refusing new kext %s, v%s: already have %s v%s."
            "Refusing new kext %s, v%s: a %s copy with a different executable UUID is already present."
            "Refusing new kext %s, v%s: a codeless copy is already %s"
            "Dropping old copy of kext %s (v%s) for newly-added (v%s)."
            "Dropping lower version (v%s) of registered kext %s for higher (v%s)."
            "Kext %s is already registered with a higher/same version (v%s); dropping newly-added (v%s)."
            "Kext %s, v%s registered and available for loading."
        }
        symbol = "__ZN6OSKext18registerIdentifierEv"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Attempt to set info dictionary on a kext that already has one (%s). @%s:%d"
            "OSBundleEnableKextLogging"
            "CFBundleIdentifier missing/invalid type in kext %s."
            "Can't copy bundle identifier as symbol for kext %s."
            "Kext %s error - CFBundleIdentifier over max length %d."
            "Kext %s error - CFBundleVersion missing/invalid type."
            "Kext %s error - CFBundleVersion bad value '%s'."
            "Kext %s error - OSBundleCompatibleVersion bad value '%s'."
            "Kext %s error - %s %s > %s %s (must be <=)."
        }
        symbol = "__ZN6OSKext24setInfoDictionaryAndPathEP12OSDictionaryP8OSString"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Attempt to set an executable on a kext that already has one (%s). @%s:%d"
        }
        symbol = "__ZN6OSKext13setExecutableEP6OSDataS1_b"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "HIDDefaultBehavior"
            "HIDPointerAccelerationType"
            "HIDRemoteControlType"
            "HIDScrollAccelerationType"
            "Physical Interconnect Location"
            "Vendor"
            "Vendor Identification"
            "Vendor Name"
            "bConfigurationValue"
            "bInterfaceNumber"
            "idProduct"
        }
        symbol = "__ZN6OSKext27uniquePersonalityPropertiesEP12OSDictionaryb"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Attempt to free loaded kext %s. @%s:%d"
            "Freeing dext %s but dextLaunchedCount is %d\n @%s:%d"
        }
        symbol = "__ZN6OSKext4freeEv"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Internal error; invalid arguments to OSKext::serializeLogInfo()."
            "Failed to create serializer on log info for request from user space."
            "Failed to serialize log info for request from user space."
            "Failed to copy log info for request from user space."
        }
        symbol = "__ZN6OSKext16serializeLogInfoEP7OSArrayPPcPj"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Failed to query kext UUID (MAC policy error 0x%x)."
        }
        symbol = "__ZN6OSKext22copyKextUUIDForAddressEP8OSNumber"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Failed to remove kext %s (MAC policy error 0x%x)."
            "Can't remove kext %s; unsupported by cache."
            "Can't remove kext %s; services failed to terminate - 0x%x."
            "Can't remove kext %s; kext failed to unload - 0x%x."
            "Fileset kext %s unloaded."
            "Removing kext %s."
        }
        symbol = "__ZN6OSKext10removeKextEPS_b"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Can't remove kext %s - not found."
        }
        symbol = "__ZN6OSKext24removeKextWithIdentifierEPKcb"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Can't remove kext with load tag %d - not found."
        }
        symbol = "__ZN6OSKext21removeKextWithLoadTagEjb"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Driver-"
            "\"%s\" not a kext"
        }
        symbol = "__ZN6OSKext31createExcludeListFromBooterDataEP12OSDictionaryP20OSCollectionIterator"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "OSKextExcludeList"
        }
        symbol = "__ZN6OSKext17updateExcludeListEP12OSDictionary"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "OSBundleRequired"
            "Local-Root"
            "Network-Root"
            "Safe Boot"
            "Console"
        }
        symbol = "__ZN6OSKext20isLoadableInSafeBootEv"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Cannot unload dext for upgrade %s: %d\n"
            "Cannot send upgrade notification for %s\n"
        }
        symbol = "__ZN6OSKext19replaceDextInternalEPS_S0_"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Pending upgrade found for %s but dextLaunchedCount is 0!\n"
        }
        symbol = "__ZN6OSKext11upgradeDextEPS_S0_"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s services failed to terminate - 0x%x."
        }
        symbol = "__ZN6OSKext10removeDextEPS_"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Cannot find dext UniqueID for %s, cannot increment dext launches\n"
            "Too many dexts launched for %s UniqueID %s\n"
            "New dext launched for  %s UniqueID %s"
            "Dext %s UniqueID %s requires update, cannot launch a new dext\n"
            "Dext %s: UniqueID %s does not match UniqueID looked for %s, cannot launch a new dext\n"
        }
        symbol = "__ZN6OSKext24incrementDextLaunchCountEPS_P6OSData"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Cannot find dext for %s, cannot decrement dext launches\n"
            "Cannot find dext UniqueID for %s, cannot decrement dext launches\n"
            "Over decrementing dext launch for %s UniqueID %s\n"
            "Dext terminated for %s UniqueID %s"
            "Dext upgrade for %s UniqueID %s"
            "Dext unload for %s UniqueID %s"
        }
        symbol = "__ZN6OSKext24decrementDextLaunchCountEP8OSString"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Allocation failure."
        }
        symbol = "__ZN6OSKext22getPropertyForHostArchEPKc"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Can't load kext %s - not found."
            "Can't load kext %s - requests to user space are disabled."
            "Kext Load Request"
            "Kext %s not found; queued load request to user space."
            "Kext %s might not load - kernelmanagerd is currently unavailable."
        }
        symbol = "__ZN6OSKext22loadKextWithIdentifierEP8OSStringPP8OSObjectbbhhP7OSArray"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Received kext KC load request from user space."
            "Switching to late startup (user-space) kext loading policy."
            "Start Exclude Level"
            "Start Matching Exclude Level"
            "Personality Names"
            "Received request from user space to load KC kext %s."
            "Kext %s Loaded successfully from %s KC"
        }
        symbol = "__ZN6OSKext14loadKextFromKCEPS_P12OSDictionary"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Codeless Kext Info"
            "Missing 'Codeless Kext Info' dictionary in codeless kext load request of %s."
            "Received request from user space to load codeless kext %s."
            "Could not instantiate codeless kext."
            "Codeless kext identifiers don't match '%s' != '%s'"
        }
        symbol = "__ZN6OSKext16loadCodelessKextEP8OSStringP12OSDictionary"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Recorded kext %s as a candidate for inclusion in prelinked kernel."
            "Failed to record kext %s as a candidate for inclusion in prelinked kernel."
        }
        symbol = "__ZN6OSKext23recordIdentifierRequestEP8OSString"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Kext %s is not loadable"
            "Kext %s is already loaded."
            "Failed to load kext %s (MAC policy error 0x%x)."
            "Kext loading is disabled (attempt to load kext %s)."
            "Can't load kext %s - no more load tags to assign."
            "Loading kext %s."
            "Can't load kext %s - not in a kext collection."
            "Can't load kext %s - failed to resolve library dependencies."
            "Internal error loading kext %s; dependency disappeared."
            "Dependency %s of kext %s failed to load."
            "Kext %s start failed (result 0x%x)."
            "Kext %s failed to load (0x%x)."
            "Kext %s loaded."
            "Kext Load Notification"
        }
        symbol = "__ZN6OSKext4loadEhhP7OSArray"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Sliding kext %s: External relocations found."
            "Sliding kext %s: No linkedit segment."
            "Sliding kext %s: No segments."
            "Sliding kext %s: Unexpected relocation found."
            "Kext %s: new kext size is too large."
        }
        symbol = "__ZN6OSKext24slidePrelinkedExecutableEb"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "7.9.9"
            "Kernel component %s has incorrect version %s; expected %s."
            "Not entitled to link kext '%s'"
            "Can't load kext %s - executable is missing."
            "Refusing to link non-prelinked kext: %s (no kxld support)"
            "Kext %s header size is too large (%lu > UINT32_MAX)."
            "Kext %s size is too large (%lu > UINT32_MAX)."
            "Kext %s executable loaded; %u pages at 0x%lx (load tag %u)."
            "__asan_globals"
            "KASAN: cannot load KASAN-ified kext %s on a non-KASAN kernel\n"
            "Failed to load executable for kext %s."
        }
        symbol = "__ZN6OSKext14loadExecutableEv"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "FileSet booted with no Linkedit segment @%s:%d"
            "Jettisoning fileset Linkedit segments from vmaddr %llx with size %llu"
        }
        symbol = "_ZN6OSKext30jettisonFileSetLinkeditSegmentEP14mach_header_64"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Attempt to set linked executable on kext that already has one (%s).\n @%s:%d"
        }
        symbol = "__ZN6OSKext19setLinkedExecutableEP6OSData"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "OSBundleForceDTraceInit"
            "Ignoring OSBundleForceDTraceInit for Boot KC Kext %s"
        }
        symbol = "__ZN6OSKext18registerWithDTraceEv"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Kext %s failed to set initial VM protections for segment %s - 0x%x."
        }
        symbol = "__ZN6OSKext15setVMAttributesEbb"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Kext %s - NULL kmod_info pointer."
            "Kext %s - NULL module %s pointer."
            "Kext %s module %s pointer is outside of kext range (%s %p - kext starts at %p)."
            "Kext %s module %s pointer is outside of kext range (%s %p - kext at %p-%p)."
            "Kext %s - bad %s pointer %p."
        }
        symbol = "__ZN6OSKext19validateKextMappingEb"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Kext %s - page %p is not backed by physical memory."
        }
        symbol = "_ZN6OSKext20verifySegmentMappingEP18segment_command_64"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Attempt to start nonloaded kext %s."
            "Kext loading is disabled (attempt to start kext %s)."
            "Kext %s start - internal error, dependency disappeared."
            "Kext %s start - dependency %s failed to start (error 0x%x)."
            "Not starting %s - dependency %s not started yet."
            "Kext %s calling module start function."
            "Kext %s is now started."
            "Kext %s did not start (return code 0x%x)."
        }
        symbol = "__ZN6OSKext5startEb"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Attempt to stop nonloaded kext %s."
            "Kext %s - C++ instances; can't stop."
            "Kext %s - has references (linkage or tracking object); can't stop."
            "Kext %s calling module stop function."
            "Kext %s is now stopped and ready to unload."
            "Kext %s did not stop (return code 0x%x)."
        }
        symbol = "__ZN6OSKext4stopEv"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Kext unloading is disabled (%s)."
            "Can't unload kext %s; outstanding references %d (linkage or tracking object)."
            "Can't unload kext %s; classes have instances:"
            "Kext %s can't unload - module stop returned 0x%x."
            "Kext %s unloading."
            "Failed to reset kext %s."
            "Kext %s unloaded."
        }
        symbol = "__ZN6OSKext6unloadEv"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Kext %s has delayed autounload set; skipping and clearing flag."
        }
        symbol = "__ZN6OSKext14autounloadKextEPS_"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%scheduling %sscan for unused kexts in %lu seconds."
            "initial "
        }
        symbol = "__ZN6OSKext15considerUnloadsEb"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Kext %s has a dependency loop; can't resolve dependencies."
            "Kext %s resolving dependencies."
            "Kext %s can't create bookkeeping stack to resolve dependencies."
            "Kext %s - can't resolve dependencies; %s missing/invalid type."
            "Kext %s - can't allocate dependencies array."
            "Kext %s - can't allocate dependencies iterator."
            "Kext %s - illegal type in OSBundleLibraries."
            "Kext %s - invalid library version %s."
            "Kext %s - library kext %s not found."
            "Kext %s - library kext %s not compatible with requested version %s."
            "Kext %s (prelinked) - library kext %s (v%s) not prelinked."
            "Kext %s added dependency %s."
            "Kext %s pulling %d dependencies from codeless library %s."
            "Kext %s added dependency %s from codeless library %s."
            "Error - kext %s declares a dependency on %s, which is not permitted."
            "Error - kext %s declares %s dependencies. Only %s* dependencies are supported for 64-bit kexts."
            "Warning - kext %s declares no %s* dependencies. If it uses any KPIs, the link may fail with undefined symbols."
            "Kext %s successfully resolved dependencies."
        }
        symbol = "__ZN6OSKext19resolveDependenciesEP7OSArray"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Kext %s - internal error propagating compatibility dependencies."
        }
        symbol = "__ZN6OSKext27addBleedthroughDependenciesEP7OSArray"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Kext %s flushing dependencies."
        }
        symbol = "__ZN6OSKext17flushDependenciesEb"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Notice - kext %s has already registered class %s."
            "Kext %s registered class %s."
            "Kext %s has IOService subclass %s; enabling autounload."
            "Kext %s failed to register class %s."
        }
        symbol = "__ZN6OSKext8addClassEP11OSMetaClassj"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Notice - kext %s asked to unregister unknown class %s."
            "Kext %s unregistering class %s."
            "Failed to unregister kext %s class %s."
        }
        symbol = "__ZN6OSKext11removeClassEP11OSMetaClass"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "    Kext %s class %s has %d instance%s."
        }
        symbol = "__ZN6OSKext26reportOSMetaClassInstancesEj"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Invalid request from user space (not nul-terminated)."
            "Error unserializing request from user space: %s."
            "Recieved kext request from user space with no predicate."
            "Received '%s' request from user space."
            "Access Failure - must be root user."
            "com.apple.private.security.only-bootkc-management"
            "Access Failure - client not entitled to manage file sets."
            "Access Failure - client not entitled to manage non-primary KCs"
            "Access Failure - client not entitled to manage kext in non-primary KC"
            "Invalid arguments to kext start request."
            "Kext %s not found for start request."
            "Invalid arguments to kext stop request."
            "Kext %s not found for stop request."
            "Invalid arguments to AuxKC Bundle Available request."
            "Invalid arguments to kext load from KC request."
            "Kext %s not found for load from KC request."
            "Kext %s does not exist in a KC: refusing to load."
            "Invalid arguments to codeless kext load interface (missing identifier)."
            "Invalid arguments to kext unload request."
            "Kext %s not found for unload request."
            "Terminate IOServices"
            "Get Kext UUID by Address"
            "Kext Request Lookup Address"
            "Kext Request Info Keys"
            "Invalid arguments to kext info request."
            "Returning loaded kext info."
            "Returning kernel requests."
            "Get All Load Requests"
            "Returning load requests."
            "KextLog: Loading FileSet KC(s)\n"
            "KextLog: kernelmanagerd is %s\n"
            "active"
            "not active"
            "KextLog: was reset after userspace reboot\n"
            "Received '%s' invalid request from user space."
            "Request from user space still retained by a kext; probable memory leak."
            "responseObject should be an OSArray if predicate is Get Kernel Requests"
            "Failed to patch dext launch requests."
            "Failed to serialize response to request from user space."
        }
        symbol = "__ZN6OSKext13handleRequestEP4hostjPcjPS2_PjS3_S4_"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "kcUUID length is %d, expected %lu @%s:%d"
            "_PrelinkInfoDictionary"
            "The given KC has no kext info dictionaries"
            "_PrelinkLinkKASLROffsets"
            "Kext info dictionary for kext #%d isn't a dictionary?"
            "Can't find a TEXT segment named '%s' in macho header"
            "%u prelinked kexts"
        }
        symbol = "__ZN6OSKext26addKextsFromKextCollectionEP14mach_header_64P12OSDictionaryPKcPP6OSData7kc_kind"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "An Aux KC has already been registered for deferred processing."
            "The Aux KC has info dictionary"
            "The Aux KC has no UUID in %s"
        }
        symbol = "__ZN6OSKext30registerDeferredKextCollectionEP14mach_header_64R11OSSharedPtrI8OSObjectE7kc_kind"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Invalid '%s' argument value '%s' to kext collection info request."
            "Loaded State"
            "Loaded"
            "Unloaded"
            "Invalid '%s' argument value '%s' for '%s' collection info"
        }
        symbol = "__ZN6OSKext22copyKextCollectionInfoEP12OSDictionaryP7OSArray"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "OSBundleDextStateActive"
        }
        symbol = "__ZN6OSKext13copyDextsInfoEP7OSArrayS1_"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "OSBundleAllPrelinked"
        }
        symbol = "__ZN6OSKext18copyLoadedKextInfoEP7OSArrayS1_"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "__os_log"
            "__cstring"
            "__asan_cstring"
            "OSMetaClassName"
            "OSMetaClassSuperclassName"
            "OSMetaClassTrackingCount"
        }
        symbol = "__ZN6OSKext8copyInfoEP7OSArray"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s/Contents/MacOS/%s"
        }
        symbol = "__ZN6OSKext22copyUserExecutablePathEPK8OSSymbolPcm"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Can't request resource %s for %s - requests to user space are disabled."
            "Resource request has bad callback address."
            "Resource request callback is in a kext that is not started."
            "No more request tags available; restart required."
        }
        symbol = "__ZN6OSKext15requestResourceEPKcS1_PFvjiPKvjPvES4_Pj"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Requesting daemon launch for %s %s with serverName %s and tag %llu%s"
            " with reslid shared cache"
            "Driver Extension Server Name"
            "Driver Extension Server Tag"
            "DriverKit Reslide Shared Cache"
        }
        symbol = "__ZN6OSKext19requestDaemonLaunchEP8OSStringS1_P8OSNumberP9OSBooleanP24IOUserServerCheckInTokenP6OSData"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Notifying of dext upgrade for %s with UniqueID %s"
            "Dext Daemon Upgrade"
        }
        symbol = "__ZN6OSKext17notifyDextUpgradeEP8OSStringP6OSData"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "KextLog: No arguments in plist for loading fileset kext\n"
            "KextLog: Kext loading is disabled (attempt to load KCs)."
            "PageableKCName"
            "KextLog: ignoring Pageable KC load from %s\n"
            "KextLog: Adding kexts from in-memory AuxKC\n"
            "KextLog: WARNING: did not find UUID in deferred Aux KC!"
            "KextLog: can't re-parse deferred AuxKC personalities on IOKit daemon restart"
            "KextLog: ERROR loading deferred AuxKC: PRELINK_INFO wasn't an OSDictionary"
            "KextLog: ERROR loading deferred AuxKC: PRELINK_INFO wasn't an OSDictionary\n"
            "AuxKCName"
            "KextLog: Ignoring AuxKC load from %s\n"
            "Codeless Personalities"
            "KextLog: loading %d codeless kexts/dexts"
        }
        symbol = "__ZN6OSKext16loadFileSetKextsEP12OSDictionary"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Kext %s cannot be reset, mutable segments were not saved."
            "Resetting kext %s, mutable segment %.*s %llx->%llx."
            "Kext %s cannot be reset, mutable segment %llx->%llx could not be restored. @%s:%d"
            "Kext %s cannot be reset, could not find saved mutable segment for %llx->%llx. @%s:%d"
        }
        symbol = "__ZN6OSKext20resetMutableSegmentsEv"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "validateKCFileSetUUID Boot KC UUID was not set at boot."
            "_BootKCID"
            "KextLog: Collection UUID matches with loaded KCs.\n"
        }
        symbol = "__ZN6OSKext21validateKCFileSetUUIDEP12OSDictionary7kc_kind"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "validateKCUUID Info plist does not contain %s KC UUID key."
            "validateKCUUID %s KC UUID has wrong length: %d."
            "KextLog: ERROR: UUID from key:%s %s != expected %s (KC UUID: %s)\n"
            "System KC UUID %s linked against %s, but %s is loaded @%s:%d"
        }
        symbol = "__ZN6OSKext29validateKCUUIDfromPrelinkInfoEPA16_h7kc_kindP12OSDictionaryPKc"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Can't invoke callback for resource request; "
            "Can't invoke kext resource callback; "
        }
        symbol = "__ZN6OSKext16dispatchResourceEP12OSDictionary"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Missing Bundle IDs"
        }
        symbol = "__ZN6OSKext22setMissingAuxKCBundlesEP12OSDictionary"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Bundle Availability"
            "KextLog: AuxKC bundle %s marked as %s"
            "loadable"
            "NOT loadable"
        }
        symbol = "__ZN6OSKext23setAuxKCBundleAvailableEP8OSStringP12OSDictionary"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Kext %s requires an explicit kextload; omitting its personalities."
        }
        symbol = "__ZN6OSKext24copyAllKextPersonalitiesEb"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Sending all eligible registered kexts' personalities to the IOCatalogue %s."
            "and starting matching"
            "but not starting matching"
        }
        symbol = "__ZN6OSKext33sendAllKextPersonalitiesToCatalogEb"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Kext loading is disabled (attempt to start matching for kext %s)."
            "Kext %s sending %d personalit%s to the IOCatalogue%s."
            " and starting matching"
            " but not starting matching"
        }
        symbol = "__ZN6OSKext26sendPersonalitiesToCatalogEbP7OSArray"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Kext %s removing all personalities naming it from the IOCatalogue."
        }
        symbol = "__ZN6OSKext30removePersonalitiesFromCatalogEv"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Failed to allocate user-space log message arrays."
        }
        symbol = "__ZN6OSKext21setUserSpaceLogFilterEjb"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s%s%s\n"
        }
        symbol = "OSKextVLog"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "         can't perform kext scan: no kext summary"
            "         can't perform kext scan: missing kext summary page %p"
        }
        symbol = "__ZN6OSKext21printKextsInBacktraceEPmjPFiPKczEj"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "      Kernel Extensions in backtrace:\n"
        }
        symbol = "___ZN6OSKext21printKextsInBacktraceEPmjPFiPKczEj_block_invoke"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "unknown version"
            "%s%s(%s)[%s]@0x%llx->0x%llx\n"
            "         "
            "            kmod dependency scan stopped due to missing dependency page: %p\n"
            "            kmod dependency scan stopped due to missing kmod page: %p\n"
            "            dependency: %s(%s)[%s]@%p->%p\n"
        }
        symbol = "__ZN6OSKext12printSummaryEP20_loaded_kext_summaryPFiPKczEj"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "OSKext::saveLoadedKextPanicListTyped - NULL kext in loaded kext list; continuing\n"
            "OSKext::saveLoadedKextPanicListTyped - Kext type cast failed in loaded kext list; continuing\n"
            "kext scan stopped due to missing kmod_info page: %p\n"
            "error saving loaded kext info\n"
        }
        symbol = "__ZN6OSKext28saveLoadedKextPanicListTypedEPKciiPcj"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Couldn\\'t allocate kext panic log buffer."
        }
        symbol = "__ZN6OSKext23saveLoadedKextPanicListEv"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "last started kext at %llu: %.*s (addr %p, size %lu)\n"
            "last stopped kext at %llu: %.*s (addr %p, size %lu)\n"
            "loaded kexts:\n"
            "(none)\n"
        }
        symbol = "__ZN6OSKext19printKextPanicListsEPFiPKczE"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Elements of request should be of type OSDictionary"
            "Failed to get request predicate"
            "Could not create send right for object."
            "Could not create OSNumber object."
            "Could not set OSNumber object as request Check In Token"
        }
        symbol = "__ZL23patchDextLaunchRequestsP4taskP7OSArray"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "__llvm_prf_data"
            "__llvm_prf_names"
            "__llvm_prf_name"
        }
        symbol = "__ZL23OSKextGrabPgoDataLockedP6OSKextbPhPyPcy"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%lu.%06d"
        }
        symbol = "__ZL23OSKextPgoMetadataPutAllP6OSKextPhPcPmmPj"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "integer size=\"%d\""
            "0x%lx%08lx"
            "0x%lx"
        }
        symbol = "__ZNK8OSNumber9serializeEP11OSSerialize"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "__cxa_pure_virtual"
        }
        symbol = "__cxa_pure_virtual"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "OSRuntime: C++ runtime failed to initialize. @%s:%d"
        }
        symbol = "OSlibkernInit"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Size of array created by new[] has overflowed @%s:%d"
        }
        symbol = "__ZSt20__throw_length_errorPKc"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s: null structor @%s:%d"
        }
        symbol = "__ZL31OSRuntimeCallStructorsInSectionP6OSKextP9kmod_infoPvP18segment_command_64PKcmm"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "<reference IDREF=\""
        }
        symbol = "__ZN11OSSerialize20previouslySerializedEPK15OSMetaClassBase"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "class %s: xml serialize\n"
            " ID=\""
        }
        symbol = "__ZN11OSSerialize14addXMLStartTagEPK15OSMetaClassBasePKc"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "xml serialize\n"
        }
        symbol = "__ZN11OSSerialize7addCharEc"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "OSUnserialize: can't alloc temp memory\n"
        }
        symbol = "__Z18OSUnserializeparsev"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "unexpected end of buffer"
            "buildDictionary"
            "maximum object count"
            "buildArray"
            "buildSet"
            "buildString"
            "buildData"
            "buildNumber"
            "buildBoolean"
            "maximum object reference count"
            "duplicate dictionary key"
            "format"
            "plist"
        }
        symbol = "__Z21OSUnserializeXMLparsePv"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "OSUnserializeXML: can't alloc temp memory\n"
        }
        symbol = "__ZL9getStringP12parser_statePi"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "No service matching %s"
            "Unable to match CoreAnalyticsHub"
            "CoreAnalyticsHub"
        }
        symbol = "core_analytics_family_match"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Dropping attempt to send a CoreAnalytics event before CoreAnalyticsHub has registered."
            "Unable to serialize CoreAnalytics event: %d"
            "Unable to send CoreAnalytics event. Giving up."
            "Unknown CoreAnalytics event type: %s. @%s:%d"
        }
        symbol = "core_analytics_send_event_lazy"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "CoreAnalyticsHub is out of sync with xnu. CoreAnalyticsHub table version: %d. xnu table version: %d @%s:%d"
            "Registered CoreAnalyticsHub functions with xnu."
        }
        symbol = "core_analytics_hub_register"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Kext %s (load tag %d) has been retained."
            "Can't retain kext with load tag %d - no such kext is loaded."
        }
        symbol = "OSKextRetainKextWithLoadTag"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Kext %s (load tag %d) has been released."
            "Can't release kext with load tag %d - no such kext is loaded."
        }
        symbol = "OSKextReleaseKextWithLoadTag"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "Invalid request from user space (no data)."
            "vm_map_copyout() failed for request from user space."
            "Failed to copy log data for request from user space."
        }
        symbol = "kext_request"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "A kext referenced an unresolved weak symbol @%s:%d"
            "OSKextLib.cpp"
        }
        symbol = "pmap_cs_core_entitlements_abort"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s@%llx:%llx\n"
        }
        symbol = "__telemetry_backtrace_add_kexts_block_invoke"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "(invalid)"
            "(missing)"
        }
        symbol = "OSKextVersionGetString"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%2hhx%2hhx%2hhx%2hhx-%2hhx%2hhx-%2hhx%2hhx-%2hhx%2hhx-%2hhx%2hhx%2hhx%2hhx%2hhx%2hhx%n"
        }
        symbol = "uuid_parse"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x"
        }
        symbol = "_uuid_unparse_lower"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Long logs support disabled: Logging disabled by ATM\n"
            "Long logs support configured: size: %u\n"
            "Long logs support disabled: Not enough memory\n"
        }
        symbol = "oslog_init_logmem"
        caller = "?"
    }
    new {
        args = 3
        anchors {
            "[%5lu.%06u]: "
            "Unknown firehose tracepoint flags %x @%s:%d"
        }
        symbol = "_os_log_with_args_internal"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "Unexpected firehose stream type %u @%s:%d"
        }
        symbol = "log_payload_send"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "unhandled return value @%s:%d"
            "log_encode.c"
        }
        symbol = "os_log_context_encode"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Log queues disabled: Logging disabled by ATM\n"
            "Log queues disabled: Zero lq_size_order boot argument\n"
            "Log queues configured: slot count: %u, per-slot size: %u, total size: %u\n"
        }
        symbol = "oslog_init_log_queues"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "os_refcnt: unexpected release of final reference (rc=%p) @%s:%d"
        }
        symbol = "os_ref_panic_live"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "os_refcnt: underflow (rc=%p) @%s:%d"
        }
        symbol = "os_ref_panic_underflow"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "os_refcnt: attempted resurrection (rc=%p) @%s:%d"
        }
        symbol = "os_ref_panic_retain"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "os_pcpu_ref: destroying live refcount %p at %p @%s:%d"
            "os_pcpu_ref: destroying refcount %p with a waiter at %p @%s:%d"
            "os_pcpu_ref: destroying non-zero refcount %p at %p @%s:%d"
        }
        symbol = "__os_pcpu_ref_destroy_panic"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "os_pcpu_ref: attempted resurrection (rc=%p) @%s:%d"
        }
        symbol = "__os_pcpu_ref_retain_panic"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "os_pcpu_ref: unexpected release of final reference (rc=%p) @%s:%d"
        }
        symbol = "__os_pcpu_ref_release_live_panic"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "os_pcpu_ref: over-release (rc=%p) @%s:%d"
        }
        symbol = "__os_pcpu_ref_release_panic"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "os_pcpu_ref: double-kill (rc=%p) @%s:%d"
        }
        symbol = "__os_pcpu_ref_kill_panic"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "os_pcpu_ref: overflow (rc=%p) @%s:%d"
        }
        symbol = "__os_pcpu_ref_overflow_panic"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "os_pcpu_ref: double-wait (rc=%p) @%s:%d"
            "os_pcpu_ref: wait while still live (rc=%p) @%s:%d"
        }
        symbol = "__os_pcpu_ref_invalid_wait_panic"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "incorrect header check"
            "unknown compression method"
            "invalid window size"
            "unknown header flags set"
            "header crc mismatch"
            "invalid block type"
            "invalid stored block lengths"
            "too many length or distance symbols"
            "invalid code lengths set"
            "invalid literal/lengths set"
            "invalid distances set"
            "incorrect data check"
            "incorrect length check"
        }
        symbol = "inflate"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "zlib deflate"
        }
        symbol = "compress_block"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: inconsistent size for SHA384 context @%s:%d"
            "SHA384_Init"
        }
        symbol = "SHA384_Init"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "sha1_hardware_hook: Called twice.. Should never happen @%s:%d"
            "corecrypto_sha1.c"
        }
        symbol = "sha1_hardware_hook"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: inconsistent size for DES-ECB context @%s:%d"
            "des_ecb_key_sched"
        }
        symbol = "des_ecb_key_sched"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: inconsistent size for 3DES-ECB context @%s:%d"
            "des3_ecb_key_sched"
        }
        symbol = "des3_ecb_key_sched"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: corecrypto not registered! @%s:%d"
            "%s: xts mode not registered? enc=%p, dec=%p @%s:%d"
            "%s: inconsistent size for AES-XTS context @%s:%d"
        }
        symbol = "xts_start"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "xts encrypt not a multiple of block size @%s:%d"
        }
        symbol = "xts_encrypt"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "xts decrypt not a multiple of block size @%s:%d"
        }
        symbol = "xts_decrypt"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "coretrust interface already set @%s:%d"
            "coretrust.c"
        }
        symbol = "coretrust_interface_register"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "apple_encrypted_archive interface already set @%s:%d"
        }
        symbol = "apple_encrypted_archive_interface_register"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "img4 interface already set @%s:%d"
            "interface.c"
        }
        symbol = "coretrust_interface_register_0"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "image4 dlxk interface already set @%s:%d"
            "dlxk.c"
        }
        symbol = "image4_dlxk_link"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "AppleMobileFileIntegrity interface already set @%s:%d"
            "amfi.c"
        }
        symbol = "amfi_interface_register"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "ptrauth_utils_auth_blob_generic: ptr must not be NULL @%s:%d"
            "signature mismatch for %lu bytes at %p, calculated %lx vs %lx @%s:%d"
        }
        symbol = "ptrauth_utils_auth_blob_generic"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "compression interface already set @%s:%d"
        }
        symbol = "apple_encrypted_archive_interface_register_0"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "OSAction"
        }
        symbol = "_GLOBAL__sub_I_OSCollection.cpp_2"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "IODispatchSource"
        }
        symbol = "_GLOBAL__sub_I_OSCollection.cpp_3"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "IODispatchQueue"
        }
        symbol = "_GLOBAL__sub_I_OSCollection.cpp_4"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "IOInterruptDispatchSource"
        }
        symbol = "_GLOBAL__sub_I_IOUserClient.iig.cpp_0"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "IOServiceStateNotificationDispatchSource"
        }
        symbol = "_GLOBAL__sub_I_IOUserClient.iig.cpp_3"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "IOEventLink"
        }
        symbol = "_GLOBAL__sub_I_OSCollection.cpp_5"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "IOWorkGroup"
        }
        symbol = "_GLOBAL__sub_I_OSCollection.cpp_6"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "hibernate_set_page_state @%s:%d"
        }
        symbol = "hibernate_set_page_state"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "boot-signature"
            "bridge-boot-session-uuid"
            "hfile"
        }
        symbol = "IOHibernateSystemInit"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "couldn\\'t find sectHIBTEXTB in segInfo @%s:%d"
        }
        symbol = "hibernate_write_image"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "handoff overflow @%s:%d"
            "handoff out of range @%s:%d"
            "kIOHibernateHandoffTypeCryptVars(%d) @%s:%d"
            "kIOHibernateHandoffTypeVolumeCryptKey(%d) @%s:%d"
            "no volumeCryptKey @%s:%d"
            "hibernate handoff @%s:%d"
            "IOPolledFilePollersSetEncryptionKey(0x%x) @%s:%d"
            "Hibernate restore error %x @%s:%d"
            "image2 pages corrupted @%s:%d"
        }
        symbol = "hibernate_machine_init"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "handoff %p, %x, %x\n"
            "failed to find %s in IORegistry @%s:%d"
        }
        symbol = "__ZL15IOHibernateDoneP15IOHibernateVars"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "no name @%s:%d"
        }
        symbol = "__ZL15MergeDeviceTreePK13OpaqueDTEntryP15IORegistryEntryP5OSSetmm"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "com.apple.private.hibernation.set-preview"
        }
        symbol = "__ZL21hibernate_set_previewP10sysctl_oidPviP10sysctl_req"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "pid %d, "
        }
        symbol = "IOCopyLogNameForPID"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Invalid offset %p for aligned addr %p @%s:%d"
            "alignMask 0x%llx overflows recalAlignedStart %p for provided addr %p @%s:%d"
            "Recalculated aligned addr %p doesn't match provided addr %p @%s:%d"
            "Offset %zd doesn't accomodate IOLibPageMallocHeader for aligned addr %p @%s:%d"
            "alignMask 0x%llx overflows adjusted size %zd for aligned addr %p @%s:%d"
        }
        symbol = "__ZL33IOMallocAlignedHdrCorruptionPanicyyym"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "IOKitBuildVersion"
            "_NO_NAME_4"
        }
        symbol = "iokit_post_constructor_init"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Failed to initialize IOKit root nub @%s:%d"
        }
        symbol = "InitIOKit"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Failed to start IOService matching @%s:%d"
        }
        symbol = "StartIOKitMatching"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "IODeviceTree:/chosen"
            "IOProgressColorTheme"
        }
        symbol = "IORecordProgressBackbuffer"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "IODeviceTree"
            "AAPL,unit-string"
            "bridge-model"
            "#size-cells"
            "#address-cells"
            "IODTPersist"
            "associated-service"
            "IOPrimaryInterruptController"
            "IONWInterrupts"
            "AAPL,interrupts"
            "interrupt-parent"
            "#interrupt-cells"
            "exclave-edk-endpoint"
            "exclave-endpoint"
            "disp0"
        }
        symbol = "__Z17IODeviceTreeAllocPv"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "IOInterruptController%08X"
        }
        symbol = "__Z27IODTInterruptControllerNameP15IORegistryEntry"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "AAPL,ignore"
        }
        symbol = "__Z23IODTFindMatchingEntriesP15IORegistryEntryjPKc"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "IODTSetResolving - gIODTResolvers alloc overflows @%s:%d"
            "IODTSetResolving - could not allocate new resolvers @%s:%d"
        }
        symbol = "__Z16IODTSetResolvingP15IORegistryEntryPFxjPjS1_EPFvS0_PhS4_S4_E"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "IODTResolveAddressCell: Invalid device tree (%u,%u) @%s:%d"
            "There is no mixed comparison function yet... @%s:%d"
            "IODTResolveAddressCell: Invalid device tree (%u) @%s:%d"
            "IODTResolveAddressCell: Invalid device tree (%u, %u) @%s:%d"
        }
        symbol = "__Z22IODTResolveAddressCellP15IORegistryEntryPjPyS2_"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "slot-names"
        }
        symbol = "__Z16IODTFindSlotNameP15IORegistryEntryj"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "kernel-only"
        }
        symbol = "__ZL18MakeReferenceTablePK13OpaqueDTEntryb"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: error mapping interrupt[%d]\n"
            "interrupt-map"
            "interrupt-map-mask"
        }
        symbol = "__ZL24IODTMapInterruptsSharingP15IORegistryEntryP12OSDictionary"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "DefaultCompare only knows how to handle 1 or 2 cells. @%s:%d"
        }
        symbol = "__ZL14DefaultComparejPjS_"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "IORegistryLock"
            "IOName"
            "IOLocation"
            "IORegistryEntryID"
            "IORegistryEntryPropertyKeys"
            "IORegistryPlanes"
        }
        symbol = "__ZN15IORegistryEntry10initializeEv"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "ChildLinks"
        }
        symbol = "__ZN15IORegistryEntry9makePlaneEPKc"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: attached at free() @%s:%d"
            "IORegistryEntry.cpp"
        }
        symbol = "__ZN15IORegistryEntry4freeEv"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "_IOServiceNullNotifier"
            "_IOConfigThread"
            "IOUserResources"
            "_IOServiceStateNotification"
            "IOServiceCompatibility"
        }
        symbol = "_GLOBAL__sub_I_IOService.cpp"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "IOPower"
            "IOPropertyMatch"
            "IOPropertyExistsMatch"
            "IOLocationMatch"
            "IOParentMatch"
            "IODefaultMatchCategory"
            "IOMatchedAtBoot"
            "IOMatchedServiceCountMatch"
            "IOMatchedPersonality"
            "IORematchPersonality"
            "IORematchCount"
            "IODEXTMatchCount"
            "IOServiceLegacyMatchingRegistryID"
            "dextrelaunch"
            "iocthreads"
            "IOUserClientClass"
            "IOUserClasses"
            "IOUserServerName"
            "IOUserServerTag"
            "IOUserServerOneProcess"
            "IOUserServerPreserveUserspaceReboot"
            "IOResourceMatch"
            "IOResourceMatched"
            "IODeviceMemory"
            "IOInterruptControllers"
            "IOInterruptSpecifiers"
            "IOCompatibilityMatch"
            "IOCompatibilityProperties"
            "IOPath"
            "IOSupportedProperties"
            "IOMapperID"
            "IOKitDebug"
            "IOCommandPoolSize"
            "IOGeneralInterest"
            "IOBusyInterest"
            "IOAppPowerStateInterest"
            "IOPriorityPowerStateInterest"
            "IOConsoleSecurityInterest"
            "IOServicePublish"
            "IOServiceFirstPublish"
            "IOServiceMatched"
            "IOServiceFirstMatch"
            "IOServiceTerminate"
            "IOServiceWillTerminate"
            "IOConsoleLocked"
            "IOConsoleUsers"
            "kCGSSessionUserIDKey"
            "kCGSSessionAuditIDKey"
            "IOConsoleUsersSeed"
            "kCGSSessionOnConsoleKey"
            "kCGSessionLoginDoneKey"
            "kCGSSessionSecureInputPID"
            "CGSSessionScreenLockedTime"
            "CGSSessionScreenIsLocked"
            "IOServiceDEXTEntitlements"
            "com.apple.developer.driverkit"
            "com.apple.developer.driverkit.userclient-access"
            "com.apple.developer.driverkit.allow-any-userclient-access"
            "com.apple.private.driverkit.driver-access"
            "com.apple.private.driverkit.test-driver"
            "com.apple.developer.driverkit.communicates-with-drivers"
            "com.apple.developer.driverkit.allow-third-party-userclients"
            "IOMatchDefer"
            "IOServiceMatchDeferred"
            "IOServiceNotificationUser"
            "IOPrimaryDriverTerminateOptions"
            "IOBlockStorageDriver"
            "Virtual Interface"
            "IOAllCPUInitialized"
            "IOPlatformFunctionHandlerSet"
            "IOPlatformFunctionHandlerMaxBusDelay"
            "getKey"
            "IOAssociatedServices"
            "IOServiceTerminateThread"
        }
        symbol = "__ZN9IOService10initializeEv"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s::attach(%s)\n"
        }
        symbol = "__ZN9IOService6attachEPS_"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s::detach(%s)\n"
        }
        symbol = "__ZN9IOService6detachEPS_"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s: not registry member at registerService()\n"
            "Registering: "
        }
        symbol = "__ZN9IOService15registerServiceEj"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: Failed to acquire power assertion for matching @%s:%d"
        }
        symbol = "__ZN9IOService13startMatchingEj"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Matching service count = %ld\n"
        }
        symbol = "__ZN9IOService17catalogNewDriversEP12OSOrderedSet"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Class %s passed the %s action to IOService @%s:%d"
        }
        symbol = "__ZN9IOService20callPlatformFunctionEPK8OSSymbolbPvS3_S3_S3_"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "IOPlatformMaxBusDelay"
        }
        symbol = "__ZN9IOService11setPlatformEP16IOPlatformExpert"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "I/O Kit: Unrecoverable deadlock. @%s:%d"
        }
        symbol = "__ZN9IOService18lockForArbitrationEb"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s[0x%qx]::terminatePhase1(%08llx)\n"
            "%s[0x%qx]::waitPhase1(%s[0x%qx])\n"
            "%s[0x%qx]::did waitPhase1(%s[0x%qx])\n"
            "%s[0x%qx]::requestTerminate(%s[0x%qx], %08llx)\n"
            "%s[0x%qx]::requestTerminate(%s[0x%qx], ok = %d)\n"
            "%s[0x%qx]::wakePhase1\n"
            "DK: %s-0x%qx rematching after dext crash\n"
        }
        symbol = "__ZN9IOService15terminatePhase1Ej"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s[0x%qx]::terminate(kIOServiceSynchronous): THREAD_TIMED_OUT. Attempting to auto-resolve your deadlock. PLEASE FIX!\n"
        }
        symbol = "__ZN9IOService23scheduleTerminatePhase2Ej"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s[0x%qx]::scheduleStop(%s[0x%qx])\n"
        }
        symbol = "__ZN9IOService12scheduleStopEPS_"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s[0x%qx]::scheduleFinalize\n"
        }
        symbol = "__ZN9IOService16scheduleFinalizeEb"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s[0x%qx]::finalize(%08llx)\n"
        }
        symbol = "__ZN9IOService14actionFinalizeEPS_jPvS1_S1_"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s[0x%qx]::stop(%s[0x%qx])\n"
            "%s[0x%qx]::detach(%s[0x%qx])\n"
        }
        symbol = "__ZN9IOService10actionStopEPS_S0_PvS1_S1_"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s[0x%qx]::defer phase2(%s[0x%qx])\n"
            "%s[0x%qx]::nop stop(%s[0x%qx])\n"
            "%s[0x%qx]::defer stop()\n"
            "iokit terminate done, %d stops remain\n"
        }
        symbol = "__ZN9IOService15terminateWorkerEj"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s[0x%qx]::stop1(%s[0x%qx])\n"
        }
        symbol = "__ZN9IOService8finalizeEj"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: match category %s exists\n"
            "%s: stalling for module\n"
            "Couldn\\'t alloc class \"%s\"\n"
            "%s::init fails\n"
            "%s::probe(%s)\n"
            "%s::probe fails\n"
            "%s(0x%qx): %u categories\n"
            "match category exists, skipping "
            "%s::start(%s) <%d>\n"
            "%s(0x%qx): matching deferred by %s%s\n"
            " in userspace reboot"
            "%s::start(%s) <%d> failed\n"
            "Can't replace primary matched driver on root media %s-0x%qx\n"
        }
        symbol = "__ZN9IOService15probeCandidatesEP12OSOrderedSet"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s(0x%qx): category %s, %u matches\n"
        }
        symbol = "___ZN9IOService15probeCandidatesEP12OSOrderedSet_block_invoke"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s(0x%qx): category %s: matched %s, probe score %qd\n"
        }
        symbol = "___ZN9IOService15probeCandidatesEP12OSOrderedSet_block_invoke_2"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "deferring %s-%llx (provider of %s-%llx) matching after userspace reboot\n"
        }
        symbol = "__ZN9IOService19userSpaceWillRebootEv"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "DK: Waiting for %u user servers, %u matching work\n"
            "DK: allowPowerChange\n"
        }
        symbol = "__ZN11IOServicePH9serverAckEP12IOUserServer"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "DK: sleep deferred rematching count %d\n"
        }
        symbol = "__ZN11IOServicePH11matchingEndEP9IOService"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "DK: ack timer expired\n"
            "DK ack timer expired after %u ms @%s:%d"
        }
        symbol = "__ZN11IOServicePH25userServerAckTimerExpiredEPvS0_"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "DK: %s-0x%qx power state transition failed\n"
            "Power Management Failed"
        }
        symbol = "___ZN11IOServicePH25userServerAckTimerExpiredEPvS0__block_invoke"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "IOServicePH::kIOMessageSystemCapabilityChange: %s%s 0x%x->0x%x\n"
            "DK: arming ack timer, %u ms\n"
        }
        symbol = "__ZN11IOServicePH17systemPowerChangeEPvS0_jP9IOServiceS0_m"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "DK: %s-0x%qx dext launches are disabled \n"
            "DK: %s disabled in shutdown\n"
            "DK: %s deferred in sleep\n"
            "DK: %s-0x%qx using existing server %s-0x%qx\n"
            "DK: %s-0x%qx waiting for server %s-%llx\n"
            "DK: %s-0x%qx failed to launch server\n"
            "DK: %s-0x%qx user server timeout\n"
            "Check In Token verification failed"
            "Entitlements check failed"
            "%s::start took %ld ms\n"
        }
        symbol = "__ZN9IOService14startCandidateEPS_"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: Can't match using: %s\n"
            "config(%p): stalling %s\n"
            "config(%p): waking\n"
        }
        symbol = "__ZN9IOService13checkResourceEP8OSObject"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "IOConfigThread_'%s'"
        }
        symbol = "__ZN15_IOConfigThread12configThreadEPKc"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: bad busy count (%d,%d)\n"
        }
        symbol = "__ZN9IOService11_adjustBusyEib"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "busy extended ok[%d], (%llds, %llds)\n"
            "IOServiceBusyTimeoutExtensions"
            "registry root held busy, kernelmanagerd %s checked in"
            "has not"
            "%s'%s' (%x,%x)"
            "%s[%d], (%llds): multiple entries holding the registry busy, IOKit termination queue depth %u: %s"
            "IOKit Daemon (kernelmanagerd) stall"
            "busy timeout"
            "%s[%d], (%llds): %s"
        }
        symbol = "__ZN9IOService20waitQuietWithOptionsEyj"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "thread_policy_set(%d)\n"
            "config(%p): starting on %s, %d\n"
            "config(%p): strange type (%d)\n"
            "config(%p): terminating\n"
        }
        symbol = "__ZN15_IOConfigThread4mainEPvi"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "config(%d): creating\n"
        }
        symbol = "__ZN13_IOServiceJob10pingConfigEPS_"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "deliverNotification @%s:%d"
        }
        symbol = "__ZN9IOService19deliverNotificationEPK8OSSymboljj"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "IOConsoleUsers: gIOScreenLockState %d, hs %d, bs %d, now %ld, sm 0x%x\n"
        }
        symbol = "__ZN9IOService18updateConsoleUsersEP7OSArrayjb"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "com.apple.private.iokit.ioresources.setproperty"
        }
        symbol = "__ZN11IOResources13setPropertiesEP8OSObject"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: family specific matching fails\n"
        }
        symbol = "__ZN9IOService12matchPassiveEP12OSDictionaryj"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "addInterruptStatistics called for an excessively large index (%d) @%s:%d"
            "%s %d"
            "Interrupt Statistics (by index)"
            "addInterruptStatistics call for index %d would have clobbered existing statistics @%s:%d"
        }
        symbol = "__ZN9IOService22addInterruptStatisticsEP25IOInterruptAccountingDatai"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "removeInterruptStatistics called for index %d, which was never registered @%s:%d"
            "removeInterruptStatistics called for empty index %d @%s:%d"
        }
        symbol = "__ZN9IOService25removeInterruptStatisticsEi"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "com.apple.private.iokit.IOServiceSetAuthorizationID"
        }
        symbol = "__ZN9IOService18setAuthorizationIDEy"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "DevicePowerState"
            "DriverPowerState"
            "ChildProxyPowerState"
            "ChildrenPowerState"
            "AdvisoryTicklePowerState"
            "RootDomainPower"
        }
        symbol = "__ZN9IOService6PMinitEv"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s: PMstop() already stopped\n"
            "%s: %p PMstop\n"
        }
        symbol = "__ZN9IOService6PMstopEv"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s: %p %s start\n"
            "%s: %p %s done\n"
        }
        symbol = "__ZN9IOService12handlePMstopEP11IOPMRequest"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s: %s (%p) is already a child\n"
        }
        symbol = "__ZN9IOService13addPowerChildEPS_"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: addPowerChild2 not in power plane\n"
        }
        symbol = "__ZN9IOService14addPowerChild2EP11IOPMRequest"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: strict PM order enforced\n"
            "%s: addPowerChild3 not in power plane\n"
        }
        symbol = "__ZN9IOService14addPowerChild3EP11IOPMRequest"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "handlePowerDomainWillChangeTo"
        }
        symbol = "__ZN9IOService29handlePowerDomainWillChangeToEP11IOPMRequest"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "handlePowerDomainDidChangeTo"
            "aotPS %s0x%qx[%ld]\n"
            "%s::powerDomainDidChangeTo parentsKnowState %d\n"
        }
        symbol = "__ZN9IOService28handlePowerDomainDidChangeToEP11IOPMRequest"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s::requestPowerDomainState\n"
            "%s: power drop cancelled in state %u by %s\n"
        }
        symbol = "__ZN9IOService23requestPowerDomainStateEmP17IOPowerConnectionm"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "  %u %s\n"
            "  temp %u, clamp %u, current %u, new %u\n"
        }
        symbol = "__ZN9IOService19computeDesiredStateEmb"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s: %d children in delayed array\n"
        }
        symbol = "__ZN9IOService14notifyChildrenEv"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: notified delayed children\n"
        }
        symbol = "__ZN9IOService21notifyChildrenDelayedEv"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "IOService::pmDriverCallout bad machine state %x @%s:%d"
        }
        symbol = "__ZN9IOService15pmDriverCalloutEPS_Pv"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s::setPowerState(%p, %lu -> %lu) returned 0x%x\n"
        }
        symbol = "__ZN9IOService19driverSetPowerStateEv"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "PM waiting on pmDriverCallout(0x%x) to %s (%u ms)\n"
        }
        symbol = "__ZN9IOService20pmDriverCalloutTimerEPvS0_"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: power desired %u:0x%x got %u:0x%x\n"
        }
        symbol = "__ZN9IOService18requestDomainPowerEmj"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s: tickle desire removed\n"
            "%s: tickle desire dropped\n"
        }
        symbol = "__ZN9IOService26ParentChangeRootChangeDownEv"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "IOPMTardyAckSetPowerState"
            "%s::setPowerState(%p, %lu -> %lu) timed out after %d ms @%s:%d"
            "%s::setPowerState(%p : %p, %lu -> %lu) timed out after %d ms @%s:%d"
            "IOPMTardyAckPowerStateChange"
            "%s::powerState%sChangeTo(%p, %s, %lu -> %lu) timed out after %d ms\n"
            "%s: unexpected ack timer tick (state = %d)\n"
        }
        symbol = "__ZN9IOService12ackTimerTickEv"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "WDOG:Object %s unexpected in blocked array\n"
        }
        symbol = "__ZN9IOService19stop_watchdog_timerEv"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "WDOG:Object %s is already blocked for responses. Ignoring timeout %d\n"
        }
        symbol = "__ZN9IOService20reset_watchdog_timerEPS_i"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "PM priority notification timeout\n"
            "PM priority notification timeout @%s:%d"
        }
        symbol = "__ZN9IOService20cleanClientResponsesEb"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "PMRD: tellClientsWithResponse( %s, %s )\n"
            "tellClientsWithResponse(%s, %s) %d of %d skipped in dark\n"
        }
        symbol = "__ZN9IOService23tellClientsWithResponseEi"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "PMTellAppWithResponse - Suspended"
            "App response ignored"
        }
        symbol = "__ZN9IOService21pmTellAppWithResponseEP8OSObjectPv"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "PMTellCapablityAppWithResponse - Suspended"
            "%s MESG App(%u) %s, wait %u, %s\n"
        }
        symbol = "__ZN9IOService31pmTellCapabilityAppWithResponseEP8OSObjectPv"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "PMRD: tellClients( %s )\n"
        }
        symbol = "__ZN9IOService11tellClientsEi"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "PM response took %d ms (%d, %s)\n"
            "Ack(%u) %u ms\n"
        }
        symbol = "__ZN9IOService13responseValidEji"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "IOPMClientAck"
            "IOPMRequest"
            "IOPMRequestQueue"
            "IOPMWorkQueue"
            "IOPMCompletionQueue"
            "IOServicePM"
        }
        symbol = "_GLOBAL__sub_I_IOServicePM.cpp"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "PMRD: resetting ack timer to %u ms\n"
        }
        symbol = "__ZN9IOService21updateClientResponsesEv"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            " (%s)"
            "PM notification cancel (pid %d, %s)\n"
        }
        symbol = "__ZN9IOService17cancelPowerChangeEm"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s: cancel from machine state %d\n"
        }
        symbol = "__ZN9IOService25handleCancelIdlePowerDownEv"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "bufSize is smaller than the required size\n @%s:%d"
        }
        symbol = "__ZN9IOService26configurePowerStatesReportEjPv"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: No memory for PM request type 0x%x\n"
        }
        symbol = "__ZN9IOService16acquirePMRequestEPS_jP11IOPMRequest"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s: PM not initialized\n"
            "[- %02x] %p [%p %s] !initialized\n"
        }
        symbol = "__ZN9IOService20actionPMRequestQueueEP11IOPMRequestP16IOPMRequestQueue"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "[- %02x] %p [%p %s] state %d, busy %d\n"
        }
        symbol = "__ZN9IOService23actionPMWorkQueueRetireEP11IOPMRequestP13IOPMWorkQueue"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "[B %02x] %p [%p %s] state %d, reason %d\n"
        }
        symbol = "__ZN9IOService11isPMBlockedEP11IOPMRequesti"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "[W %02x] %p [%p %s] state %d\n"
            "%s: idle revert, state %u\n"
            "%s: bad call reason %x @%s:%d"
            "PMWorkQueueInvoke: unknown machine state %x @%s:%d"
        }
        symbol = "__ZN9IOService23actionPMWorkQueueInvokeEP11IOPMRequestP13IOPMWorkQueue"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "executePMRequest: unknown request type %x @%s:%d"
        }
        symbol = "__ZN9IOService16executePMRequestEP11IOPMRequest"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "[A %02x] %p [%p %s] state %d\n"
            "%s: delay notify cancelled\n"
            "PMReplyQueue: unknown reply type %x @%s:%d"
        }
        symbol = "__ZN9IOService18actionPMReplyQueueEP11IOPMRequestP16IOPMRequestQueue"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: %s(%s) on PM thread\n"
            "waitForPMDriverCall"
            "%s: waitForPMDriverCall timeout\n"
        }
        symbol = "__ZN9IOService19waitForPMDriverCallEPS_"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "PM request 0x%x dropped\n"
        }
        symbol = "__ZN13IOPMWorkQueue17checkRequestQueueEP11queue_entryPb"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "CurrentPowerState"
            "CapabilityFlags"
            "MaxPowerState"
            "DesiredPowerState"
            "MachineState"
            "PowerOverrideOn"
            "PowerClamp"
            "IdleTimerPeriod"
            "ActivityTickles"
            "TimeSinceLastTickle"
            "IdleTimerElapsedTime"
            "WQ-CheckForWork"
            "WQ-ScanEntries"
            "WQ-QueueEmpty"
            "WQ-NoWorkDone"
        }
        symbol = "__ZNK11IOServicePM14gatedSerializeEP11OSSerialize"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "PM notification timeout (pid %d, %s)\n"
        }
        symbol = "__ZL14logAppTimeoutsP8OSObjectPv"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "tellAppClientApplier - Suspended"
        }
        symbol = "__ZL20tellAppClientApplierP8OSObjectPv"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "IOPMPowerStateQueue"
        }
        symbol = "_GLOBAL__sub_I_IOPMPowerStateQueue.cpp"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "IOCatalogue"
        }
        symbol = "_GLOBAL__sub_I_OSCollectionIterator.cpp_0"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "KernelConfigTables syntax error: %s\n"
            "IOProbeScore"
            "IOHIDInterface"
        }
        symbol = "__ZN11IOCatalogue10initializeEv"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Missing or bad \"%s\" key\n"
        }
        symbol = "__ZN11IOCatalogue4initEP7OSArray"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "IOCatalogue.cpp"
        }
        symbol = "__ZN11IOCatalogue4freeEv"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "IOCatalogue::addDrivers() encountered non-dictionary; bailing.\n"
        }
        symbol = "__ZN11IOCatalogue10addDriversEP7OSArrayb"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "OSBundleAllowUserTerminate"
            "%sallowing kextunload terminate for bundleID %s\n"
        }
        symbol = "__ZN11IOCatalogue16terminateDriversEP12OSDictionaryPcb"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "preserving service %s-0x%llx during userspace reboot\n"
            "terminating service %s-0x%llx [dext %s]\n"
            "terminating service %s-0x%llx [kext %s]\n"
        }
        symbol = "__ZN11IOCatalogue34terminateDriversForUserspaceRebootEv"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: failed to terminate service %s-0x%qx with options %08llx for new dext %s\n"
            "startMatching_block_invoke"
        }
        symbol = "___ZN11IOCatalogue13startMatchingEPK8OSSymbol_block_invoke.34"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Resetting IOCatalogue.\n"
        }
        symbol = "__ZN11IOCatalogue18resetAndAddDriversEP7OSArrayb"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "enableCPUCore is unimplemented @%s:%d"
            "IOPMGR.cpp"
        }
        symbol = "__ZN6IOPMGR13enableCPUCoreEj"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "IOPolledFilePollers"
        }
        symbol = "_GLOBAL__sub_I_IOPolledInterface.cpp"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "IOPolledInterface::close[%d] 0x%x\n"
        }
        symbol = "IOPolledFilePollersClose"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Preferred Block Size"
            "%qx:%x"
        }
        symbol = "__Z16IOPolledFileOpenPKcjyyPvmPP18IOPolledFileIOVarsPP6OSDataPhPm"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "IOPolledFileWrite(0x%p, 0x%p, %llu, 0x%p) : IOStartPolledIO(0x%p, kIOPolledWrite, %llu, 0x%llx, %d) returned 0x%x\n"
        }
        symbol = "IOPolledFileWrite"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "IOPolledFileFlush(0x%p) : IOStartPolledIO(0x%p, kIOPolledFlush, 0, 0, 0) returned 0x%x\n"
        }
        symbol = "IOPolledFileFlush"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "IOWorkLoop %p lock time %qd us @%s:%d"
            "IOWorkLoop.cpp"
            "IOWorkLoop %p lock time %qd us"
        }
        symbol = "__ZN10IOWorkLoop8lockTimeEv"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "IOCommandGate::disable() called when not gated"
        }
        symbol = "__ZN13IOCommandGate7disableEv"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "setTimeoutFunc already %p, %p @%s:%d"
            "IOTimerEventSource.cpp"
        }
        symbol = "__ZN18IOTimerEventSource14setTimeoutFuncEv"
        caller = "?"
    }
    new {
        args = 3
        anchors {
            "IOBMD: Unsupported use of guard pages with pageable memory.\n"
            "IOBMD: Unsupported use of guard pages with physical mask or contiguous memory.\n"
        }
        symbol = "__ZN24IOBufferMemoryDescriptor20initWithPhysicalMaskEP4taskjyyy"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "Attempting to free IOBMD with page allocated flag @%s:%d"
            "IOBufferMemoryDescriptor.cpp"
        }
        symbol = "__ZN24IOBufferMemoryDescriptor4freeEv"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "dmaCommandOperation @%s:%d"
            "dmaCommandOperation 0x%x @%s:%d"
        }
        symbol = "__ZN12IODMACommand7prepareEyybb"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "no remap page found @%s:%d"
        }
        symbol = "__ZN12IODMACommand15genIOVMSegmentsEjPFiPvPS_NS_9Segment64ES0_jES0_PyS0_Pj"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "iommu-id"
        }
        symbol = "__ZN8IOMapper5startEP9IOService"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "iommu-parent"
            "%s.DMA.%s"
        }
        symbol = "__ZN8IOMapper28copyMapperForDeviceWithIndexEP9IOServicej"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "mach_make_memory_entry_64 actualSize @%s:%d"
            "getKernelReserved @%s:%d"
            "phys is kIODefaultCache @%s:%d"
        }
        symbol = "__ZN25IOGeneralMemoryDescriptor21memoryReferenceCreateEjPP17IOMemoryReference"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "overrun @%s:%d"
            "map enter err %x @%s:%d"
        }
        symbol = "__ZN25IOGeneralMemoryDescriptor21memoryReferenceMapNewEP17IOMemoryReferenceP7_vm_mapyyjPy"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "bad dir for upl 0x%x @%s:%d"
            "short external upl @%s:%d"
        }
        symbol = "__ZN25IOGeneralMemoryDescriptor15initWithOptionsEPvjjP4taskjP8IOMapper"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "IOGMD: not wired for the IODMACommand @%s:%d"
            "!pageList phys_addr @%s:%d"
        }
        symbol = "__ZNK25IOGeneralMemoryDescriptor19dmaCommandOperationEjPvj"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "fMapped %p %s %qx @%s:%d"
        }
        symbol = "__ZNK18IOMemoryDescriptor19dmaCommandOperationEjPvj"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "IOMemoryDescriptor 0x%zx prepared read only"
            "memRefEntry @%s:%d"
            "entry size error %d\n"
        }
        symbol = "__ZN25IOGeneralMemoryDescriptor11wireVirtualEj"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "complete() while dma active @%s:%d"
        }
        symbol = "__ZN25IOGeneralMemoryDescriptor8completeEj"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "upl_transpose(%x)\n"
        }
        symbol = "__ZN25IOGeneralMemoryDescriptor5doMapEP7_vm_mapPyjyy"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "doUnmap @%s:%d"
        }
        symbol = "__ZN18IOMemoryDescriptor7doUnmapEP7_vm_mapyy"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "address"
        }
        symbol = "__ZNK25IOGeneralMemoryDescriptor9serializeEP11OSSerialize"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "_IOMemoryDescriptorMixedData"
        }
        symbol = "_GLOBAL__sub_I_IOMemoryDescriptor.cpp"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "IOPlatformInterruptController"
            "enforce_platform_action_safety"
        }
        symbol = "__ZN16IOPlatformExpert5startEP9IOService"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "top-level"
        }
        symbol = "__ZN16IOPlatformExpert9configureEP9IOService"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "pm%u %p %.30s %d %lx %lx\n"
        }
        symbol = "__ZN16IOPlatformExpert5PMLogEPKcmmm"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "device"
            "provider"
            "PMRegisterDevice/CheckSubTree - service registered!\n"
        }
        symbol = "__ZN16IOPlatformExpert12CheckSubTreeEP7OSArrayP9IOServiceS3_P12OSDictionary"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s IOClass is %s\n"
            "%s IOProviderClass is %s\n"
            "%s IONameMatch is %s\n"
            "%s IONameMatched is %s\n"
            "%s name is %s\n"
        }
        symbol = "__Z19printDictionaryKeysP12OSDictionaryPc"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "halt-restart-timeout"
        }
        symbol = "PEHaltRestartInternal"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "Class %s passed the %s action to IOPlatformExpert @%s:%d"
        }
        symbol = "__ZN16IOPlatformExpert20callPlatformFunctionEPK8OSSymbolbPvS3_S3_S3_"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "logical-cpu-id"
            "logical-cluster-id"
        }
        symbol = "__ZN18IODTPlatformExpert10createNubsEP9IOServiceP10OSIterator"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "AAPL,"
        }
        symbol = "__ZN18IODTPlatformExpert12getModelNameEPci"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "IOPlatformExpertDevice"
            "IOPanicPlatform"
        }
        symbol = "_GLOBAL__sub_I_IOPlatformExpert.cpp"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "chip-id"
        }
        symbol = "__ZN22IOPlatformExpertDevice20generatePlatformUUIDEv"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "(unknown platform name)"
            "Unable to find driver for this platform: \"%s\". @%s:%d"
        }
        symbol = "__ZN15IOPanicPlatform5startEP9IOService"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Halt/Restart Timed Out @%s:%d"
        }
        symbol = "__ZL31IOShutdownNotificationsTimedOutPvS_"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "IOPlatformIO"
        }
        symbol = "_GLOBAL__sub_I_IOPMGR.cpp_0"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "IOCPUNumber"
        }
        symbol = "__ZN5IOCPU12setCPUNumberEj"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "IOPlatformSleepAction"
            "IOPlatformWakeAction"
            "IOPlatformQuiesceAction"
            "IOPlatformActiveAction"
            "IOPlatformHaltRestartAction"
            "IOPlatformPanicAction"
        }
        symbol = "__Z27IOPlatformActionsInitializev"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s -> %s\n"
        }
        symbol = "__ZL23IOServicePlatformActionPvS_jS_S_S_PKcy"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "IODTNVRAMPlatformNotifier"
            "IODTNVRAMDiags"
            "IODTNVRAMVariables"
        }
        symbol = "_GLOBAL__sub_I_IONVRAM.cpp"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Stats"
        }
        symbol = "__ZN14IODTNVRAMDiags5startEP9IOService"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%02X:%s"
            "Write"
            "Delete"
        }
        symbol = "__ZN14IODTNVRAMDiags11logVariableE18NVRAMPartitionType16IONVRAMOperationPKcPv"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "nvram-bank-count"
            "nvram-current-bank"
        }
        symbol = "__ZN22IODTNVRAMFormatHandler18getNVRAMPropertiesEv"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "nvram-raw"
        }
        symbol = "__ZN16IONVRAMV3Handler18getNVRAMPropertiesEv"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Invalid _systemUsed size\n @%s:%d"
            "Invalid _commonUsed size\n @%s:%d"
        }
        symbol = "__ZN16IONVRAMV3Handler17setEntryForRemoveEP18nvram_v3_var_entryb"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Version"
            "options-system"
            "options-common"
        }
        symbol = "__ZN9IODTNVRAM5startEP9IOService"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "nvram-proxy-data"
            "NVRAM size is 0 bytes, possibly due to bad config with iBoot + xnu mismatch @%s:%d"
            "IONVRAMV3Handler creation failed\n @%s:%d"
            "IONVRAMCHRPHandler creation failed\n @%s:%d"
        }
        symbol = "__ZN9IODTNVRAM15initImageFormatEv"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "triggered"
            "completed with ret=%08x"
            "Generation"
        }
        symbol = "__ZN9IODTNVRAM12syncInternalEb"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "ObliterateNVRam"
            "ResetNVRam"
        }
        symbol = "__ZN9IODTNVRAM22handleSpecialVariablesEPKcPKhPK8OSObjectPi"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "IONVRAM-DELETE-PROPERTY"
            "IONVRAM-DELETEWRET-PROPERTY"
            "IONVRAM-FORCESYNCNOW-PROPERTY"
            "%s as bool to %d"
            "%s as number to %#llx"
            "%s as string to %s"
            "%s as data with size %#x"
        }
        symbol = "__ZN9IODTNVRAM26setPropertyWithGUIDAndNameEPKhPKcP8OSObject"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "IOClassNameOverride"
            "BSD Names"
        }
        symbol = "__ZL7skipKeyPK8OSSymbol"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "2nvram"
        }
        symbol = "__ZL26nvram_validate_header_v1v2PKhPji"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "com.apple.private.iokit.nvram-write-access"
            "com.apple.private.iokit.nvram-read-access"
            "com.apple.private.iokit.system-nvram-allow"
            "com.apple.private.iokit.system-nvram-internal-allow"
            "com.apple.private.iokit.system-nvram-hidden-allow"
        }
        symbol = "__ZL16verifyPermission16IONVRAMOperationPKhPKcb"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "IOExtensiblePaniclog"
        }
        symbol = "_GLOBAL__sub_I_IOUserClient.iig.cpp_7"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "EXT_PANICLOG IOKIT: Failed to create iobmd"
            "Extensible paniclog not supported"
        }
        symbol = "__ZN20IOExtensiblePaniclog11Create_ImplEP6OSDataP8OSStringjjPPS_"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "dma-parent"
            "dmaIndex out of range @%s:%d"
            "IODMAController.cpp"
        }
        symbol = "__ZN15IODMAController13getControllerEP9IOServicej"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "PassthruInterruptController"
        }
        symbol = "_GLOBAL__sub_I_PassthruInterruptController.cpp"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "handleInterrupt shouldn't be invoked directly @%s:%d"
            "PassthruInterruptController.cpp"
        }
        symbol = "__ZN27PassthruInterruptController15handleInterruptEPvP9IOServicei"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "IOMachPort"
            "iokit.IOMachPort"
            "IOUserIterator"
            "IOUserNotification"
            "IOServiceUserNotification"
            "IOServiceMessageUserNotification"
        }
        symbol = "_GLOBAL__sub_I_IOUserClient.cpp"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s(0x%qx)"
        }
        symbol = "iokit_port_object_description"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "ipcEnter @%s:%d"
        }
        symbol = "__ZN12IOUserClient18callExternalMethodEjP25IOExternalMethodArguments"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "ipcExit @%s:%d"
        }
        symbol = "__ZN12IOUserClient7ipcExitEi"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "virtual bool IOServiceUserNotification::handler(void *, IOService *)"
        }
        symbol = "__ZN25IOServiceUserNotification7handlerEPvP9IOService"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "virtual IOReturn IOServiceMessageUserNotification::handler(void *, UInt32, IOService *, void *, vm_size_t)"
        }
        symbol = "__ZN32IOServiceMessageUserNotification7handlerEPvjP9IOServiceS0_m"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "setAsyncReference not valid for 64b @%s:%d"
        }
        symbol = "__Z29transmuteEntitlementsInDaemonP7cs_blobPPKhPm.cold.1"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "consolesession"
            "secureprocess"
        }
        symbol = "__ZN12IOUserClient18clientHasPrivilegeEPvPKc"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "iokit_task_terminate phase %d @%s:%d"
            "destroying out of band connect for %s\n"
        }
        symbol = "iokit_task_terminate"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s: mach_msg_send_from_kernel(0x%x)\n"
            "static IOReturn IOUserClient::_sendAsyncResult64(io_user_reference_t *, IOReturn, io_user_reference_t *, UInt32, IOOptionBits)"
        }
        symbol = "__ZN12IOUserClient18_sendAsyncResult64EPyiS0_jj"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "IORegistryEntrySetProperties(%s, %s) disallowed due to IORegistryEntryAllowableSetProperties\n"
        }
        symbol = "__is_io_registry_entry_set_properties_block_invoke"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "com.apple.private.security.waitquiet-panics"
        }
        symbol = "is_io_service_wait_quiet_with_options"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "IOUserClientSharedInstance"
            "IOUserClientMessageAppSuspended"
            "IOUC %s requires kIOUserClientDefaultLockingKey, kIOUserClientDefaultLockingSetPropertiesKey, kIOUserClientDefaultLockingSingleThreadExternalMethodKey\n"
            "IOUC %s missing IOUserClientEntitlements property\n"
            "IOUC %s had IOUserClientEntitlementswith value not boolean false or string\n"
            "IOUC %s missing entitlement in process %s\n"
            "IOUC %s failed MACF in process %s\n"
            "IOUC %s failed sandbox in process %s\n"
        }
        symbol = "is_io_service_open_extended"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "ignored is_io_service_close(0x%qx,%s)\n"
        }
        symbol = "is_io_service_close"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "com.apple.private.security.iocatalog-management"
        }
        symbol = "is_io_catalog_send_data"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "wrong externalMethod for IOUserClient2022 @%s:%d"
        }
        symbol = "__ZN16IOUserClient202214externalMethodEjP25IOExternalMethodArgumentsP24IOExternalMethodDispatchP8OSObjectPv"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "Count %d\n"
            "Empty\n"
            ", busy %ld"
        }
        symbol = "IOPrintPlane"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Instance allocation"
            "Container allocation"
            "IOMalloc allocation"
            "Pageable allocation"
        }
        symbol = "__ZNK16IOKitDiagnostics9serializeEP11OSSerialize"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "IOKitDiagnosticsClient"
        }
        symbol = "_GLOBAL__sub_I_IOKitDebug.cpp"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: dataAvailableNotification failed - msg_send returned: %d\n"
        }
        symbol = "__ZN11IODataQueue29sendDataAvailableNotificationEv"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "IOStatistics::onKextUnload: cannot find kext: %s @%s:%d"
        }
        symbol = "__ZN12IOStatistics12onKextUnloadEP6OSKext"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "IOStatistics::onClassAdded: cannot find parent kext: %s @%s:%d"
        }
        symbol = "__ZN12IOStatistics12onClassAddedEP6OSKextP11OSMetaClass"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "IOStatistics::onClassRemoved: cannot find class: %s @%s:%d"
        }
        symbol = "__ZN12IOStatistics14onClassRemovedEP6OSKextP11OSMetaClass"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "IOStatistics::registerEventSource - bad metaclass %p\n"
            "IOStatistics::registerEventSource: cannot find parent class: %s @%s:%d"
        }
        symbol = "__ZN12IOStatistics19registerEventSourceEP8OSObject"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "IOStatistics::registerWorkLoop: cannot find parent kext @%s:%d"
        }
        symbol = "__ZN12IOStatistics16registerWorkLoopEP10IOWorkLoop"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "IOStatistics::registerUserClient: cannot find parent class: %s @%s:%d"
        }
        symbol = "__ZN12IOStatistics18registerUserClientEP12IOUserClient"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "interrupt_accounting"
        }
        symbol = "__Z23interruptAccountingInitv"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "virtual IOReturn IOReporter::handleSwapPrepare(int)"
            "%s doesn't support shrinking @%s:%d"
            "IOReporter::_swap* already in use @%s:%d"
        }
        symbol = "__ZN10IOReporter17handleSwapPrepareEi"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s - can't free %d channels of dimension %d @%s:%d"
            "virtual void IOReporter::handleSwapCleanup(int)"
        }
        symbol = "__ZN10IOReporter17handleSwapCleanupEi"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "virtual IOReturn IOReporter::setElementValues(int, IOReportElementValues *, uint64_t)"
        }
        symbol = "__ZN10IOReporter16setElementValuesEiP21IOReportElementValuesy"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "virtual const IOReportElementValues *IOReporter::getElementValues(int)"
        }
        symbol = "__ZN10IOReporter16getElementValuesEi"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "IOReturn IOReporter::updateReportChannel(int, int *, IOBufferMemoryDescriptor *)"
            "updateReportChannel"
            "chElems"
        }
        symbol = "__ZN10IOReporter19updateReportChannelEiPiP24IOBufferMemoryDescriptor"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "virtual IOReturn IOReporter::copyElementValues(int, IOReportElementValues *)"
        }
        symbol = "__ZN10IOReporter17copyElementValuesEiP21IOReportElementValues"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "IOReportChannelUnit"
            "IOReportChannels"
        }
        symbol = "__ZN10IOReporter10legendWithEP7OSArrayS1_19IOReportChannelTypey"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "virtual IOReturn IOStateReporter::handleSwapPrepare(int)"
            "IOStateReporter::_swap* already in use @%s:%d"
        }
        symbol = "__ZN15IOStateReporter17handleSwapPrepareEi"
        caller = "?"
    }
    new {
        args = 3
        anchors {
            "IOStateReporter::handleAddChannelSwap _lastUpdateTimes unset despite non-NULL _currentStates @%s:%d"
        }
        symbol = "__ZN15IOStateReporter20handleAddChannelSwapEyPK8OSSymbol"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "virtual void IOStateReporter::handleSwapCleanup(int)"
        }
        symbol = "__ZN15IOStateReporter17handleSwapCleanupEi"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "overrideChannelState() cannot be used after setChannelState()! @%s:%d"
        }
        symbol = "__ZN15IOStateReporter20overrideChannelStateEyyyyy"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "incrementChannelState() cannot be used after setChannelState()! @%s:%d"
        }
        symbol = "__ZN15IOStateReporter21incrementChannelStateEyyyyy"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "virtual IOReturn IOStateReporter::handleSetStateID(uint64_t, int, uint64_t)"
        }
        symbol = "__ZN15IOStateReporter16handleSetStateIDEyiy"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "virtual IOReturn IOStateReporter::handleSetStateByIndices(int, int, uint64_t, uint64_t)"
        }
        symbol = "__ZN15IOStateReporter23handleSetStateByIndicesEiiyy"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "virtual IOReturn IOStateReporter::updateChannelValues(int)"
        }
        symbol = "__ZN15IOStateReporter19updateChannelValuesEi"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "IOReportGroupName"
            "IOReportSubGroupName"
        }
        symbol = "__ZN14IOReportLegend14organizeLegendEP12OSDictionaryPK8OSSymbolS4_"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "OSUserMetaClass"
            "IOUserService"
            "IOUserServerCheckInToken"
            "_IOUserServerCheckInCancellationHandler"
            "IOServiceStateNotificationEventSource"
            "IOSystemStateNotification"
            "IOStateNotificationItem"
            "IOStateNotificationListener"
        }
        symbol = "_GLOBAL__sub_I_IOUserServer.cpp"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "DK: %s-0x%qx::SetDispatchQueue(%s)\n"
        }
        symbol = "__ZN9IOService21SetDispatchQueue_ImplEPKcP15IODispatchQueue"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "com.apple.private.driverkit.allows-publish"
            "DK: %s-0x%qx: publisher entitlements check failed\n"
            "IODriverKitPublishEntitlementsKey"
            "DK: %s-0x%qx: subscriber entitlements check failed\n"
        }
        symbol = "___ZN35IOServiceNotificationDispatchSource11Create_ImplEP12OSDictionaryyP15IODispatchQueuePPS__block_invoke"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "DK: %s-0x%qx::Create(%s-0x%qx) %p\n"
            "DK: %s-0x%qx::Create(%s-0x%qx): could not find OSKext for %s\n"
            "IOUserServer(%s-0x%qx)"
            "%s: found the task loadTag already set to %u (set to %u)\n"
        }
        symbol = "__ZN12IOUserServer11Create_ImplEPKcyyP8OSStringPPS_"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "DK: IODispatchQueue::Create %s %p\n"
        }
        symbol = "__ZN15IODispatchQueue11Create_ImplEPKcyyPPS_"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "DK: OSMetaClassBase::Invoke user 0x%x\n"
            "DK: OSMetaClassBase::Invoke kernel %s 0x%qx\n"
        }
        symbol = "__ZN15OSMetaClassBase6InvokeE5IORPC"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: proc not found\n"
            "%s: uuid not matching\n"
        }
        symbol = "__ZN12IOUserServer16setDriverKitUUIDEP6OSKext"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s: failed to set check in token. token=%p, fCheckInToken=%p\n"
            "setCheckInToken"
        }
        symbol = "__ZN12IOUserServer19externalMethodStartEP8OSObjectPvP25IOExternalMethodArguments"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: null check in token\n"
            "serviceMatchesCheckInToken"
        }
        symbol = "__ZN12IOUserServer26serviceMatchesCheckInTokenEP24IOUserServerCheckInToken"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "DK: %s-0x%qx: provider entitlements check failed\n"
            "DK: %s-0x%qx: family entitlements check failed\n"
        }
        symbol = "__ZN12IOUserServer17checkEntitlementsEP9IOServiceS1_"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "DK: %s::exit(%s)\n"
        }
        symbol = "__ZN12IOUserServer4exitEPKc"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "DK: %s::kill(%s)\n"
        }
        symbol = "__ZN12IOUserServer4killEPKc"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "DK: %s-0x%qx::instantiate inactive\n"
            "DK: no IOUserClass defined for %s-0x%qx\n"
            "DK: userMeta %s %p\n"
            "DK: userMeta %s was not found in fClasses\n"
            "DK: instantiate object %s with user class %s\n"
            "DK: %s: no user class found\n"
        }
        symbol = "__ZN12IOUserServer17objectInstantiateEP8OSObject5IORPCP12IORPCMessage"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "DK:  fClasses[\"%s\"] => %p\n"
        }
        symbol = "___ZN12IOUserServer17objectInstantiateEP8OSObject5IORPCP12IORPCMessage_block_invoke"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "DK: %s: instantiate failed 0x%x\n"
            "DK: %s::Dispatch kernel 0x%qx\n"
            "DK: %s::Dispatch kernel 0x%qx result 0x%x\n"
        }
        symbol = "__ZN12IOUserServer14kernelDispatchEP8OSObject5IORPC"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "DK: TARGET %s msg 0x%qx from 0x%qx\n"
        }
        symbol = "__ZN12IOUserServer6targetEP8OSActionP12IORPCMessage"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "DK: UEXT notify %o\n"
            "DK: UEXT copyin(0x%x) %x\n"
        }
        symbol = "__ZN12IOUserServer6serverEP8ipc_kmsgP12IORPCMessagePS1_"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "DK: invalid refs count %qd in message id 0x%qx\n"
            "DK: %s::Dispatch(trap) kernel 0x%qx 0x%x\n"
        }
        symbol = "IOUserServerUEXTTrap"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "DK: mach_msg() failed 0x%x\n"
            "DK: rpc copyin(0x%x) %x\n"
        }
        symbol = "__ZN12IOUserServer3rpcE5IORPC"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "DK: %s::finalize(%p)\n"
            "DK: %s::finalize(%p) dext was replaced, do not rematch current dext\n"
            "DK: %s::finalize(%p) could not find fCheckInToken\n"
        }
        symbol = "__ZN12IOUserServer8finalizeEj"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "DK: %s::terminate(%s-0x%qx)\n"
            "DK: %s::terminate(%s-0x%qx) server exit before start()\n"
        }
        symbol = "___ZN12IOUserServer8finalizeEj_block_invoke"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "DK: IOUserServer may only be created with driver tasks\n"
            "DK: entitlements are missing for %s[%d]\n"
            "DK: %s[%d] has team identifier %s\n"
            "com.apple.developer.driverkit entitlement check failed for %s[%d]\n"
        }
        symbol = "__ZN12IOUserServer8withTaskEP4task"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "DK: %s::clientClose(%p)\n"
            "Driver %s has crashed too many times\n @%s:%d"
        }
        symbol = "__ZN12IOUserServer11clientCloseEv"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "DK: %s-0x%qx::ClientCrashed(%s-0x%qx)\n"
        }
        symbol = "___ZN12IOUserServer11clientCloseEv_block_invoke"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "DK: %s::registerClass %s, %d, %d\n"
        }
        symbol = "__ZN12IOUserServer13registerClassEP18OSClassDescriptionjPP15OSUserMetaClass"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "DK: %s::LoadModule 0x%x %s\n"
        }
        symbol = "__ZN12IOUserServer13serviceAttachEP9IOServiceS1_"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "com.apple.developer.driverkit.administrator"
            "DK: %s-0x%qx:UC failed required entitlement check\n"
            "DK: %s-0x%qx:UC failed userclient-access check, needed bundle ID %s\n"
            "DK: %s-0x%qx:UC entitlements check failed\n"
        }
        symbol = "__ZN12IOUserServer20serviceNewUserClientEP9IOServiceP4taskPvjP12OSDictionaryPP12IOUserClient"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "non-removable"
        }
        symbol = "__ZN12IOUserServer17serviceJoinPMTreeEP9IOService"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "DK: %s-0x%qx::setPowerState(%ld) %d\n"
        }
        symbol = "__ZN12IOUserServer13setPowerStateEmP9IOService"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "DK: %s-0x%qx::serviceSetPowerState(%ld) %d\n"
        }
        symbol = "__ZN12IOUserServer20serviceSetPowerStateEP9IOServiceS1_mm"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "DK: %s-0x%qx::powerStateDidChangeTo(%ld) %d, %d\n"
        }
        symbol = "__ZN12IOUserServer21powerStateDidChangeToEmmP9IOService"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "DK: %s-0x%qx::SetPowerState(%d), %d\n"
        }
        symbol = "__ZN9IOService18SetPowerState_ImplEj"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "DK: %s::powerOff(%d) %d\n"
        }
        symbol = "__ZN12IOUserServer11systemPowerEbb"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "DK: changePowerStateWithOverrideTo(%s-0x%qx, %d)\n"
        }
        symbol = "___ZN12IOUserServer11systemPowerEb_block_invoke.164"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "DK: %schangePowerStateWithOverrideTo(%s-0x%qx, %d)\n"
        }
        symbol = "___ZN12IOUserServer11systemPowerEb_block_invoke_2"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "DK: %s::systemHalt()\n"
        }
        symbol = "__ZN12IOUserServer10systemHaltEi"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "DK: stale service %s-0x%qx found, skipping termination\n"
            "DK: %d: terminate(%s-0x%qx)\n"
        }
        symbol = "___ZN12IOUserServer10systemHaltEi_block_invoke"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "DK: %s-0x%qx::start(%s-0x%qx) %s\n"
        }
        symbol = "__ZN12IOUserServer14serviceStartedEP9IOServiceS1_b"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "DK: %s-0x%qx- %s-0x%qx blocked attempt to open %s-0x%qx\n"
        }
        symbol = "__ZN12IOUserServer11serviceOpenEP9IOServiceS1_"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "DK: %s-0x%qx:force close (%s-0x%qx)\n"
        }
        symbol = "___ZN12IOUserServer14serviceDidStopEP9IOServiceS1__block_invoke"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "DK: %s-0x%qx %s SetEventlinkPort() returned %x\n"
        }
        symbol = "__ZN16IOUserUserClient26eventlinkConfigurationTrapEPvS0_S0_S0_S0_S0_"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "DK: %s-0x%qx %s SetWorkGroupPort() returned %x\n"
        }
        symbol = "__ZN16IOUserUserClient26workgroupConfigurationTrapEPvS0_S0_S0_S0_S0_"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "Driver %s has crashed %zu time(s)\n"
            "DK: Could not find OSKext for %s\n"
            "IOUserServerName \"%s\" not correct organization for bundleID \"%s\"\n"
            "Could not initialize token\n"
        }
        symbol = "__ZN12IOUserServer16launchUserServerEP8OSStringPK8OSSymbolP8OSNumberbPP24IOUserServerCheckInTokenP6OSData"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "com.apple.iokit.pm.sleepdescription"
            "com.apple.iokit.pm.hibernatestate"
            "com.apple.iokit.pm.sleepreason"
            "com.apple.iokit.pm.wakedescription"
            "com.apple.iokit.pm.wakereason"
            "com.apple.iokit.pm.wakedescription.continuous-time-offset"
            "com.apple.iokit.pm.haltdescription"
            "com.apple.iokit.pm.haltstate"
            "com.apple.iokit.pm.powersourcedescription"
            "com.apple.iokit.pm.acattached"
        }
        symbol = "__ZN25IOSystemStateNotification10initializeEv"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "com.apple.private.iokit.systemstate"
            "com.apple.iokit.statenotification.create"
            "com.apple.iokit.statenotification.set"
        }
        symbol = "__ZN25IOSystemStateNotification13setPropertiesEP8OSObject"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "DK: Attempted to create action object with type \"%s\" which does not inherit from OSAction\n"
        }
        symbol = "__ZL34OSActionCreateWithTypeNameInternalP8OSObjectyymP8OSStringbPP8OSAction"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "obsolete message"
        }
        symbol = "__ZL25IORPCMessageFromMachReplyP16IORPCMessageMach"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "IOInterfaceNamePrefix"
            "network-type"
            "IONetworkRootType"
        }
        symbol = "IONetworkNamePrefixMatching"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "apfs-preboot-uuid"
        }
        symbol = "IOGetBootUUID_0"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "associated-volume-group"
        }
        symbol = "IOGetBootUUID_1"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "boot-objects-path"
        }
        symbol = "IOGetBootObjectsPath"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "boot-manifest-hash"
        }
        symbol = "IOGetBootManifestHash"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "ssv-seal-broken"
            "40A0DDD2-77F8-4392-B4A3-1E7304206516:recovery-broken-seal-uuid"
            "Failed to write recovery-broken-seal-uuid to NVRAM.\n"
            "40A0DDD2-77F8-4392-B4A3-1E7304206516:recovery-boot-mode"
            "Failed to write recovery-boot-mode to NVRAM.\n"
            "missing-boot-media"
            "40A0DDD2-77F8-4392-B4A3-1E7304206516:boot-picker-bringup-reason"
            "Failed to write boot-picker-bringup-reason to NVRAM.\n"
            "40A0DDD2-77F8-4392-B4A3-1E7304206516:boot-command"
            "recover-system"
            "Failed to acquire IODTNVRAM object.\n"
            "Failed to wait for IONVRAM service.\n"
            "Failed to save new boot-command to NVRAM.\n"
            "Unknown mode: %d\n"
            "\nAbout to reboot into Recovery!\n"
        }
        symbol = "IOSetRecoveryBoot"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "!BSD\n"
            "mount(%d) failed\n"
            "rootdev"
            "root-matching"
            "rooting via boot-uuid from /chosen: %s\n"
            "RAMDisk"
            "ramdisk params @%s:%d"
            "BSD root: %s, major %d, minor %d\n"
            "Unable to retrieve range for root memory device %d\n"
            "IOFindBSDRoot: specified root memory device, %s, has not been configured @%s:%d"
            "rd=uuid but no boot-uuid=<value> specified @%s:%d"
            "\nWaiting for boot volume with UUID %s\n"
            "Apple_HFS"
            "Content"
            "Waiting for matching to complete\n"
            "Waiting on %s\n"
            "Got boot device = %s\n"
            "Wait for root failed\n"
            ", major %d, minor %d\n"
            "IONetworkStack"
            "IOInterfaceUnit"
        }
        symbol = "IOFindBSDRoot"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "SecureRootName"
        }
        symbol = "IOSecureBSDRoot"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Failed to open the corefile. Error %d\n"
        }
        symbol = "IOProvideCoreFileAccess"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "kernel-core-dump-location"
            "/private/preboot/kernelcore"
            "corefile path selection in device-tree is not one of the allowed values: %s, Using default %s\n"
            "corefile path selection in device-tree was set to: %s (value: %s)\n"
        }
        symbol = "__ZL21IOResolveCoreFilePathv"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Failed to open corefile of size %llu MB (low disk space)\n"
            "IOPolledFilePollersSetup for corefile failed with error: 0x%x\n"
            "Opened corefile of size %llu MB\n"
            "corefile_size_mb"
            "Boot-args specify %d MB kernel corefile\n"
            "Volume is low on space. Not allocating kernel corefile.\n"
            "Couldn\\'t retrieve volume status. Error %d\n"
        }
        symbol = "__ZL20IOOpenPolledCoreFilePvS_"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Failed to %s the corefile. Error %d\n"
            "write to"
            "read from"
        }
        symbol = "__ZL20IOAccessCoreFileDataPviyiS_"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "di-root-image"
            "IOHDIXController::setProperty(%s, %s) failed.\n"
            "failed to quiesce attached disk image (%s)! \n"
            "di-root-removable"
            "IOHDIXController::setProperty(%s, %d) failed.\n"
        }
        symbol = "di_root_image_ext"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "boot-ramdmg-size"
            "boot-ramdmg-extents"
        }
        symbol = "di_root_ramfile"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "com.apple.AppleDiskImageController.load"
            "IOHDIXController"
        }
        symbol = "__ZL18di_load_controllerv"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "IOUserClientCrossEndianCompatible"
        }
        symbol = "__ZN20RootDomainUserClient12initWithTaskEP4taskPvjP12OSDictionary"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "SleepRequestedByPID"
            "IOPMRootDomain SleepSystem unserialization failure: %s\n"
        }
        symbol = "__ZN20RootDomainUserClient24secureSleepSystemOptionsEPKvyPj"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "UserActivity Assertion"
        }
        symbol = "__ZN20RootDomainUserClient24externalMethodDispatchedEP8OSObjectPvP25IOExternalMethodArguments"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "could not create IOPerfControlClient @%s:%d"
        }
        symbol = "__ZN19IOPerfControlClient10copyClientEP9IOServicey"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "driverState has already been initialized @%s:%d"
        }
        symbol = "__ZN19IOPerfControlClient14registerDeviceEP9IOServiceS1_"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "IOPerfControlWorkContext"
        }
        symbol = "_GLOBAL__sub_I_IOPerfControl.cpp"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "WorkloadIDTable"
            "WorkloadIDConfigurationFlags"
        }
        symbol = "IOParseWorkloadConfig"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "WorkloadClass"
            "CriticalityOffset"
            "WorkIntervalType"
        }
        symbol = "___ZL11parsePhasesP19workload_config_ctxRK8OSSymbolP8OSObject_block_invoke"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "ComplexityAllowed"
        }
        symbol = "___ZL10parseFlagsRK8OSSymbolPK8OSObjectRjS5__block_invoke"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "DefaultPhase"
            "Phases"
        }
        symbol = "___ZL20parseWorkloadIDTableP19workload_config_ctxP12OSDictionary_block_invoke"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "DisableWorkloadClassThreadPolicy"
        }
        symbol = "___ZL33parseWorkloadIDConfigurationFlagsP19workload_config_ctxPK8OSObject_block_invoke"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "IOSKRegionMapper"
            "IOSKMapper"
            "IOSKArena"
            "IOSKRegion"
            "IOSKMemoryArray"
            "IOSKMemoryBuffer"
            "iokit.IOSKMemoryBuffer"
        }
        symbol = "_GLOBAL__sub_I_IOSkywalkSupport.cpp"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "IOUnifiedAddressTranslator"
        }
        symbol = "_GLOBAL__sub_I_IOUnifiedAddressTranslator.cpp"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "IOUnifiedAddressTranslator init failed\n"
        }
        symbol = "__ZN26IOUnifiedAddressTranslator22registerTaskForServiceEP4taskP9IOService"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "IOUAT ERROR: Failed to retrieve '%s' DT prop @%s:%d"
            "IOUAT ERROR: Bad '%s' DT prop size (expected %zu bytes, got %u) @%s:%d"
        }
        symbol = "__ZN26IOUnifiedAddressTranslator13getDTPropertyEPKcm"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "IOUAT %s:%d: *** Attempting to map %s\n\n"
            "IOUAT ERROR: Expected %s base address to be page-aligned but got %#llx @%s:%d"
            "IOUAT ERROR: Expected %s size to be a non-zero multiple of the page size but got %#zx bytes @%s:%d"
            "IOUAT ERROR: Failed to allocate IOMemoryDescriptor for %s @%s:%d"
            "IOUAT ERROR: Failed to allocate IOMemoryMap for %s @%s:%d"
            "IOUAT ERROR: Failed to prepare %s descriptor @%s:%d"
            "IOUAT %s:%d: *** Successfully mapped %s at (VA=%#lx, PA=%#llx)\n\n"
        }
        symbol = "__ZN26IOUnifiedAddressTranslator29mapHardwareResourceDTInternalEPKcS1_m"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "ASC carveout region"
            "gfx-shared-region-base"
            "gfx-shared-region-size"
            "TTBR1 shared L2 table"
            "gfx-shared-l2-region-base"
            "TTBAT"
            "gpu-region-base"
            "GPU handoff region"
            "gfx-handoff-base"
            "IOUAT %s:%d: *** IOUnifiedAddressTranslator entry\n"
            "IOUAT ERROR: Failed to allocate unmap list lock\n"
            "IOUAT ERROR: Failed to allocate the TTBR0 lock\n"
            "IOUAT ERROR: Failed to allocate release thread lock\n"
            "IOUAT ERROR: Failed to allocate release array\n"
            "iouat_debug"
            "IOUAT WARN: Not using restricted aperture as VM range extension not sufficient\n"
            "IOUAT ERROR: Failed to allocate the TTBR1 lock\n"
            "IOUAT"
            "IOUAT ERROR: failed to initialize PPL state object\n"
            "fCodeRangeAllocator @%s:%d"
            "IOUAT %s:%d: *** IOUnifiedAddressTranslator success\n"
        }
        symbol = "__ZN26IOUnifiedAddressTranslator4initEP4taskP9IOService"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "IOUAT %s:%d: *** setClientContextID entry: %u\n\n"
            "setClientContextID"
            "IOUAT: failed to call PPL ioctl UAT_PPL_IOCTL_SET_CONTEXT_ID @%s:%d"
        }
        symbol = "__ZN26IOUnifiedAddressTranslator18setClientContextIDEjb"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "IOUAT %s:%d: *** removeClientContextID entry: %u\n\n"
            "removeClientContextID"
            "IOUAT: failed to call PPL ioctl UAT_PPL_IOCTL_REMOVE_CONTEXT_ID @%s:%d"
        }
        symbol = "__ZN26IOUnifiedAddressTranslator21removeClientContextIDEv"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "IOUAT %s:%d: *** taskDied, context ID: %u\n"
            "IOUAT %s:%d: *** taskDied, no context ID assigned\n"
            "IOUAT: failed to free all page tables on task death for ID %u @%s:%d"
        }
        symbol = "__ZN26IOUnifiedAddressTranslator8taskDiedEv"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "IOUAT %s:%d: *** map virt: %010llX length: 0x%llX options: 0x%llX contextID: %u\n"
            "doMap"
            "backingDescriptor != nullptr @%s:%d"
            "isAligned(size, (uint32_t)PAGE_SIZE)failed: %llu/%u @%s:%d"
            "isAligned(virtAddr, (uint32_t)PAGE_SIZE)failed: 0x%llX/%u @%s:%d"
            "IOUAT: PPL map operation failed virt: %010llX length: 0x%llX options: 0x%llX contextID: %u @%s:%d"
        }
        symbol = "__ZN26IOUnifiedAddressTranslator5doMapEP18IOMemoryDescriptoryyj"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "IOUAT %s:%d: *** unmap virt: %010llX length: 0x%llX contextID: %u\n"
            "IOUAT %s:%d: *** reached doUnmap exit\n"
        }
        symbol = "__ZN26IOUnifiedAddressTranslator7doUnmapEP18IOMemoryDescriptoryy"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "IOUAT %s:%d: *** prepareFWUnmap entry virt:%010llX length: 0x%llX contextID: %u\n"
            "prepareFWUnmap"
            "IOUAT: failed to call PPL ioctl UAT_PPL_IOCTL_PREPARE_UNMAP @%s:%d"
        }
        symbol = "__ZN26IOUnifiedAddressTranslator14prepareFWUnmapEyy"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "IOUAT %s:%d: *** reached createMappingInAperture()\n"
            "createMappingInAperture"
        }
        symbol = "__ZN26IOUnifiedAddressTranslator23createMappingInApertureEjP18IOMemoryDescriptorjym"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "IOUAT %s:%d: *** reached queueUnmap()\n"
            "fUnmapListCount < IOUAT_UNMAP_LIST_MAX_SIZE @%s:%d"
            "IOUAT %s:%d: *** exit queueUnmap()\n"
        }
        symbol = "__ZN26IOUnifiedAddressTranslator10queueUnmapEP18IOMemoryDescriptoryy"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "IOUAT %s:%d: *** Reached commitUnmaps()\n"
            "IOUAT %s:%d: *** exit commitUnmaps()\n"
        }
        symbol = "__ZN26IOUnifiedAddressTranslator12commitUnmapsEv"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "IOUAT %s:%d: *** getTotalPageTableMemory entry\n\n"
            "getTotalPageTableMemory"
            "IOUAT: failed to call PPL ioctl UAT_PPL_IOCTL_TOTAL_PT_MEM @%s:%d"
        }
        symbol = "__ZN26IOUnifiedAddressTranslator23getTotalPageTableMemoryEv"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "IOUAT %s:%d: *** isPageFaultExpected entry 0x%llx %u\n\n"
            "isPageFaultExpected"
            "IOUAT: failed to call PPL ioctl UAT_PPL_IOCTL_FAULT_EXPECTED @%s:%d"
        }
        symbol = "__ZN26IOUnifiedAddressTranslator19isPageFaultExpectedEyj"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "IOUAT %s:%d: *** getPageTablePhysicalBaseAddress entry %u\n\n"
            "getPageTablePhysicalBaseAddress"
            "ttbrIdx < 2 @%s:%d"
        }
        symbol = "__ZN26IOUnifiedAddressTranslator31getPageTablePhysicalBaseAddressEj"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "IOUAT %s:%d: *** getPageTableEntry entry 0x%llx\n\n"
            "getPageTableEntry"
            "IOUAT: failed to call PPL ioctl UAT_PPL_IOCTL_GET_PT_ENTRY @%s:%d"
        }
        symbol = "__ZN26IOUnifiedAddressTranslator17getPageTableEntryEy"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "IOUAT %s:%d: *** mapToPhysicalAddress entry 0x%llx\n\n"
            "mapToPhysicalAddress"
        }
        symbol = "__ZN26IOUnifiedAddressTranslator20mapToPhysicalAddressEy"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "SEPHibernator"
            "SEPHibernatorService"
        }
        symbol = "_GLOBAL__sub_I_SEPHibernator.cpp"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "HibernationService"
            "Couldn\\'t allocate service dict @%s:%d"
            "Wrong type for IOService @%s:%d"
        }
        symbol = "__ZN13SEPHibernator13sepHibernatorEv"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "kPMGeneralAggressiveness"
            "kPMMinutesToDim"
            "kPMMinutesToSpinDown"
            "kPMMinutesToSleep"
            "kPMEthernetWakeOnLANSettings"
            "kPMSetProcessorSpeed"
            "kPMPowerSource"
            "kPMMotionSensor"
            "kPMLastAggressivenessType"
            "PMRD: setAggressiveness(%x) %s = %u\n"
        }
        symbol = "__ZN14IOPMrootDomain17setAggressivenessEmmj"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "kPMCPUAssertion"
            "kPMPCIUnsupported"
            "kPMDKNotReady"
        }
        symbol = "__ZN14IOPMrootDomain23checkSystemSleepAllowedEjj"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "OSValueObject<PMAssertStruct>"
        }
        symbol = "_GLOBAL__sub_I_OSCollection.cpp_8"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "PMAssertionsTracker"
            "PMHaltWorker"
            "IOPMServiceInterestNotifier"
            "PMTraceWorker"
            "PMSettingHandle"
            "PMSettingObject"
        }
        symbol = "_GLOBAL__sub_I_IOPMrootDomain.cpp"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: %qd ms @ 0x%lx, "
        }
        symbol = "halt_log_enter"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "waitQuiet() for unmount %qd ms\n"
            "IOServicePH::systemHalt took %qd ms\n"
            "IOPMRootDomainWillShutdown"
            "IOHibernateSystemPostWake"
        }
        symbol = "IOSystemShutdownNotification"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "WakeByCalendarDate"
            "PowerByCalendarDate"
            "poweron"
            "WakeRelativeToSleep"
            "PowerRelativeToShutdown"
            "MaintenanceWakeCalendarDate"
            "SleepServiceWakeCalendarKey"
            "SilentRunning"
            "IOPMUserTriggeredFullWake"
            "IOPMUserIsActive"
            "LowLatencyAudioMode"
            "ResponseTimedOut"
            "ResponseCancel"
            "ResponseSlow"
            "ResponsePrompt"
            "DriverPSChangeSlow"
            "IOPMSetSleepSupported"
            "IOPMSystemSleepMessage"
            "Sleep On Power Button"
            "Wake On Modem Ring"
            "Wake On Clamshell Open"
            "Wake On AC Change"
            "TimeZoneOffsetSeconds"
            "Display Sleep Uses Dim"
            "MobileMotionModule"
            "GPUSwitch"
            "ConsoleShutdown"
            "swd_sleeptimeout"
            "swd_waketimeout"
            "haltmspanic"
            "haltmslog"
            "no-idle"
            "PMRD: Setting gNoIdleFlag to %u from device tree\n"
            "IOSleepSupported"
            "TimeMS"
            "ResponseType"
            "MessageType"
            "PowerCaps"
            "LowLatencyAudioNotifyState"
            "LowLatencyAudioNotifyTimestamp"
            "DisplayDims"
            "Hibernation"
            "BootSessionUUID"
        }
        symbol = "__ZN14IOPMrootDomain5startEP9IOService"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "com.apple.private.iokit.rootdomain-set-property"
            "privileged"
            "entitled"
            "PMRD: %s failed, process %s is not %s\n"
            "SoftwareSimulatedBatteries"
            "System Boot Complete"
            "System Shutdown"
            "StallSystemAtHalt"
            "BatteryWarningsDisabled"
            "System Idle Seconds"
            "System Idle Milliseconds"
            "SleepDisabled"
            "LoginWindowProgress"
            "CoreDisplayProgress"
            "CoreGraphicsProgress"
            "DestroyFVKeyOnStandby"
            "UserWakeAlarmScheduled"
            "PMRD: _userScheduledAlarmMask 0x%x\n"
            "PMRD: setProperties(%s) not handled\n"
        }
        symbol = "__ZN14IOPMrootDomain13setPropertiesEP8OSObject"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "PMRD: getAggressiveness type 0x%x not found\n"
        }
        symbol = "__ZN14IOPMrootDomain17getAggressivenessEmPm"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "PMRD: disk spindown accelerated, was %u min\n"
            "PMRD: disk spindown restored to %u min\n"
            "PMRD: disk spindown accelerated\n"
            "bad aggressives request type %x @%s:%d"
        }
        symbol = "__ZN14IOPMrootDomain25handleAggressivesRequestsEv"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "PMRD: idle timer not set (noidle=%d)\n"
            "PMRD: startIdleSleepTimer increasing timeout from %u to %u\n"
            "PMRD: idle timer set for %u milliseconds\n"
        }
        symbol = "__ZN14IOPMrootDomain19startIdleSleepTimerEj"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "PMRD: idle timer cancelled\n"
            "PMRD: Updated assertOnWake %lu\n"
        }
        symbol = "__ZN14IOPMrootDomain20cancelIdleSleepTimerEv"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "PMRD: sleep timer expired\n"
        }
        symbol = "__ZN14IOPMrootDomain26handleSleepTimerExpirationEv"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "PMRD: ignoring lastActivityTime 0x%qx, now 0x%qx, wake 0x%qx\n"
            "PMRD: user inactive %u min, time to idle sleep %u min\n"
        }
        symbol = "__ZN14IOPMrootDomain18getTimeToIdleSleepEv"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "OSSwitch"
            "Sleep Reason"
        }
        symbol = "__ZN14IOPMrootDomain18sleepSystemOptionsEP12OSDictionary"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "PMRD: Added %s to idle sleep preventers list (Total %u)\n"
            "PMRD: Removed %s from idle sleep preventers list (Total %u)\n"
            "PMRD: Cannot cancel idle sleep\n"
            "PMRD: %s\n"
        }
        symbol = "__ZN14IOPMrootDomain34updatePreventIdleSleepListInternalEP9IOServicebj"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "PMRD: Added %s to system sleep preventers list (Total %u)\n"
            "PMRD: Removed %s from system sleep preventers list (Total %u)\n"
        }
        symbol = "__ZN14IOPMrootDomain28updatePreventSystemSleepListEP9IOServiceb"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "PMRD: tellChangeDown %s->%s\n"
            "PMRD: tellChangeDown::userActivityAtSleep %d\n"
        }
        symbol = "__ZN14IOPMrootDomain14tellChangeDownEm"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "PMRD: askChangeDown %s->%s\n"
        }
        symbol = "__ZN14IOPMrootDomain13askChangeDownEm"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "PMRD: askChangeDownDone(0x%x, %u) type %x, cap %x->%x\n"
            "PMRD: cancel dark->sleep\n"
            "AOT wake window cancel: %qd, %qd\n"
        }
        symbol = "__ZN14IOPMrootDomain17askChangeDownDoneEPjPb"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "PMRD: MESG cap %x->%x did change\n"
        }
        symbol = "__ZN14IOPMrootDomain17systemDidNotSleepEv"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "PMRD: tellNoChangeDown %s->%s\n"
        }
        symbol = "__ZN14IOPMrootDomain16tellNoChangeDownEm"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "PMRD: tellChangeUp %s->%s\n"
        }
        symbol = "__ZN14IOPMrootDomain12tellChangeUpEm"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "PMRD: sysPowerDownHandler message %s\n"
            "PMRD: sysPowerDownHandler cap %x -> %x (flags %x)\n"
            "PMRD: sysPowerDownHandler max wait %d s\n"
        }
        symbol = "__ZN14IOPMrootDomain19sysPowerDownHandlerEPvS0_jP9IOServiceS0_m"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "PMRD: SleepWake UUID queued: %s\n"
        }
        symbol = "__ZN14IOPMrootDomain24handleQueueSleepWakeUUIDEP8OSObject"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "PMRD: SleepWake UUID cleared\n"
        }
        symbol = "__ZN14IOPMrootDomain26handlePublishSleepWakeUUIDEb"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "PMRD: Reverting sleep with relative wake\n"
            "Reverting sleep with relative wake\n"
        }
        symbol = "__ZN14IOPMrootDomain26scheduleImmediateDebugWakeEv"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "aotlinger"
        }
        symbol = "__ZN14IOPMrootDomain23willNotifyPowerChildrenEm"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "PMRD: dark wake promotion disabled at %u ms\n"
        }
        symbol = "__ZN14IOPMrootDomain33willTellSystemCapabilityDidChangeEv"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "AppleClamshellState"
            "AppleClamshellCausesSleep"
        }
        symbol = "__ZN14IOPMrootDomain31sendClientClamshellNotificationEv"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "PMRD: setSleepSupported(%x)\n"
        }
        symbol = "__ZN14IOPMrootDomain17setSleepSupportedEj"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "PMRD: setClamShellSleepDisable(%x->%x)\n"
        }
        symbol = "__ZN14IOPMrootDomain24setClamShellSleepDisableEbj"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "PMRD: next alarm (%s) in %u secs\n"
            "PMRD: %s %04d/%02d/%d %02d:%02d:%02d\n"
            "PMRD: next alarm (%s) %04d/%02d/%d %02d:%02d:%02d\n"
            "PMRD: scheduled alarm mask 0x%x\n"
        }
        symbol = "__ZN14IOPMrootDomain14recordRTCAlarmEPK8OSSymbolP8OSObject"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "SleepTimerWake"
            "LidOpen"
            "ACPower"
            "BatteryLow"
            "StandbyNoDelay"
            "StandbyForced"
            "StandbyDisabled"
            "USBExternalDevice"
            "BluetoothHIDDevice"
            "ExternalMediaMounted"
            "ThunderboltDevice"
            "RTCAlarmScheduled"
            "MagicPacketWakeEnabled"
            "HibernateForced"
            "AutoPowerOffDisabled"
            "AutoPowerOffForced"
            "ExternalDisplay"
            "NetworkKeepAliveActive"
            "LocalUserActivity"
            "HibernateFailed"
            "ThermalWarning"
            "DisplayCaptured"
            "PMRD: phase %d, standby %d delay %u timer %u, poweroff %d delay %u timer %u, hibernate 0x%x\n"
            "PMRD: HibernateMode is 0. Not sending LowBattery factor to IOPPF\n"
            "PMRD: sleep factors 0x%llx%s\n"
            "PMRD: sleep policy handler error\n"
            "sleep policy handler error\n"
            "PMRD: sleep params v%u, type %u, flags 0x%x, wake 0x%x, timer %u, poweroff %u\n"
        }
        symbol = "__ZN14IOPMrootDomain25evaluateSystemSleepPolicyEP25IOPMSystemSleepParametersiPj"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "IOPMSystemSleepType"
        }
        symbol = "__ZN14IOPMrootDomain30evaluateSystemSleepPolicyEarlyEv"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "PMRD: wake in %u secs for hibernateDisabled %d, hibernateAborted %d, standbyNixed %d\n"
        }
        symbol = "__ZN14IOPMrootDomain30evaluateSystemSleepPolicyFinalEv"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "PMRD: hibernateMode 0x%x\n"
        }
        symbol = "__ZN14IOPMrootDomain20getHibernateSettingsEPjS0_S0_"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "PMRD: Standby delay is not set\n"
        }
        symbol = "__ZN14IOPMrootDomain18getSystemSleepTypeEPjS0_"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "PagingOff"
            "PMRD: PM quiesce took %u ms\n"
            "Quiesce"
            "PMRD: %s all drivers took %u ms\n"
            "PMRD: %s total %u ms\n"
            "%s total %d ms:%s\n"
            "PMRD: %s msgType = 0x%x\n"
            "PMShutdown"
            "PMRD: Skipped PM node %s\n"
            "PMRD: Nodes at depth %u = %u\n"
            "PMRD: PM nodes %u, maxDepth %u, workers %u\n"
            "PMRD: %s done\n"
        }
        symbol = "__ZN14IOPMrootDomain25handlePlatformHaltRestartEj"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "IOPMUnattendedWakePowerState"
            "IOPCITunnelled"
            "PMRD: Avoiding delayChildNotification on object 0x%llx. flags: 0x%x\n"
            "PMRD: delayChildNotification for 0x%llx\n"
            "IOPMDarkWakeMaxPowerState"
            "PMRD: %s tag flags %x\n"
            "IOPCIBridge"
            "PMRD: PMTrace found PCI host bridge %s->%s\n"
            "IOPCIDevice"
            "acpi-device"
        }
        symbol = "__ZN14IOPMrootDomain20tagPowerPlaneServiceEP9IOServiceP11IOPMActionsm"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "PMRD: PowerChangeOverride (%s->%s, %x, 0x%x) tag 0x%x\n"
            "PMRD: Duplicate lowBattery sleep"
        }
        symbol = "__ZN14IOPMrootDomain22overrideOurPowerChangeEP9IOServiceP11IOPMActionsPK11IOPMRequestPmPj"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "PMRD: sleepDelaysReport f->9 start at 0x%llx\n"
            "PMRD: sleepDelaysReport 9->0 start at 0x%llx\n"
            "PMRD: sleep reason %s\n"
            "PMRD: === START (%s->%s, %x->%x, 0x%x) gen %u, msg %x, tag %x\n"
            "illegal AOT entry from %s @%s:%d"
        }
        symbol = "__ZN14IOPMrootDomain25handleOurPowerChangeStartEP9IOServiceP11IOPMActionsPK11IOPMRequestmPj"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "PMRD: sleepDelaysReport f->9 end 0x%llx\n"
            "PMRD: === FINISH (%s->%s, %x->%x, 0x%x) gen %u, msg %x, tag %x\n"
            "PMRD: DisplayOn fullwake request is removed\n"
        }
        symbol = "__ZN14IOPMrootDomain24handleOurPowerChangeDoneEP9IOServiceP11IOPMActionsPK11IOPMRequestmj"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "PMRD: power clamp enabled %s %qx, pendingCap 0x%x, ps %d, cflags 0x%x\n"
            "PMRD: power clamp removed %s %qx, pendingCap 0x%x, ps %d, cflags 0x%x\n"
            "PMRD: power clamped %s %qx, ps %u->%u, cflags 0x%x)\n"
            "PMRD: dark wake power clamped after %u ms\n"
        }
        symbol = "__ZN14IOPMrootDomain29overridePowerChangeForServiceEP9IOServiceP11IOPMActionsPK11IOPMRequestPmPj"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "PMRD: %s: delay child notify\n"
        }
        symbol = "__ZN14IOPMrootDomain28shouldDelayChildNotificationEP9IOService"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "IOPMSystemCapabilityInterest"
        }
        symbol = "__ZN14IOPMrootDomain16registerInterestEPK8OSSymbolPFiPvS3_jP9IOServiceS3_mES3_S3_"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "PMRD: destroyed capability client set %p\n"
        }
        symbol = "__ZN14IOPMrootDomain19systemMessageFilterEPvS0_S0_S0_"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "PMRD: user activity reported %d lastSleepReason %d\n"
        }
        symbol = "__ZN14IOPMrootDomain15reportUserInputEv"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "PMRD: requestUserActive: device is null\n"
            "PMRD: requestUserActive: no device name or registry entry\n"
            "%s:%s"
            "PMRD: requestUserActive from %s (0x%llx) for %s\n"
        }
        symbol = "__ZN14IOPMrootDomain17requestUserActiveEP9IOServicePKc"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "PMRD: wakeAbs %qd < nowAbs %qd\n"
            "PMRD: setWakeTime: %04d/%02d/%d %02d:%02d:%02d\n"
        }
        symbol = "__ZN14IOPMrootDomain11setWakeTimeEy"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "user alarm"
        }
        symbol = "__ZN14IOPMrootDomain13aotShouldExitEb"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "PMRD: System cannot sustain full wake\n"
            "Notification"
        }
        symbol = "__ZN14IOPMrootDomain23handleSetDisplayPowerOnEb"
        caller = "?"
    }
    new {
        args = 3
        anchors {
            "sleep-disabled"
            "PMRD: Setting gSleepDisabledFlag to %u from device tree\n"
            "PMRD: Clearing gSleepDisabledFlag due to test_sleep_in_vm boot-arg\n"
            "WakeTypeUser"
            "WakeTypeAlarm"
            "SleepService"
            "Maintenance"
            "PMRD: power event %u args %p 0x%llx\n"
        }
        symbol = "__ZN14IOPMrootDomain18dispatchPowerEventEjPvy"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "PMRD: Thermal overtemp message received!\n"
            "PMRD: DarkWake thermal limits message received!\n"
            "PMRD: Received kIOPMPowerEmergency"
            "PMRD: Clamshell opened\n"
            "Lid Open"
            "PMRD: clamshell tickled %d lastSleepReason %d\n"
            "PMRD: Ignoring redundant Clamshell close event\n"
            "PMRD: Clamshell closed\n"
            "PMRD: Desktop mode %d\n"
            "PMRD: Clamshell enabled\n"
            "PMRD: Clamshell disabled\n"
            "PMRD: ProModeEngaged\n"
            "PMRD: ProModeDisengaged\n"
        }
        symbol = "__ZN14IOPMrootDomain23handlePowerNotificationEj"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "PMRD: user active dropped\n"
            "PMRD: User activity while in notification wake\n"
            "PMRD: aggressiveness changed: system %u->%u, display %u\n"
            "PMRD: idle time -> %d ms (ena %d)\n"
            "PMRD: Requested wrangler idle\n"
            "HID Activity"
            "PMRD: Requesting full wake due to dark wake activity tickle\n"
            "PMRD: dark wake entry\n"
            "PMRD: User activity recorded while going to darkwake\n"
            "PMRD: DarkWake: sleepASAP %d, clamshell closed %d, disabled %d/%x, desktopMode %d, ac %d\n"
            "PMRD: Display sleep while in notification wake\n"
            "PMRD: extra sleep timer changed\n"
            "PMRD: user inactive\n"
            "PMRD: idle sleep timer enabled\n"
            "PMRD: idle sleep timer disabled\n"
            "PMRD: evaluatePolicy( %d, 0x%x )\n"
        }
        symbol = "__ZN14IOPMrootDomain14evaluatePolicyEij"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "AppleARMBacklight"
        }
        symbol = "___ZN14IOPMrootDomain24idleSleepPreventersCountEv_block_invoke"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "PMRD: full wake %s (reason %u) %u ms\n"
            "promotion"
            "full wake %s (reason %u) %u ms\n"
        }
        symbol = "__ZN14IOPMrootDomain15requestFullWakeENS_14FullWakeReasonE"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "PMRD: wrangler->setIgnoreIdleTimer(%d)\n"
            "CPU assertions %d\n"
            "PMRD: PreventIdleSleep driver assertion raised\n"
            "PMRD: PreventIdleSleep driver assertion dropped\n"
        }
        symbol = "__ZN14IOPMrootDomain18evaluateAssertionsEyy"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "PMStats: Hibernate read took %qd ms\n"
            "SleepStatistics"
        }
        symbol = "__ZN14IOPMrootDomain18pmStatsRecordEventEiy"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Sleep"
            "TransitionType"
        }
        symbol = "__ZN14IOPMrootDomain32pmStatsRecordApplicationResponseEPK8OSSymbolPKcijyP8OSObjectmb"
        caller = "?"
    }
    new {
        args = 7
        anchors {
            "IOPMRegisterNVRAMTracePointHandler"
            "wake-failure"
            "PMRD: Sleep failure code 0x%08x 0x%08x\n"
            "Sleep failure code 0x%08x 0x%08x\n"
            "IOPMInstallSystemSleepPolicyHandler"
        }
        symbol = "__ZN14IOPMrootDomain20callPlatformFunctionEPK8OSSymbolbPvS3_S3_S3_"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "PMRD: %s[%u] to %s\n"
            "PMRD: %s to %s\n"
        }
        symbol = "__ZN14IOPMrootDomain17traceNotificationEP8OSObjectbyj"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "PMRD: %s[%u] ack from %s took %d ms\n"
        }
        symbol = "__ZN14IOPMrootDomain20traceNotificationAckEP8OSObjectj"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "PMRD: %s[%u] response from %s took %d ms\n"
            "PMRD: %s[%u] response from %s took %d ms (ack in %d us)\n"
        }
        symbol = "__ZN14IOPMrootDomain25traceNotificationResponseEP8OSObjectjj"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "PMRD: %s to %s dropped\n"
        }
        symbol = "__ZN14IOPMrootDomain25traceFilteredNotificationEP8OSObject"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "PMRD: trace point 0x%02x msgType 0x%x detail 0x%08x\n"
        }
        symbol = "__ZN14IOPMrootDomain11traceDetailEjjj"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "PMRD: PMTraceWorker %p\n"
        }
        symbol = "__ZN13PMTraceWorker6tracerEP14IOPMrootDomain"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "PCITopLevel"
        }
        symbol = "__ZN13PMTraceWorker23recordTopLevelPCIDeviceEP9IOService"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "PMRD: trace point 0x%02x\n"
        }
        symbol = "__ZN13PMTraceWorker10tracePointEh"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "PMRD: component trace point 0x%02x data 0x%08x\n"
        }
        symbol = "__ZN13PMTraceWorker26traceComponentWakeProgressEjj"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "PMRD: trace point 0x%02x detail 0x%08x\n"
        }
        symbol = "__ZN13PMTraceWorker19tracePCIPowerChangeENS_8change_tEP9IOServicejj"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "PMRD: PMHaltWorker %p\n"
        }
        symbol = "__ZN12PMHaltWorker6workerEv"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "PMRD: PMHaltWorker free %p\n"
        }
        symbol = "__ZN12PMHaltWorker4freeEv"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "PMRD: All done for worker: %p (visits = %u)\n"
        }
        symbol = "__ZN12PMHaltWorker4mainEPvi"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "PMRD: %s driver %s (0x%llx) took %u ms\n"
            "PowerOff/Restart handler completed"
        }
        symbol = "__ZN12PMHaltWorker4workEPS_"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "PowerOff/Restart still waiting on handler"
            "PMRD: %s still waiting on %s\n"
            "%s still waiting on %s\n"
        }
        symbol = "__ZN12PMHaltWorker12checkTimeoutEPS_Py"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "PMRD: %s acknowledged without worker property\n"
        }
        symbol = "__ZN14IOPMrootDomain29acknowledgeSystemWillShutdownEP9IOService"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "DK matching"
        }
        symbol = "___ZN14IOPMrootDomain33acquireDriverKitMatchingAssertionEv_block_invoke"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Over-release of driverkit matching assertion @%s:%d"
        }
        symbol = "___ZN14IOPMrootDomain33releaseDriverKitMatchingAssertionEv_block_invoke"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "SWWdogTriggeredRestart"
            "SWWdogLogsValid"
            "DesktopMode"
            "DisplayIdleForDemandSleep"
            "IOPMDriverWakeEvents"
            "AppStatistics"
            "IdleSleepPreventers"
            "SystemSleepPreventers"
            "IdleSleepPreventersWithID"
            "SystemSleepPreventersWithID"
        }
        symbol = "__ZNK14IOPMrootDomain12copyPropertyEPKc"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "PMRD: system wake events: %s\n"
            "system wake events: %s\n"
        }
        symbol = "__ZN14IOPMrootDomain22acceptSystemWakeEventsEj"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "AOP.OutboxNotEmpty"
            "spu_gesture"
            "trackpadkeyboard"
            "Reason"
            "Details"
            "claimSystemWakeEvent(%s, %s, 0x%x) 0x%x %d\n"
            "PMRD: claimSystemWakeEvent(%s, 0x%x, %s, 0x%llx) aot %d phase 0x%x add %d\n"
        }
        symbol = "__ZN14IOPMrootDomain20claimSystemWakeEventEP9IOServicejPKcP8OSObject"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "PMRD: cpu assertion held for %llu ms by 0x%llx\n"
        }
        symbol = "__ZN19PMAssertionsTracker22reportCPUBitAccountingEv"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "DriverPMAssertions"
        }
        symbol = "__ZN19PMAssertionsTracker17publishPropertiesEv"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "PMRD: assertionsUser 0x%llx->0x%llx\n"
        }
        symbol = "__ZN19PMAssertionsTracker28handleSetUserAssertionLevelsEPv"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "CreatedTime"
            "ModifiedTime"
            "Level"
            "Assertions"
        }
        symbol = "__ZN19PMAssertionsTracker19copyAssertionsArrayEv"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "DesignCapacity"
            "MaxErr"
            "ManufactureDate"
            "BatteryHealth"
            "HealthConfidence"
            "CapacityEstimated"
            "ChargeStatus"
            "Temperature"
            "AdapterDetails"
            "ChargerConfiguration"
            "AdapterID"
            "Watts"
            "AdapterRevision"
            "SerialNumber"
            "FamilyCode"
            "Current"
            "Description"
            "PMUConfiguration"
            "Source"
            "ErrorFlags"
            "SharedSource"
            "CloakedSource"
            "BatteryInvalidWakeSeconds"
            "PostChargeWaitSeconds"
            "PostDischargeWaitSeconds"
        }
        symbol = "__ZN12IORootParent10initializeEv"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "IOPMAOTAnalytics possibleCount: %u, confirmedPossibleCount: %u, rejectedPossibleCount: %u, expiredPossibleCount: %u\n"
        }
        symbol = "__ZN14IOPMrootDomain15reportAnalyticsEv"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "starting sleep"
            "notifying applications"
            "notifying clients about upcoming system capability changes"
            "creating hibernation file or while calling rootDomain's clients about upcoming rootDomain's state changes"
            "calling power state change callbacks"
            "calling rootDomain's clients about rootDomain's state changes"
            "notifying clients about current system capabilities"
            "calling Quiesce/Sleep action callbacks"
            "halting all non-boot CPUs"
            "executing platform specific code"
            "writing the hibernation image"
            "in EFI/Bootrom after last point of entry to sleep"
            "calling Wake action callbacks"
            "starting non-boot CPUs"
            "sending kIOMessageSystemWillPowerOn message to kernel and userspace clients"
            "calling rootDomain's clients about upcoming rootDomain's state changes"
            "calling rootDomain's clients about completed rootDomain's state changes"
            "informing clients about current system capabilities"
            "sending asynchronous kIOMessageSystemHasPoweredOn message to userspace clients"
            "entering darkwake on way to sleep"
            "entering fullwake from darkwake"
            "Sleep transition timed out after %d seconds"
            "Wake transition timed out after %d seconds"
            " while "
            " Suspected bundle: "
            " Thread 0x%llx."
        }
        symbol = "__ZN14IOPMrootDomain14getFailureDataEPP6threadPcm"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "PMRD: Sleep Wake failure in EFI\n"
            "Sleep Wake failure in EFI\n\nFailure code:: 0x%08x 0x%08x\n\nPlease IGNORE the below stackshot\n"
            "PMRD: No sleep wake failure string\n"
            "PMRD: Ignoring zero byte SleepWake failure string\n"
            "PMRD: Deleting stackshot on successful wake\n"
            "/var/log/SleepWakeFailureString.txt"
            "PMRD: Failed to save SleepWake failure string to file. error:%d\n"
            "PMRD: Saved SleepWake failure string to file.\n"
            "PMRD: No SleepWake blob to read beyond chunk %d\n"
            "PMRD: Could not read the property :-(\n"
            "PMRD: Concatenated length for the SWD blob %d\n"
            "PMRD: Failed to save SleepWake zipped data to file. error:%d\n"
            "PMRD: Saved SleepWake zipped data to file.\n"
            "No stackshot data\n"
            "PMRD: No buffer allocated to save failure stackshot\n"
            "bounded_array_ref: n + m is larger than the size of any bounded_array_ref"
            "bounded_array_ref: invalid slice provided, the indices are of bounds for the bounded_array_ref"
        }
        symbol = "__ZN14IOPMrootDomain20saveFailureData2FileEv"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "PMRD: Deleting any sleepwake failure data in nvram\n"
            "PMRD: Failed to force nvram sync\n"
        }
        symbol = "__ZN14IOPMrootDomain15deleteStackshotEv"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "Power button pressed during wake transition after %u ms.\n"
            "PMRD: Taking snapshot. bytesRemaining: %d\n"
            "PMRD: stack_snapshot_from_kernel returned 0x%x. pid: %d bufsize:0x%x flags:0x%llx bytesWritten: %d\n"
            "PMRD: Insufficient buffer size for only kernel task\n"
            "PMRD: Failed to get stackshot(0x%x) bufsize:0x%x flags:0x%llx\n"
            "Failed to get stackshot(0x%x) bufsize:0x%x flags:0x%llx\n"
            "PMRD: Failed to update NVRAM %d\n"
            "PMRD: Failed to update NVRAM with leftovers\n"
            "PMRD: Successfully saved stackshot to NVRAM\n"
            "PMRD: Compressed failure stackshot of kernel+dexts is too large size=%d bytes\n"
            "PMRD: Compressed failure stackshot of only kernel is too large size=%d bytes\n"
            "\nFailure code:: 0x%08x %08x\n"
            "PMRD: Failed to write SleepWake failure string\n"
            "PMRD: Shutting down due to repeated Sleep/Wake failures\n"
            "PMRD: Calling panic prevented by swd_panic boot-args. Calling restart"
            "PMRD: PMRD inited the zlib allocation routines\n"
            "PMRD: ZERR %d\n"
            "PMRD: Total output size %d\n"
        }
        symbol = "__ZN14IOPMrootDomain13takeStackshotEb"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "PMRD: Failed to allocate Memory descriptor for sleepWake debug\n"
            "PMRD: SleepWake debug buffer size:0x%x spindump offset:0x%x\n"
        }
        symbol = "__ZN14IOPMrootDomain22sleepWakeDebugMemAllocEv"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "PMRD: Failed to open the file %s\n"
            "PMRD: Bailing as this is not a regular file\n"
            "PMRD: Failed to save sleep wake log. err 0x%x\n"
            "PMRD: Saved %d bytes to file %s\n"
        }
        symbol = "__ZN14IOPMrootDomain22sleepWakeDebugSaveFileEPKcPci"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "PMRD: disk_sync_callout ps=%u\n"
            "PMRD: disk_sync_callout finish\n"
        }
        symbol = "__ZL17disk_sync_calloutPvS_"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "PMRD: Print buffer exhausted for sleep preventers list\n"
        }
        symbol = "__ZL26makeSleepPreventersListLogRK11OSSharedPtrI5OSSetEPcm"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "PMRD: %s handler %p took %u ms\n"
            "PowerOff/Restart message to priority client"
        }
        symbol = "__ZL26platformHaltRestartApplierP8OSObjectPv"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "PMRD: Alloc in zipping %d items of size %d\n"
            "PMRD: Offset %zu\n"
        }
        symbol = "__ZL12swd_zs_allocPvjj"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "PMRD: No space to GZIP... not writing to NVRAM\n"
        }
        symbol = "__ZL11swd_zoutputP10z_stream_sPhj"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "cpu_boot_thread"
        }
        symbol = "__Z15IOCPUInitializev"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "PE_cpu_start_from_kext unimplemented @%s:%d"
        }
        symbol = "__ZN12IODARTMapper5startEP9IOService.cold.4"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "PE_cpu_halt unimplemented @%s:%d"
        }
        symbol = "__Z18IOPCIRangeOptimizeP10IOPCIRange.cold.6"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s>turning off power to cluster %d\n"
            "PE_cpu_power_disable"
        }
        symbol = "PE_cpu_power_disable"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s>turning on power to cluster %d\n"
            "PE_cpu_power_enable"
        }
        symbol = "PE_cpu_power_enable"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "IOCPUSleepKernel enter\n"
            "IOCPUSleepKernel exit\n"
        }
        symbol = "__Z16IOCPUSleepKernelv"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Can't initialize PassthruInterruptController @%s:%d"
            "ml_processor_register failed: %d @%s:%d"
            "Error finding interrupts for CPU %d @%s:%d"
            "Error registering IPIs @%s:%d"
            "Error registering PMI @%s:%d"
        }
        symbol = "__ZL15cpu_boot_threadPvi"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "assertions"
            "statistics"
            "diagnostic_api"
            "cpu-factor"
            "target-is-fpga"
        }
        symbol = "pe_init_debug"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "random-seed"
            "no random seed @%s:%d"
            "pe_gen.c"
        }
        symbol = "PE_get_random_seed"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "consistent-debug-root"
        }
        symbol = "PE_consistent_debug_inherit"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "timebase-frequency"
            "bus-frequency"
            "memory-frequency"
            "peripheral-frequency"
            "fixed-frequency"
        }
        symbol = "pe_identify_machine"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "pe_arm_init_interrupts: args: %p\n"
            "pe_arm_map_interrupt_controller: soc_phys:  0x%lx\n"
            "master"
            "pe_arm_map_interrupt_controller: found interrupt-controller\n"
            "pe_arm_map_interrupt_controller: gPicBase: 0x%lx\n"
            "pe_arm_map_interrupt_controller: failed to find the interrupt-controller.\n"
            "pe_arm_map_interrupt_controller: found timer\n"
            "pe_arm_map_interrupt_controller: gTimerBase: 0x%lx\n"
            "pe_arm_map_interrupt_controller: failed to find the timer.\n"
        }
        symbol = "pe_arm_init_interrupts"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "iBoot version: %s\n"
            "BootCLUT"
            "Pict-FailedBoot"
            "-noprogress"
            "progress-dy"
            "/chosen/iBoot"
            "start-time"
            "debug-wait-start"
            "load-kernel-start"
            "populate-registry-time"
        }
        symbol = "PE_init_iokit"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "BBBBBBBBGGGGGGGGRRRRRRRR"
            "debug-enabled"
            "firmware-version"
            "dram-vendor-id"
        }
        symbol = "PE_init_platform"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Error!! Current Magic 0x%X, expected value 0x%x\n"
        }
        symbol = "PE_update_panic_crc"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "socd-trace-ram"
        }
        symbol = "PE_init_socd_client"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "unaligned acccess to socd trace ram @%s:%d"
            "pe_init.c"
        }
        symbol = "socd_client_trace"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "embedded-panic-log-size"
            "iBoot didn't extract panic log from previous session crash, this is bad\n"
        }
        symbol = "PE_create_console"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Platform Expert not initialized @%s:%d"
            "pe_kprintf.c"
        }
        symbol = "PE_init_kprintf_config"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "disable-uart-irq"
            "Unable to find the 'defaults' devicetree node. @%s:%d"
            "serial-device"
            "Unable to find a devicetree node with phandle %x @%s:%d"
            "The serial device devicetree node doesn't have a 'compatible' string @%s:%d"
            "Unable to find serial device driver for '%s' @%s:%d"
            "uart-1,samsung"
            "Unable to find the 'reg' property on the Apple UART devicetree node @%s:%d"
            "Unable to find the 'reg' property on the Dock Channels devicetree node @%s:%d"
            "max-aop-clk"
            "enable-sw-drain"
            "dock-wstat-mask"
        }
        symbol = "serial_init"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "On-demand serial mode selected.\nWaiting for user input to send logs.\n"
        }
        symbol = "serial_set_on_demand"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Unable to find a configuration for the UART that would result in a nominal baud rate close enough to %u @%s:%d"
        }
        symbol = "apple_uart_init"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "pe_arm_init_debug: failed to initialize gSocPhys == 0\n"
            "cpu-debug-interface"
            "pe_arm_init_debug: failed to find cpu-debug-interface\n"
        }
        symbol = "pe_arm_init_debug"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "MAC Framework successfully initialized\n"
        }
        symbol = "mac_policy_initbsd"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "AppleUserConsent Policy"
            "policy's name is not set @%s:%d"
            "policy's full name is not set @%s:%d"
            "policy's managed label namespaces exceeds maximum @%s:%d"
            "policy's OPs field is NULL @%s:%d"
            "Module %s does not support late loading.\n"
            "calling mpo_policy_init for %s\n"
            "calling mpo_policy_initbsd for %s\n"
            "Security policy loaded: %s (%s)\n"
        }
        symbol = "mac_policy_register"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Security policy unload: %s (%s)\n"
        }
        symbol = "mac_policy_unregister"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Free of NULL MAC label @%s:%d"
        }
        symbol = "mac_labelzone_free"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "label backref mismatch: labelp:%p label:%p l_owner:%p @%s:%d"
        }
        symbol = "mac_label_verify_panic"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "cannot set mac label to ~0 @%s:%d"
        }
        symbol = "panic_label_set_sentinel"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: MAC hook returned no error, but status is claimed to be fatal? path: '%s', fatal_failure_desc_len: %ld, fatal_failure_desc:\n%s\n @%s:%d"
            "mac_proc_check_launch_constraints"
            "mac_process.c"
        }
        symbol = "mac_proc_check_launch_constraints"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "mac_vnode_check_signature: MAC hook returned no error, but status is claimed to be fatal? path: '%s', fatal_failure_desc_len: %ld, fatal_failure_desc:\n%s\n @%s:%d"
            "mac_vfs.c"
            "mac_vnode_check_signature: %s: code signature validation failed fatally: %s"
            "mac_vnode_check_signature: %s: failure to allocate exit reason for validation failure: %s\n"
            "mac_vnode_check_signature: %s: fatal failure is missing its description.\n"
            "mac_vnode_check_signature: %s: failed to copy reason string (kcdata_memcpy error: %d, length: %ld)\n"
            "mac_vnode_check_signature: %s: failed to allocate space for reason string (os_reason_alloc_buffer error: %d, kcdata error: %d, length: %ld)\n"
        }
        symbol = "mac_vnode_check_signature"
        caller = "?"
    }
    new {
        args = 3
        anchors {
            "vn_setlabel: null v_mount\n"
            "vn_setlabel: null v_mount with non-VNON\n"
            "%s: mac_vnode_label_store failed %d\n"
            "vn_setlabel"
            "vn_setlabel: vop setlabel failed %d\n"
        }
        symbol = "vn_setlabel"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "file_check_mmap increased max protections @%s:%d"
            "mac_file.c"
        }
        symbol = "mac_file_check_mmap"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "mac_exc_action_check_exception_send: no exc_action label for process @%s:%d"
            "mac_mach.c"
            "mac_exc_action_check_exception_send: no exc_action label for process"
        }
        symbol = "mac_exc_action_check_exception_send"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "\"Unable to recycle a chunk\" @%s:%d"
            "firehose_buffer.c"
        }
        symbol = "__ZN17AppleSmartBattery18setChargeRateLimitEP8OSObject.cold.1"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "\"TB_ASSERT: \" \"msg_buf->position >= msg_buf->reserved\" @%s:%d"
        }
        symbol = "__ZN18IODARTMapperClient5startEP9IOService.cold.2_0"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "\"TB_ASSERT: \" \"end <= msg_buf->size\" @%s:%d"
        }
        symbol = "delete_buffers_triage"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "\"TB_ASSERT: \" \"original_buffer->connection_owned\" @%s:%d"
        }
        symbol = "sched_clutch_thread_remove.cold.2"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "\"TB_ASSERT: \" \"success\" @%s:%d"
        }
        symbol = "__add_accumulator.cold.1"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "\"TB_FATAL: \" \"overflow detected when multiplying\" @%s:%d"
        }
        symbol = "_tb_message_accumulator_accumulate.cold.2"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "\"TB_ASSERT: \" \"accumulator->total_size >= total\" @%s:%d"
        }
        symbol = "key_output.cold.2"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "\"TB_ASSERT: \" \"!init_err\" @%s:%d"
        }
        symbol = "__ZN12IODARTMapper5startEP9IOService.cold.2"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "\"TB_ASSERT: \" \"tb_message_get_state(message) == TB_MESSAGE_STATE_RECEIVED\" @%s:%d"
        }
        symbol = "buf_brelse.cold.1"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "\"TB_ASSERT: \" \"tb_message_get_disposition(message) == TB_MESSAGE_DISPOSITION_QUERY\" @%s:%d"
        }
        symbol = "os_reason_set_description_data.cold.2"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "\"TB_ASSERT: \" \"buffer\" @%s:%d"
        }
        symbol = "compressor_memory_object_last_unmap"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "\"TB_ASSERT: \" \"buffer->payload != NULL\" @%s:%d"
        }
        symbol = "___tb_service_connection_create_block_invoke.cold.3_0"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "\"TB_ASSERT: \" \"query->state == TB_MESSAGE_STATE_READY\" @%s:%d"
        }
        symbol = "device_pager_data_initialize"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "\"TB_ASSERT: \" \"query->disposition == TB_MESSAGE_DISPOSITION_QUERY\" @%s:%d"
        }
        symbol = "_tb_connection_send_query.cold.3"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "\"TB_ASSERT: \" \"transport_buffer->connection_owned\" @%s:%d"
        }
        symbol = "__ZN25IOSkywalkNetworkBSDClient21adjustInterfaceEnableEv.cold.1_0"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "\"TB_ASSERT: \" \"0 && \\\"invalid transport type for static initialisation\\\"\" @%s:%d"
        }
        symbol = "__ZN26IOUnifiedAddressTranslator20mapHardwareResourcesEv.cold.10"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "\"TB_ASSERT: \" \"transport_buffer->wrapping == false\" @%s:%d"
        }
        symbol = "__ZN14OSEntitlements10getXMLBlobEv.cold.2_1"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "\"TB_ASSERT: \" \"tpt_buf->wrapping == false\" @%s:%d"
        }
        symbol = "proc_apply_resource_actions.cold.1"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "\"TB_ASSERT: \" \"self->state == TB_MESSAGE_STATE_UNINITIALIZED\" @%s:%d"
        }
        symbol = "__ZN22AppleMCA2Cluster_T803025initClusterPreflightGatedEv.cold.3"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "\"TB_ASSERT: \" \"(disposition == TB_MESSAGE_DISPOSITION_REPLY || disposition == TB_MESSAGE_DISPOSITION_QUERY)\" @%s:%d"
        }
        symbol = "__ZN17AppleUSBIORequest4freeEv.cold.1_0"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "\"TB_FATAL: \" \"overflow detected when subtracting\" @%s:%d"
        }
        symbol = "bank_init.cold.4"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "\"TB_ASSERT: \" \"start <= msg->transport_buffer->size\" @%s:%d"
        }
        symbol = "__ZN19IOPCIHostBridgeData4initEv.cold.4_0"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "\"TB_ASSERT: \" \"end <= msg->transport_buffer->size\" @%s:%d"
        }
        symbol = "__ZN16AppleT8006GPIOIC15claimWakeEventsEv.cold.1_0_0"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "\"TB_FATAL: \" \"tb_message_encode_f32_v2\" \": %d\" @%s:%d"
        }
        symbol = "_tb_message_encode_f32"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "\"TB_FATAL: \" \"tb_message_encode_f64_v2\" \": %d\" @%s:%d"
        }
        symbol = "_tb_message_encode_f64"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "\"TB_ASSERT: \" \"end <= tpt_buf->size\" @%s:%d"
        }
        symbol = "_tb_message_encode_buffer.cold.2"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "\"TB_FATAL: \" \"tb_message_decode_f32_v2\" \": %d\" @%s:%d"
        }
        symbol = "_tb_message_decode_f32"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "\"TB_FATAL: \" \"tb_message_decode_f64_v2\" \": %d\" @%s:%d"
        }
        symbol = "_tb_message_decode_f64"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "\"TB_ASSERT: \" \"kr == KERN_SUCCESS\" @%s:%d"
        }
        symbol = "ip6_ecn_egress.cold.1"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "\"TB_ASSERT: \" \"blocks->connection_message_handler\" @%s:%d"
        }
        symbol = "__ZN16EndpointInstance28initWithControllerAndOptionsEP21IOUSBDeviceControlleriiijjiP8IOMapper.cold.1"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "\"TB_ASSERT: \" \"response->state == TB_MESSAGE_STATE_READY\" @%s:%d"
        }
        symbol = "__ZN29AppleConvergedIPCRTIInterface5startEP9IOService.cold.1_0"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "\"TB_ASSERT: \" \"response\" @%s:%d"
        }
        symbol = "__ZN15IODMAController13getControllerEP9IOServicej.cold.1"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "stackshot: initial allocation failed: %d, allocating %u bytes of %u max, try %llu\n"
            "stackshot: final buffer size was insufficient at maximum size\n"
            "stackshot: debugger call failed: %d, try %llu, buffer %u estimate %u\n"
            "stackshot: initial buffer size was insufficient at maximum size\n"
            "stackshot: succeeded, traced %u bytes to %u buffer (estimate %u) try %llu\n"
        }
        symbol = "kern_stack_snapshot_internal"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "stackshot: final allocation failed: %d, allocating %u bytes of %u max, try %llu\n"
        }
        symbol = "stackshot_collect_kcdata"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Coalition [%lld] caught causing excessive I/O (flavor: %d). Task I/O: %lld MB. [Limit : %lld MB per %lld secs]. Triggered by process [%d]\n"
            "ERROR %#x returned from send_resource_violation(disk_writes, ...)\n"
        }
        symbol = "SENDING_NOTIFICATION__THIS_COALITION_IS_CAUSING_TOO_MUCH_IO"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Failed to get memory error port - mcc"
        }
        symbol = "mcc_memory_error_event_queue_invoke"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s[%d] task_info: possibly invalid task_info_count %d > TASK_VM_INFO_COUNT=%d on platform %d sdk %d.%d.%d - please use TASK_VM_INFO_COUNT"
        }
        symbol = "task_info"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "process %s[%d] caught allocating too many mach ports. \t    Num of ports allocated %u; \n"
        }
        symbol = "SENDING_NOTIFICATION__THIS_PROCESS_HAS_TOO_MANY_MACH_PORTS"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Memory pressure corpse purge for pid %d.\n"
        }
        symbol = "task_purge_all_corpses"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "corpse for pid %d disabled via SPI\n"
        }
        symbol = "task_generate_corpse_internal"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s[%d] Corpse failure, too many faults %d\n"
            "%s[%d] Corpse failure, too many %d\n"
            "%s[%d] Corpse allowed %d of %d\n"
        }
        symbol = "task_crashinfo_get_ref"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Failed to allocate event for VM API telemetry."
        }
        symbol = "vm_sanitize_send_telemetry"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "vm_reclaim: failed to initialize vmdr buffer - reclaim is disabled (%llu)\n"
            "vm_reclaim: failed to allocate VA for reclaim buffer (%d) - %s [%d]\n"
            "vm_reclaim: indices were not zero-initialized\n"
            "vm_reclaim: failed to initialize buffer on dying task %s [%d]"
            "vm_reclaim: tried to overwrite existing reclaim buffer for %s [%d]"
        }
        symbol = "vm_deferred_reclamation_buffer_init_internal"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "vm_reclaim: enquequeing %d for asynchronous reclamation.\n"
        }
        symbol = "vm_deferred_reclamation_reclaim_from_task_async"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "vm_reclaim: Unable to copy head ptr from 0x%llx: err=%d\n"
        }
        symbol = "reclaim_copyin_head"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "vm_reclaim: Unable to copy tail ptr from 0x%llx: err=%d\n"
        }
        symbol = "reclaim_copyin_tail"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "vm_reclaim: Unable to copy busy ptr from 0x%llx: err=%d\n"
        }
        symbol = "reclaim_copyin_busy"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "vm_reclaim: Userspace modified head or busy pointer! head: %llu (0x%llx) != busy: %llu (0x%llx) | tail = %llu (0x%llx)\n"
            "vm_reclaim: Userspace modified head or tail pointer! head: %llu (0x%llx) > tail: %llu (0x%llx) | busy = %llu (0x%llx)\n"
            "vm_reclaim: Unable to copyin %llu entries in reclaim buffer at 0x%llx to 0x%llx: err=%d\n"
            "vm_reclaim: Unable to deallocate 0x%llx (%u) from 0x%llx err=%d\n"
            "vm_reclaim: unable to free(reusable) 0x%llx (%u) for pid %d err=%d\n"
            "vm_reclaim: attempted to reclaim entry with unsupported behavior %uh"
        }
        symbol = "reclaim_chunk"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "vm_reclaim: Unable to copy %llu to busy ptr at 0x%llx: err=%d\n"
        }
        symbol = "reclaim_copyout_busy"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "vm_reclaim: Unable to copy %llu to head ptr at 0x%llx: err=%d\n"
        }
        symbol = "reclaim_copyout_head"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "NSPACE SNAPSHOT not handled"
            "NSPACE TRACK not handled"
            "NSPACE no port"
            "NSPACE resolve_path call"
            "NSPACE resolve failure: %d"
            "NSPACE process %s (pid %d) is decorated as no-materialization (op %lld; %s)"
        }
        symbol = "vfs_materialize_item"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "NSPACE send_nspace_resolve_cancel failure: %d"
        }
        symbol = "nspace_resolver_req_wait"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "bpfopen: bpf%d kalloc_type bpf_d failed"
            "bpf%u opened by %s.%u"
        }
        symbol = "bpfopen"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "bpfattach - %s with dlt %d is already attached"
        }
        symbol = "bpf_attach"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s: %s"
        }
        symbol = "bpfdetach"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "bpfwrite: len %d if %s less than copy_len %d"
            "bpfwrite: bad len %d if %s"
            "bpfwrite: len %u - hlen %u too big if %s write_size_max %u"
            "bpfwrite: len %u - hlen %u too big if %s mtu %u"
            "bpfwrite mbuf_allocpacket len %d error %d"
            "bpfwrite uiomove hlen %d error %d"
            "bpfwrite bpf_copy_uio_to_mbuf_packet error %d"
            "bpf_copy_uio_to_mbuf_packet: len %d error %d"
        }
        symbol = "bpf_movein"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s: uuids not found error %d"
            "%s: processes not matching error %d"
            "%s: d_to is closing error %d"
            "%s: d_from is closing error %d"
            "%s: bufsizes not matching error %d"
            "%s: bpf_setif() failed error %d"
        }
        symbol = "bpf_setup"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: ifnet_allocate failed %d"
            "%s: bridge_ifnet_set_attrs failed %d"
            "%s: ifnet_attach failed %d"
            "%s: ifnet_set_lladdr_and_type failed %d"
            "%s: bridge_set_tso failed %d"
            "%s: failed error %d"
            "%s: ifnet_set_mtu failed %d"
            "%s: ifnet_set_flags failed %d"
            "%s sdl len %d index %d family %d type 0x%x nlen %d alen %d slen %d addr %s"
        }
        symbol = "bridge_clone_create"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: ARP %s short frame %lu < %lu"
            "%s: ARP %s size %lu mbuf_pullup fail"
            "%s: ARP %s htype not ethernet"
            "%s: ARP %s hlen not ethernet"
            "%s: ARP %s ptype not IP"
            "%s: ARP %s plen not IP"
        }
        symbol = "is_valid_arp_packet"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: IP %s short frame %lu < %lu"
            "%s: IP %s size %lu mbuf_pullup fail"
        }
        symbol = "get_ether_ip_header_ptr"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s: mbuf_copydata udphdr failed %d"
            "%s: mbuf_copydata dp_flags failed %d"
            "%s: %s %s DHCP dp_flags 0x%x UDP cksum 0x%x"
            "%s: short IPv6 payload length %d < %lu"
            "%s: failed to pullup icmp6 header"
            "%s: failed to pullup icmp6 + payload"
            "%s: short nd_ns %d < %lu"
            "%s: invalid target ignored"
            "%s: invalid ND6 NS option"
            "%s: bad ND6 DAD packet"
            "%s: source lladdrlen %d != %lu"
            "%s: short nd_na %d < %lu"
            "%s: invalid ND6 NA option"
            "%s: target lladdrlen %d != %lu"
            "%s: short ND6 %s %d < %d"
            "%s: invalid ND6 %s option"
            "%s: %s %s %s ip6len %d icmp6len %d lladdr offset %d"
        }
        symbol = "bridge_mac_nat_output"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s: bridge_get_ip_proto failed %d"
            "%s: IP checksum HW %svalid"
            "%s: IP checksum SW %svalid"
            "%s: IPv%c %s checksum HW 0x%x %svalid"
            "%s: IPv%c %s checksum SW %svalid (0x%x) hlen %d paylen %d"
        }
        symbol = "bridge_verify_checksum"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: non-TCP (%d) IPv%c frame %d bytes"
            "%s: fragmented TSO packet?"
            "%s: m_pullup %d failed"
        }
        symbol = "bridge_get_tcp_header"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s: ifp %s cmd 0x%08lx (%c%c [%lu] %c %lu)"
            "%s: ifp %s has address"
            "%s: %s SIOCSIFLLADDR error %d"
            "%s: %s invalid MTU: %u(%s) != %d"
        }
        symbol = "bridge_ioctl"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: ifnet_get_address_list(%s) failed %d"
            "%s: ifaddr_address failed %d"
            "%s: ifaddr_address_family unknown %d"
        }
        symbol = "bridge_mac_nat_enable"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s0x%llx type: %u flags: 0x%x len: %u data: 0x%llx maxlen: %u datastart: 0x%llx next: 0x%llx%s"
            "%s<NULL>%s"
            "%spktlen: %u rcvif: 0x%llx header: 0x%llx nextpkt: 0x%llx%s"
        }
        symbol = "brlog_mbuf"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%02x%s"
        }
        symbol = "brlog_mbuf_data"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: IPv4 checksum 0x%x"
            "%s: bad tcp header length %u"
            "%s: IPv%c %s set checksum 0x%x"
        }
        symbol = "bridge_offload_checksum"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: %s.%dbrhf_arp_too_small"
            "%s: %s.%dbrhf_arp_pullup_failed"
            "%s: %s.%dbrhf_arp_bad_hw_type"
            "%s: %s.%dbrhf_arp_bad_pro_type"
            "%s: %s.%dbrhf_arp_bad_hw_len"
            "%s: %s.%dbrhf_arp_bad_pro_len"
            "%s: %s.%dbrhf_arp_bad_op"
            "%s: %s.%dbrhf_arp_bad_sha"
            "%s: %s.%dbrhf_arp_bad_spa"
        }
        symbol = "bridge_host_filter_arp"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "%s: %s.%dbrhf_dhcp_too_small"
            "%s: %s.%dbrhf_dhcp_bad_op"
            "%s: %s.%dbrhf_dhcp_bad_htype"
            "%s: %s.%dbrhf_dhcp_bad_hlen"
            "%s: %s.%dbrhf_dhcp_bad_chaddr"
            "%s: %s.%dbrhf_dhcp_bad_ciaddr"
        }
        symbol = "bridge_dhcp_filter"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "%s: zalloc_nolock failed"
            "%s: added %02x:%02x:%02x:%02x:%02x:%02x on %s count %u hashsize %u"
        }
        symbol = "bridge_rtupdate"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: %s new size %u"
            "%s: %s failed %d"
        }
        symbol = "bridge_rthash_delayed_resize"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "%s: large non IPv4/IPv6 packet"
            "%s: gso_tcp returned no packets"
            "%s: %s packets %d bytes %d"
        }
        symbol = "bridge_interface_input"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s: %s doesn't support LRO"
            "%s: %s %s failed (cap 0x%x) %d"
            "%s: %s %s success (cap 0x%x)"
        }
        symbol = "bridge_set_lro"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: ifnet_set_offload(%s, 0x%x) failed %d"
            "%s: ifnet_set_tso_mtu(%s, AF_INET, %u) failed %d"
            "%s: ifnet_set_tso_mtu(%s, AF_INET6, %u) failed %d"
        }
        symbol = "bridge_set_tso"
        caller = "?"
    }
    new {
        args = 3
        anchors {
            "%s: %s MAC-NAT input translate to %s"
            "%s: %s MAC-NAT input for %s"
        }
        symbol = "bridge_mac_nat_input_list"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s: %s is not attached"
        }
        symbol = "if_updown"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "interface %s management set %s by %s:%d"
        }
        symbol = "ifnet_set_management"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "null_proto_input unexpected packet on %s"
        }
        symbol = "null_proto_input"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "eventhandler_invoke(\"ifnet_event\")"
            "eventhandler_invoke: executing %p"
        }
        symbol = "intf_event_callback"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "kern_nexus_interface_remove_netagent(%s) returned %d"
        }
        symbol = "ifnet_remove_netagent"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s:%d %s Failed for ioctl %lu as interface is not attached"
            "%s:%d %s unknown ioctl %lu"
        }
        symbol = "ifnet_ioctl_async"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: interface %s (%u) available\n"
            "%s: interface %s (%u) unavailable)\n"
        }
        symbol = "if_state_update"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%3lu: %s"
        }
        symbol = "log_hexdump"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s:%d %s ifnet_ioctl returned %d for ioctl %lu"
            "%s:%d %s ifnet_ioctl returned successfully for ioctl %lu"
        }
        symbol = "ifnet_ioctl_event_callback"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s: dropping short packet %d < %d"
        }
        symbol = "ether_demux"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: proto_register_plumber failed for AF_INET error=%d"
            "%s: proto_register_plumber failed for AF_INET6 error=%d"
            "%s: proto_register_plumber failed vlan_clone_attach error=%d"
        }
        symbol = "vlan_family_init"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "%s: %s: unable to prepend VLAN header"
            "%s: %s: m_pullup VLAN header failed"
            "%s: %s: needed to m_pullup VLAN header"
            "%s: %s: %s tag %d bytes %d (%s)"
        }
        symbol = "vlan_output"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s: %s: propagated link event to vlans"
            "%s: %s: %s wakeup"
        }
        symbol = "vlan_parent_signal"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: %s: ifnet_set_promiscuous(%s, %d) failed %d"
            "%s: %s: ifnet_set_promiscuous(%s, %d) succeeded"
        }
        symbol = "vlan_set_promisc"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s: last vlan on %s"
        }
        symbol = "vlan_unconfig"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: if_fake: copy_mbuf(): packet too large %d"
            "%s: if_fake: Large mbuf fragment %d > %d"
        }
        symbol = "copy_mbuf"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s: ifnet_set_offload(%s, 0x%x) failed, %d"
            "%s: ifnet_set_offload(%s, 0x%x) succeeded"
        }
        symbol = "feth_ifnet_set_attrs"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s: set TSO MTU IPv4 failed on %s, err %d"
            "%s: set TSO MTU IPv6 failed on %s, err %d"
        }
        symbol = "feth_set_tso_mtu"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: %s: ifnet_stat() failed %d"
            "%s: %s: interface advisory report failed %d"
        }
        symbol = "feth_if_adv"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s: %s ring %d flags 0x%x"
            "%s: %s peer fakeif %s is detaching"
            "%s: %s peer fakeif %s channel not connected, expn: %d"
            "%s: %s no peer fakeif (peer %p)"
            "%s: %s no peer"
        }
        symbol = "feth_nx_sync_tx"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s: %s err=%d getting packetid"
            "%s: %s err=%d getting nx_port_id"
        }
        symbol = "feth_get_packet_notification_details"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s: not enough room"
            "%s: %zuB trailer added"
        }
        symbol = "feth_add_packet_trailer"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s: %s: TX refill failed %d"
            "%s: %s: TX refilled"
            "%s: %s: threadcall waking up waiter"
        }
        symbol = "feth_async_doorbell"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: %s: detaching"
            "%s: %s: invalid qset_idx %d"
        }
        symbol = "feth_nx_qset_init"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: %s: invalid tx qidx %d"
            "%s: %s: invalid rx qidx %d"
        }
        symbol = "feth_nx_queue_init"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s: invalid llink_idx idx %d (max %d) on peer %s"
            "%s: invalid qset_idx %d (max %d) on peer %s"
            "%s: NULL default queue (llink_idx %d, qset_idx %d) on peer %s"
        }
        symbol = "feth_rx_queue_submit"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: free_provider_instance failed %d"
            "%s: deregister_provider %d"
        }
        symbol = "feth_detach_netif_nexus"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s: rd is NULL\n"
            "%s: %s is detaching\n"
            "%s: if_redirect_request_copyin failed: error %d\n"
            "%s: NULL delegate name\n"
            "%s: delegate %s not found\n"
            "%s: %s's family %d not compatible with ethernet functional type\n"
            "%s: low latency %s cannot be a delegate\n"
            "%s: %s's family %d not compatible with cellular functional type\n"
            "%s: delegate %s cannot be redirect\n"
            "%s: user_addr(0x%llx) or len(%llu) < %lu\n"
            "%s: copyin failed: %d\n"
            "%s: reserved[0]=0x%llu, reserved[1]=0x%llureserved[2]=0x%llu, reserved[3]=0x%llu\n"
            "%s: cannot configure the same delegate\n"
            "%s: failed to get self reference\n"
            "%s: failed to get delegate reference\n"
            "%s: failed to set delegate ifp: %d\n"
            "%s: failed to get mac addr from %s, error %d\n"
            "%s: failed to set mac addr for %s, error %d\n"
            "%s: delegate %s detached during setup\n"
        }
        symbol = "redirect_ioctl"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: %s: classifier info missing\n"
            "%s: %s: l4len(%u) < icmp6len(%lu)\n"
        }
        symbol = "redirect_rx_cb"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s: %s ring %d flags 0x%x\n"
            "%s: %s is not usable\n"
            "%s: %s has no delegate\n"
            "%s: delegate interface is being detached\n"
            "%s: nexus adapter is not present\n"
            "%s: enqueue failed: %d\n"
        }
        symbol = "redirect_nx_sync_tx"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s: %s: Tx refill (sync) %d\n"
            "%s: %s: Tx refilled (sync)\n"
            "%s: %s: schedule async refill\n"
        }
        symbol = "redirect_nx_tx_doorbell"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s: %s: Tx refill failed %d\n"
            "%s: %s: Tx refilled\n"
            "%s: %s: threadcall waking up waiter\n"
        }
        symbol = "redirect_async_doorbell"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: cannot %s advisory on %s because it is not usable\n"
            "%s: advisory is already %s on %s\n"
            "%s: delegate is not set on %s\n"
        }
        symbol = "redirect_nx_intf_adv_config"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: free_provider_instance failed %d\n"
            "%s: deregister_provider failed %d\n"
        }
        symbol = "redirect_detach_netif_nexus"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: proto_register_plumber failed for AF_INET error %d"
            "%s: proto_register_plumber failed for AF_INET6 error %d"
            "%s: bond_clone_attach error %d"
        }
        symbol = "bond_family_init"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: interface %s doesn't support mtu %d"
            "%s: (%s, %s) hwassist values don't match 0x%x != 0x%x, using 0x%x instead"
            "%s: (%s, %s): SIOCSIFMTU %d failed %d"
            "%s: (%s, %s): multicast_list_program failed %d"
            "%s: (%s, %s): SIOCSIFFLAGS failed %d"
            "%s: (%s, %s): if_siflladdr failed %d"
            "%s: (%s, %s): set promiscuous failed %d"
            "%s: (%s, %s): if_siflladdr restore failed %d"
            "%s: (%s, %s): promiscous mode disable failed %d"
            "%s: name too large"
            "%s: SIOCGIFDEVMTU %s failed, %d"
        }
        symbol = "bond_add_interface"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s: [%s] Receive PORT_DISABLED"
            "%s: [%s] Receive PORT_DISABLED: link timer started"
            "%s: [%s] Receive PORT_DISABLED: link timer completed, marking UNSELECTED"
        }
        symbol = "bondport_receive_machine_port_disabled"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s: [%s] Mux WAITING"
            "%s: [%s] Mux WAITING: Standby"
            "%s: [%s] Mux WAITING: Port is already ready"
            "%s: [%s] Mux WAITING: Timer already set"
            "%s: [%s] Mux WAITING: No waiting"
            "%s: [%s] Mux WAITING: 2 seconds"
            "%s: [%s] Mux WAITING: Ready"
            "%s: [%s] Mux WAITING: All Ports Ready"
        }
        symbol = "bondport_mux_machine_waiting"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: [%s] periodic_transmit Start"
            "%s: [%s] periodic_transmit: Need To Transmit"
            "%s: [%s] Periodic Transmission Timer: %d secs"
        }
        symbol = "bondport_periodic_transmit_machine"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s: (%s, %s): if_siflladdr (%s) failed %d"
            "%s: (%s, %s): disable promiscuous failed %d"
        }
        symbol = "bond_remove_interface"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s: %s failed, invalid dst sa_len %d\n"
            "%s: %s failed, mask sa_len %d too large\n"
            "%s: removing route to %s->%s->%s, flags 0x%x, ifaddr %s\n"
            "%s: removed route to %s->%s->%s, flags 0x%x, ifaddr %s\n"
            "%s: added route to %s->%s->%s, flags 0x%x, ifaddr %s\n"
        }
        symbol = "rtinit_locked"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s - called with null reference"
            "%s - called with incorrect shadow magic 0x%x"
        }
        symbol = "nstat_provider_stats_close"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s - for interface index %u with flags %x"
            "%s - for matching interface with flags %x"
            "%s - *matched non-Skywalk* [filter match: %d]"
            "%s - nstat get ifflags %d"
            "%s - nstat get progressdigest returned %d"
            "%s - *matched Skywalk* [filter match: %x %x]"
        }
        symbol = "progress_indicators"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "%s - NSTAT_DEBUG_SOCKET <pid %d>: NSTAT: Collecting stats"
            "%s - NSTAT_DEBUG_SOCKET <pid %d>: NSTAT: <pid %d> Collected stats - domain <%s> owner <%s> ctxt <%s> bundle id <%s> is_tracker %d is_non_app_initiated %d is_silent %d"
        }
        symbol = "nstat_inp_domain_info"
        caller = "?"
    }
    new {
        args = 3
        anchors {
            "%s - nstat_client_send_event() %d"
            "%s - nstat_client_send_event() used when updates not supported"
        }
        symbol = "nstat_client_send_event"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "%s - nstat_client_send_update() %d"
            "%s - nstat_client_send_counts() %d"
            "%s - nstat_client_send_description() %d"
            "%s - nstat_client_send_removed() %d"
        }
        symbol = "nstat_client_send_goodbye"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s - mbuf_allocpacket failed"
            "%s - resorting to ctl_enqueuedata"
        }
        symbol = "nstat_accumulate_msg"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s - src->nts_provider->nstat_copy_descriptor: %d"
            "%s - src->nts_provider->nstat_counts: %d"
        }
        symbol = "nstat_client_append_update"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s - nstat_userland_tu_copy_descriptor  returned %d"
            "%s - nstat_userland_tu_counts  returned %d"
        }
        symbol = "nstat_userland_get_snapshot"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: ifindex %u too big"
            "%s: unexpected protocol %u for inp %p"
        }
        symbol = "if_ports_used_add_inpcb"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: unexpected protocol %u for nfi %p"
        }
        symbol = "if_ports_used_add_flow_entry"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "%s: called PKT_F_WAKE_PKT not set from %s"
            "%s: unexpected protocol family %u from %s"
            "%s: unexpected wake fragment from %s"
            "%s: pkt with unassigned TCP header from %s"
            "%s: pkt with unassigned UDP header from %s"
            "%s: unexpected IP protocol %u from %s"
        }
        symbol = "if_ports_used_match_pkt"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "sysctl_wake_pkt_event_notify proc %s:%u val %u last_wake_phy_if_delay_wake_pkt %d last_wake_phy_if_family %u"
        }
        symbol = "sysctl_wake_pkt_event_notify"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "sysctl_wake_pkt_event_delay_if_families proc %s:%u npi_wake_packet_event_delay_if_families 0x%x -> 0x%x"
        }
        symbol = "sysctl_wake_pkt_event_delay_if_families"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: wakeuuid not set not adding port: %u flags: 0x%xif: %u pid: %u epid %u"
            "%s: zalloc() failed for port: %u flags: 0x%x if: %u pid: %u epid %u"
            "%s: num %u for port: %u flags: 0x%x if: %u pid: %u epid %u"
            "%s: already added port: %u flags: 0x%x if: %u pid: %u epid %u"
        }
        symbol = "net_port_info_add_entry"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s net_port_info if_index %u arch %s family %s proto %s local %s:%u foreign %s:%u pid: %u epid %u"
        }
        symbol = "net_port_info_log_npi"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "utun_output - ctl_enqueuembuf failed: %d\n"
        }
        symbol = "utun_output"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "utun_framer - ifnet_output prepend failed\n"
            "Received app uuid error %d for %s%d\n"
            "Cannot set proc uuid for %s%d, size %d < %zu\n"
        }
        symbol = "utun_framer"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s, tx refill failed %d\n"
            "utun_netif_tx_doorbell: ifnet_disable_output returned error %d\n"
        }
        symbol = "utun_netif_tx_doorbell"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "utun_cleanup_family - invalid protocol family %d\n"
            "utun_cleanup_family - failed to create %s socket: %d\n"
            "utun_cleanup_family - utun_detach_ip failed: %d\n"
            "fnet_get_address_list_family(%s%d, 0xblah, %s) - failed: %d\n"
            "utun_remove_address - ifaddr_address failed: %d"
            "utun_remove_address - SIOCDIFADDR failed: %d"
            "utun_remove_address - ifaddr_address failed (v6): %d"
            "utun_remove_address - SIOCDIFADDR_IN6 failed: %d"
        }
        symbol = "utun_cleanup_family"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "utun_ctl_rcvd: ctl_getenqueuepacketcount returned error %d\n"
            "utun_ctl_rcvd: ifnet_enable_output returned error %d\n"
        }
        symbol = "utun_ctl_rcvd"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "utun_attach_inet - ifnet_attach_protocol %d failed: %d\n"
        }
        symbol = "utun_attach_proto"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "ipsec_output: first mbuf length shorter than IP header length: %d.\n"
            "ipsec_output: Bad ip header length %d.\n"
            "ipsec_output: ipsec4_output error %d.\n"
            "ipsec_output: first mbuf length shorter than IPv6 header length: %d.\n"
            "ipsec_output: ipsec6_splithdr returned NULL\n"
            "ipsec_output: ipsec6_output error %d\n"
            "ipsec_output: Received unknown packet version %d.\n"
        }
        symbol = "ipsec_output"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "ipsec_cleanup_family - invalid protocol family %d\n"
            "ipsec_cleanup_family - failed to create %s socket: %d\n"
            "ipsec_cleanup_family - ipsec_detach_ip failed: %d\n"
            "ipsec_remove_address - ifaddr_address failed: %d"
            "ipsec_remove_address - SIOCDIFADDR failed: %d"
            "ipsec_remove_address - ifaddr_address failed (v6): %d"
            "ipsec_remove_address - SIOCDIFADDR_IN6 failed: %d"
        }
        symbol = "ipsec_cleanup_family"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "ipsec_attach_inet - ifnet_attach_protocol %d failed: %d\n"
        }
        symbol = "utun_attach_proto_0"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: necp_session_action find fd error (%d)\n"
            "%s: necp_session_action unknown action (%u)\n"
        }
        symbol = "necp_session_action"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s: DATA-TRACE <%s>: %s - fam %d proto %d port <local %d/%d remote %d/%d> <local %s remote %s> <drop-all order %d> <BoundInterface %d> <socket policy id %d socket skip id %d> <mbuf %X len %d %d>\n"
            "%s: DATA-TRACE: IP Output: RESULT - MATCHED (ID %d BoundInterface %d LastInterface %d Proto %d) Policy %d Result %d Parameter %d Route Rule %u\n"
            "%s: DATA-TRACE: IP Output: RESULT - NO MATCH (ID %d BoundInterface %d LastInterface %d Proto %d)\n"
        }
        symbol = "necp_ip_output_find_policy_match"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s: DATA-TRACE <%s>: %s - fam %d proto %d port <local %d/%d remote %d/%d> <local %s remote %s> <drop-all order %d> <BoundInterface %d> <socket policy id %d socket skip id %d> <mbuf %X len %d %d %d>\n"
            "%s: DATA-TRACE: IP6 Output: RESULT - MATCHED (ID %d BoundInterface %d LastInterface %d Proto %d) Policy %d Result %d Parameter %d Route Rule %u\n"
            "%s: DATA-TRACE: IP6 Output: RESULT - NO MATCH (ID %d BoundInterface %d LastInterface %d Proto %d)\n"
        }
        symbol = "necp_ip6_output_find_policy_match"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: necp_session_get_policy invalid input (%zu)\n"
            "%s: necp_session_get_policy policy_id copyin error (%d)\n"
            "%s: Failed to find policy with id %d\n"
            "%s: necp_session_get_policy buffer not large enough (%zu < %u)\n"
            "%s: necp_session_get_policy size too large to copy (%u)\n"
            "%s: necp_session_get_policy TLV copyout error (%d)\n"
        }
        symbol = "necp_session_get_policy"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: necp_session_delete_policy invalid input (%zu)\n"
            "%s: necp_session_delete_policy policy_id copyin error (%d)\n"
            "%s: necp_session_delete_policy failed to find policy with id %u\n"
        }
        symbol = "necp_session_delete_policy"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: necp_session_list_all size too large to copy (%u policies)\n"
            "%s: necp_session_list_all buffer not large enough (%zu < %u)\n"
            "%s: necp_session_list_all TLV copyout error (%d)\n"
        }
        symbol = "necp_session_list_all"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: necp_session_set_session_priority invalid input (%zu)\n"
            "%s: necp_session_set_session_priority priority copyin error (%d)\n"
            "%s: Session does not hold necessary entitlement to claim priority level %d\n"
        }
        symbol = "necp_session_set_session_priority"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: necp_session_register_service invalid input (%zu)\n"
            "%s: necp_session_register_service uuid copyin error (%d)\n"
        }
        symbol = "necp_session_register_service"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: necp_session_unregister_service invalid input (%zu)\n"
            "%s: necp_session_unregister_service uuid copyin error (%d)\n"
        }
        symbol = "necp_session_unregister_service"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: necp_session_add_domain_filter invalid input (%zu)\n"
            "%s: necp_session_add_domain_filter buffer not large enough (%zu)\n"
            "%s: necp_session_add_domain_filter allocate filter error (%zu)\n"
            "%s: necp_session_add_domain_filter filter copyin error (%d)\n"
            "%s: necp_session_add_domain_filter size mismatch (%zu != %zu)\n"
            "%s: necp_session_add_domain_filter ID copyout error (%d)\n"
        }
        symbol = "necp_session_add_domain_filter"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: necp_session_remove_domain_filter invalid input (%zu)\n"
            "%s: necp_session_remove_domain_filter uuid copyin error (%d)\n"
        }
        symbol = "necp_session_remove_domain_filter"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s (process %s:%u) %s matches %s/%u"
            "%s (process %s:%u) %s no match"
        }
        symbol = "necp_address_matches_drop_dest_policy"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s: DATA-TRACE <%s>: %s - policy id=%d session_order=%d policy_order=%d result=%s (cond_policy_id %d) (skip_session_order %d skip_order %d)\n"
            "%s: DATA-TRACE <%s>: %s - fam %d proto %d port <local %d/%d remote %d/%d> <local %s remote %s> <drop-all order %d> <BoundInterface %d> (policy id=%d session_order=%d policy_order=%d result=%s)\n"
            "%s: DATA-TRACE <%s>: ------ %smatching <%s> <value (%d / 0x%X) (%d / 0x%X) (%d / 0x%X) input (%d / 0x%X) (%d / 0x%X) (%d / 0x%X)>\n"
        }
        symbol = "necp_ip_output_find_policy_match_locked"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: QoS Marking : Interface match %d for Rule %d Allowed %d\n"
            "%s: QoS Marking: C:%d WF:%d W:%d E:%d Cn:%d Cmpn:%d VPN:%d for Rule %d Allowed %d\n"
            "%s: QoS Marking: Rule %d ifp %s Allowed %d\n"
        }
        symbol = "necp_update_qos_marking"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "necp_route_is_interface_type_allowed %s:%d %s not allowed on management interface %s"
        }
        symbol = "necp_log_interface_not_allowed"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: Route Allowed: No interface for route, using default for Rule %d Allowed %d\n"
            "%s: Route Allowed: Interface match %d for Rule %d Deny LQM Abort\n"
            "%s: Route Allowed: Interface match %d for Rule %d Allowed %d\n"
            "%s: Route Allowed: C:%d WF:%d W:%d E:%d Cmpn:%d VPN:%d for Rule %d Allowed %d\n"
            "%s: Route Allowed: Using default for Rule %d Allowed %d\n"
        }
        symbol = "necp_route_is_allowed_inner"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: %s (process %s:%u) not permitted\n"
            "%s: %s (process %s:%u) bad newlen %lu\n"
            "%s: %s (process %s:%u) sysctl_io_opaque() error %d\n"
            "%s: %s (process %s:%u) bad entry_count %u\n"
            "%s: %s (process %s:%u) NECP_SESSION_PRIORITY_UNKNOWN bad entry_count %u\n"
            "%s: %s (process %s:%u) priority %u entry_count 0\n"
            "%s: %s (process %s:%u) bad level %u\n"
            "%s: %s (process %s:%u) AF_INET bad prefix %u\n"
            "%s: %s (process %s:%u) AF_INET bad sin_len %u\n"
            "%s: %s (process %s:%u) AF_INET bad sin_port %u, not zero\n"
            "%s: %s (process %s:%u) AF_INET6 bad prefix %u\n"
            "%s: %s (process %s:%u) AF_INET6 bad sin6_len %u\n"
            "%s: %s (process %s:%u) AF_INET6 bad sin6_port %u, not zero\n"
            "%s: %s (process %s:%u) AF_INET6 bad sin6_flowinfo %u, not zero\n"
            "%s: %s (process %s:%u) AF_INET6 bad sin6_scope_id %u, not zero\n"
        }
        symbol = "sysctl_handle_necp_drop_dest_level"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: necp_client_action find fd error (%d)\n"
            "%s: necp_client_action unknown action (%u)\n"
        }
        symbol = "necp_client_action"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s: NECP_SOCKET_PARAMS_LOG <pid %d>: NECP ATTRIBUTES SOCKET - domain <%s> owner <%s> context <%s> tracker domain <%s> account <%s> <so flags - is_tracker %X non-app-initiated %X app-approved-domain %X\n\n"
            "%s: Set on socket: Domain <%s> Domain owner <%s> Domain context <%s> Tracker domain <%s> Account <%s> \n"
        }
        symbol = "necp_set_socket_domain_attributes"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s: NECP CLIENT FLOW TRACE <pid %d %s> <flow %s>: Collecting stats\n\n"
            "%s: NECP CLIENT FLOW TRACE <pid %d %s> <flow %s>: Collected stats - domain <%s> owner <%s> ctxt <%s> bundle id <%s> is_tracker %d is_non_app_initiated %d is_silent %d\n\n"
        }
        symbol = "necp_find_domain_info_common"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: Incorrect length (got %zu, expected %zu)\n"
            "%s: necp_client_copy client_id copyin error (%d)\n"
            "%s: necp_client_copy request flow divert TLV copyout error (%d)\n"
        }
        symbol = "necp_client_copy"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: necp_client_copy parameters copyout error (%d)\n"
            "%s: necp_client_copy result copyout error (%d)\n"
            "%s: necp_client_copy group members copyout error (%d)\n"
        }
        symbol = "necp_client_copy_internal"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s: necp_client_copy assigned results tlv_header copyout error (%d)\n"
            "%s: necp_client_copy assigned results copyout error (%d)\n"
            "%s: necp_client_copy protocol control event results tlv_header copyout error (%d)\n"
        }
        symbol = "necp_client_fillout_flow_tlvs"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: req tcp stats, failed to get route details for pid %d curproc %d %s\n\n"
            "%s: req tcp stats, necp_client flow_registration flow_stats missing for pid %d %s curproc %d %s\n\n"
            "%s: Collected stats - TCP - epid %d uid %d euuid %s persona id %d\n"
        }
        symbol = "necp_request_tcp_netstats"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: req udp stats, failed to get route details for pid %d curproc %d %s\n\n"
            "%s: req udp stats, necp_client flow_registration flow_stats missing for pid %d %s curproc %d %s\n\n"
            "%s: Collected stats - UDP - epid %d uid %d euuid %s persona id %d\n"
        }
        symbol = "necp_request_udp_netstats"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: req quic stats, failed to get route details for pid %d curproc %d %s\n\n"
            "%s: req quic stats, necp_client flow_registration flow_stats missing for pid %d %s curproc %d %s\n\n"
            "%s: Collected stats - QUIC - epid %d uid %d euuid %s persona id %d\n"
        }
        symbol = "necp_request_quic_netstats"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: necp_client_request_nexus copyin client_id error (%d)\n"
            "%s: necp_client_request_nexus process not found for pid %d error (%d)\n"
            "%s: necp_client_request_nexus copyin bufreq error (%d)\n"
            "%s: necp_client_request_nexus copyout bufreq error (%d)\n"
            "%s: Request nexus error (%d)\n"
        }
        symbol = "necp_client_request_nexus"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: necp_client_copy_agent copyin agent_uuid error (%d)\n"
        }
        symbol = "necp_client_copy_agent"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: Copyin client_id error (%d)\n"
            "%s: Parameters copyin error (%d)\n"
            "%s: Parameters copyout error (%d)\n"
        }
        symbol = "necp_client_agent_use"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: necp_client_update_cache copyin client_id error (%d)\n"
            "%s: necp_client_update_cache no flow error (%d)\n"
            "%s: necp_client_update_cache copyin cache buffer error (%d)\n"
            "%s: necp_client_update_cache copyin ecn cache buffer error (%d)\n"
            "%s: necp_client_update_cache copyin tfo cache buffer error (%d)\n"
        }
        symbol = "necp_client_update_cache"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: Client assignment failed: %d\n"
        }
        symbol = "netagent_assign_nexus"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: Provided user buffer is too small (%u < %u)\n"
            "%s: Copied agent content (error %d)\n"
        }
        symbol = "netagent_copyout"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: mbuf_tag_id_find_internal failed: %d\n"
            "%s: ctl_register failed: %d\n"
        }
        symbol = "netagent_init"
        caller = "?"
    }
    new {
        args = 3
        anchors {
            "%s: Register message size too small for agent: (%zu < %zu)\n"
            "%s: Register message size could not be read, error %d data_size %zu\n"
            "%s: Failed to read data into agent structure: %d\n"
            "%s: Failed to register agent: %d\n"
        }
        symbol = "netagent_handle_register_message"
        caller = "?"
    }
    new {
        args = 3
        anchors {
            "%s: Update message size too small for agent: (%zu < %zu)\n"
            "%s: Update message size could not be read, error %d data_size %zu\n"
        }
        symbol = "netagent_handle_update_message"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: Failed to read uuid for assign message: %d\n"
            "%s: Failed to allocate assign message (%lu bytes)\n"
            "%s: Failed to read assign message: %d\n"
        }
        symbol = "netagent_handle_assign_nexus_message"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "eventhandler_invoke(\"in6_clat46_event\")"
        }
        symbol = "in6_clat46_event_callback"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s:%d unit %u\n"
        }
        symbol = "pktap_clone_create"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s:%d %s: kauth_authorize_generic(KAUTH_GENERIC_ISSUSER) - error %d\n"
        }
        symbol = "pktap_ioctl"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s:%d pass %s match type %u\n"
            "%s:%d pass %s match name %s\n"
            "%s:%d skip %s match type %u\n"
            "%s:%d skip %s match name %s\n"
            "%s:%d %s no match\n"
        }
        symbol = "pktap_filter_evaluate"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "%s:%d mbuf_copydata tcp v4 failed for %s\n"
            "%s:%d mbuf_copydata udp v4 failed for %s\n"
            "%s:%d in_pcblookup_hash no pcb %s\n"
            "%s:%d unknown ip_p %u on %s\n"
            "%s:%d mbuf_copydata tcp v6 failed for %s\n"
            "%s:%d mbuf_copydata udp v6 failed for %s\n"
            "%s:%d in6_pcblookup_hash no pcb %s\n"
            "%s:%d unknown ip6.ip6_nxt %u on %s\n"
        }
        symbol = "pktap_fill_proc_info"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s:%d ifp %s proto %u pre %u post %u\n"
        }
        symbol = "pktap_input"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "%s:%d unsupported protocol %d\n"
            "%s:%d %s: header %d > %d\n"
        }
        symbol = "pktap_bpf_tap_packet"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: ignore v1 query on IGIF_LOOPBACK ifp %s\n"
            "%s: process v1 query on ifp %s\n"
        }
        symbol = "igmp_input_v1_query"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: inm %llx already on relq ifp %s\n"
            "%s: adding inm %llx on relq ifp %s\n"
        }
        symbol = "igmp_append_relq"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "in_pcb_check_management_entitled %s:%d not management entitled %s"
        }
        symbol = "in_pcb_check_management_entitled"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s: unable to insert route to %s;%s, flags=0x%x, due to existing ARP route %s->%s flags=0x%x, attempting to delete\n"
            "%s: route to %s->%s->%s inserted, oflags=0x%x, flags=0x%x\n"
            "%s: route to %s->%s->%s inserted, flags=0x%x\n"
            "%s: unable to insert route to %s->%s->%s, flags=0x%x, already exists\n"
        }
        symbol = "in_addroute"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s: deleting route to %s->%s->%s, flags=0x%x\n"
            "%s: route to %s->%s->%s invalidated, flags=0x%x, expire=T+%u\n"
        }
        symbol = "in_clsroute"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: initial nextstop is T+%u seconds\n"
            "%s: found %u, killed %u\n"
            "%s: adjusted rtq_reallyold to %d seconds\n"
        }
        symbol = "in_rtqtimo"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: weak ES interface match to %s for packet from %s to %s proto %u received via %s"
            "%s: no interface match for packet from %s to %s proto %u received via %s"
        }
        symbol = "ip_input_check_interface"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: Resetting TFO-data loss to 0 from %u on heur %lx\n"
            "%s: Resetting TFO-req loss to 0 from %u on heur %lx\n"
            "%s: Resetting TFO-data RST to 0 from %u on heur %lx\n"
            "%s: Resetting TFO-req RST to 0 from %u on heur %lx\n"
            "%s: Resetting ECN-loss to 0 from %u and synrst from %u on heur %lx\n"
            "%s disabling heuristics for 12 hours"
        }
        symbol = "tcp_heuristic_reset_counters"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s disable ECN until %u now %u on %lx for SYN-loss\n"
            "%s disable MPTCP until %u now %u on %lx\n"
            "%s disable ECN until %u now %u on %lx for drop-RST\n"
            "%s disable ECN until %u now %u on %lx for drop-Rxmit\n"
            "%s disable ECN until %u now %u on %lx for SYN-RST\n"
        }
        symbol = "tcp_heuristic_inc_counters"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "already processed AccECN field/options for this ACK"
        }
        symbol = "tcp_process_accecn"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: sysctl_io_string() error %d, req->newlen %lu, sizeof(keystring) %lu"
            "%s: strlen(keystring) %lu != TCP_FASTOPEN_KEYLEN * 2 %u, newlen %lu"
            "%s: sscanf() != 1, error EINVAL"
        }
        symbol = "tcp_sysctl_fastopenkey"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: %u > %u TSO 0 tunnel_ifp %s hwassist mismatch with ifp %s"
            "%s: %u > %u TSO 0 tunnel_ifp %s hwassist mismatch with inp_last_outifp %s"
            "%s: %u > %u TSO 0 tunnel_ifp %s hwassist mismatch with inp_boundifp %s"
            "%s: %u > %u TSO %d ifp %s"
        }
        symbol = "tcp_set_tso"
        caller = "?"
    }
    new {
        args = 5
        anchors {
            "Segment start (%u) is not same as retransmitted start sequence number (%u)"
            "segment %p[%u %u) was not inserted in the RB tree"
        }
        symbol = "tcp_seg_sent_insert"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "bytes_sacked (%u) can't be smaller than already SACKed segment length (%u)"
        }
        symbol = "tcp_segs_clear_sacked"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "bytes_retransmitted (%u) can't be smaller than retransmited segment length (%u)"
        }
        symbol = "tcp_mark_seg_lost"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "RB tree still contains segments while time ordered list is already empty"
            "Segment ACKed list shouldn't contain any segments as they are removed immediately after being ACKed"
        }
        symbol = "tcp_segs_sent_clean"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "pacer rate shouldn't be 0, CCA is %s (cwnd=%u, smoothed rtt=%u ms)"
        }
        symbol = "tcp_pacer_get_packet_tx_time"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "bytes_lost (%u) can't be smaller than already lost segment length (%u)"
            "bytes_retransmitted (%u) can't be smaller than already retransmited segment length (%u)"
        }
        symbol = "tcp_seg_delete_acked"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "bytes_lost (%u) and/or bytes_retransmitted (%u) can't be smaller than already lost/retransmitted segment length (%u)"
        }
        symbol = "tcp_seg_mark_sacked"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: probe_if_index %u conflicts with %u, tcps_probe_if_conflict %u\n"
            "%s: timer list already running for if_index %u\n"
            "%s: timer will fire sooner than needed for if_index %u\n"
        }
        symbol = "tcp_interface_send_probe"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "connect address error %d for %s process %s:%u"
        }
        symbol = "tcp_log_address_error"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "16 {curProtocol: 100, prevProtocol: %hhu, prevUUID: %02X%02X%02X%02X-%02X%02X-%02X%02X-%02X%02X-%02X%02X%02X%02X%02X%02X, localPort: %hu, remotePort: %hu, tcpSeq: %u, length: %u, pid: %hu, logSeqn: %hhu}"
        }
        symbol = "mpkl_tcp_send"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: error %d for proc %s[%u] out ifp is not set\n"
            "%s: error %d for proc %s[%u] if_tcp_kao_max %u\n"
        }
        symbol = "tcp_set_keep_alive_offload"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Prague CC: Cubic origin point should be greater than 0"
        }
        symbol = "tcp_prague_ack_rcvd"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "new CE count (%u) can't be less than current CE count (%u)OR newly ACKed (%u) can't be less that current ACKed (%u)"
            "%u packets were newly CE marked"
            "one RTT hasn't elapsed, not doing CWR"
            "one RTT hasn't elapsed, not updating alpha"
            "currently in loss recovery, no need to do CWR"
        }
        symbol = "tcp_prague_process_ecn"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "tcp_rtt_info (%s:%d) [%s:%u<->%s:%u] interface: %s (skipped: %lu)\nso_gencnt: %llu t_state: %s process: %s:%u base_rtt: %u ms rttcur: %u ms srtt: %u ms rttvar: %u ms rttmin: %u ms rxtcur: %u rxtshift: %u"
        }
        symbol = "tcp_log_rtt_info"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "tcp_rt_rtt (%s:%d) [%s:%u<->%s:%u] interface: %s (skipped: %lu)\nso_gencnt: %llu t_state: %s process: %s:%u rt_rmx: RTV_RTT: %d ms rtt: %u ms rttvar: %u ms"
        }
        symbol = "tcp_log_rt_rtt"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "tcp_rtt_change (%s:%d) [%s:%u<->%s:%u] interface: %s (skipped: %lu)\nso_gencnt: %llu t_state: %s process: %s:%u srtt: %u ms old_rtt: %u ms rttvar: %u old_rttvar: %u ms "
        }
        symbol = "tcp_log_rtt_change"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "tcp_keepalive (%s:%d) [%s:%u<->%s:%u] interface: %s (skipped: %lu)\nso_gencnt: %llu t_state: %s process: %s:%u snd_una: %u snd_max: %u SO_KA: %d RSTALL: %d TFOPRB: %d idle_time: %u KIDLE: %d KINTV: %d KCNT: %d"
        }
        symbol = "tcp_log_keepalive"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "tcp %s: [%s:%u<->%s:%u] interface: %s (skipped: %lu)\nso_gencnt: %llu t_state: %s process: %s:%u SYN in/out: %u/%u bytes in/out: %llu/%llu pkts in/out: %llu/%llu rtt: %u.%u ms rttvar: %u.%u ms base_rtt: %u ms error: %d so_error: %d svc/tc: %u flow: 0x%x"
            "tcp %s: [%s:%u<->%s:%u] interface: %s (skipped: %lu)\nso_gencnt: %llu t_state: %s process: %s:%u SYN in/out: %u/%u bytes in/out: %llu/%llu pkts in/out: %llu/%llu rtt: %u.%u ms rttvar: %u.%u ms base_rtt: %u ms error: %d so_error: %d svc/tc: %u flow: 0x%x\nso_qlimit: %d so_qlen: %d so_incqlen: %d "
        }
        symbol = "tcp_log_connection"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "tcp listen: [%s:%u<->%s:%u] interface: %s (skipped: %lu)\nso_gencnt: %llu t_state: %s process: %s:%u so_qlimit: %d error: %d so_error: %d svc/tc: %u"
        }
        symbol = "tcp_log_listen"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "tcp_connection_summary [%s:%u<->%s:%u] interface: %s (skipped: %lu)\nso_gencnt: %llu t_state: %s process: %s:%u Duration: %u.%03u sec Conn_Time: %u.%03u sec bytes in/out: %llu/%llu pkts in/out: %llu/%llu pkt rxmit: %u ooo pkts: %u dup bytes in: %u ACKs delayed: %u delayed ACKs sent: %u\nrtt: %u.%03u ms rttvar: %u.%03u ms base rtt: %u ms so_error: %d svc/tc: %u flow: 0x%x"
            "tcp_connection_summary [%s:%u<->%s:%u] interface: %s (skipped: %lu)\nso_gencnt: %llu t_state: %s process: %s:%u flowctl: %lluus (%llux) SYN in/out: %u/%u FIN in/out: %u/%u RST in/out: %u/%u AccECN (client/server): %s/%s\n"
        }
        symbol = "tcp_log_connection_summary"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "tcp drop incoming control packet tcp control %s %s%s%s%sreason: %s"
        }
        symbol = "tcp_log_drop_pkt"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "tcp (%s:%d) [%s:%u<->%s:%u] interface: %s (skipped: %lu)\nso_gencnt: %llu t_state: %s process: %s:%u bytes in/out: %llu/%llu pkts in/out: %llu/%llu %s"
        }
        symbol = "tcp_log_message"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "tcp (%s:%d) [%s:%u<->%s:%u] interface: %s (skipped: %lu)\nso_gencnt: %llu t_state: %s process: %s:%u flow %s %s"
        }
        symbol = "tcp_log_fsw_flow"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "tcp_state_changed [%s:%u<->%s:%u] interface: %s (skipped: %lu)\nso_gencnt: %llu t_state: %s process: %s:%u "
        }
        symbol = "tcp_log_state_change"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "tcp (%s:%d) [%s:%u<->%s:%u] interface: %s (skipped: %lu)\nso_gencnt: %llu t_state: %s process: %s:%u bytes in/out: %llu/%llu pkts in/out: %llu/%llu rxmit pkts/bytes: %u/%u%s"
        }
        symbol = "tcp_log_output"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "udp %s: [%s:%u<->%s:%u] interface: %s (skipped: %lu)\nso_gencnt: %llu so_state: 0x%04x process: %s:%u bytes in/out: %llu/%llu pkts in/out: %llu/%llu error: %d so_error: %d svc/tc: %u flow: 0x%x"
        }
        symbol = "udp_log_connection"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "udp_connection_summary [%s:%u<->%s:%u] interface: %s (skipped: %lu)\nso_gencnt: %llu so_state: 0x%04x process: %s:%u Duration: %lu.%03d sec Conn_Time: %lu.%03d sec bytes in/out: %llu/%llu pkts in/out: %llu/%llu rxnospace pkts/bytes: %llu/%llu so_error: %d svc/tc: %u flow: 0x%x"
            "udp_connection_summary [%s:%u<->%s:%u] interface: %s (skipped: %lu)\nso_gencnt: %llu so_state: 0x%04x process: %s:%u flowctl: %lluus (%llux) "
        }
        symbol = "udp_log_connection_summary"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "(%u): Detaching, ref count = %d\n"
        }
        symbol = "flow_divert_detach"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "(%u): flow_divert_init failed (%d), cannot use flow divert\n"
            "(%u): Failed to get the key unit from the token: %d\n"
            "(%u): Failed to get the control socket unit from the token: %d\n"
            "(%u): Failed to get the aggregate unit from the token: %d\n"
            "(%u): HMAC verfication failed: %d\n"
        }
        symbol = "flow_divert_token_set"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "(%u): failed to allocate the header mbuf: %d\n"
        }
        symbol = "flow_divert_token_get"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "(%u): Send buffer is NULL, but size is supposed to be %lu\n"
            "(%u): mbuf_copym failed: %d\n"
            "(%u): failed to find type MT_DATA in the mbuf chain.\n"
            "(%u): mbuf_copym() data_len = %lu\n"
            "(%u): sent %lu bytes of buffered data\n"
        }
        symbol = "flow_divert_send_buffered_data"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "(%u): flow_divert_packet_init failed: %d\n"
        }
        symbol = "flow_divert_send_data_packet"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "(%u): mbuf_copyback(hdr) failed: %d\n"
        }
        symbol = "flow_divert_packet_init"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "(%u): no provider, cannot send packet\n"
            "(%u): flow_divert_send_packet: ctl_enqueuembuf returned an error: %d\n"
        }
        symbol = "flow_divert_send_packet"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "(%u): flow_divert_append_target_endpoint_tlv() failed: %d\n"
            "(%u): flow_divert_packet_append_tlv(FLOW_DIVERT_TLV_IS_FRAGMENT) failed: %d\n"
            "(%u): flow_divert_packet_append_tlv(FLOW_DIVERT_TLV_DATAGRAM_SIZE) failed: %d\n"
        }
        symbol = "flow_divert_send_datagram_packet"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "(%u): Invalid target address, family = %u, length = %u\n"
        }
        symbol = "flow_divert_append_target_endpoint_tlv"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "(%u): sending close, how = %d\n"
            "(%u): failed to create a close packet: %d\n"
            "(%u): failed to add the error code TLV: %d\n"
            "(%u): failed to add the how flag: %d\n"
        }
        symbol = "flow_divert_send_close_if_needed"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "(%u): Removing from group %d, ref count = %d\n"
        }
        symbol = "flow_divert_pcb_remove"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "(%u): Destroying, app tx %llu, tunnel tx %llu, tunnel rx %llu\n"
        }
        symbol = "flow_divert_pcb_destroy"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "(%u): Connecting\n"
            "(%u): No destination address available when creating connect packet\n"
            "(%u): Destination address is not valid when creating connect packet\n"
            "(%u): Failed to dup the remote endpoint\n"
            "(%u): failed to get a local IPv6 address: %d\n"
            "(%u): failed to get a local IPv4 address: %d\n"
            "(%u): target address has an unsupported family: %d\n"
            "(%u): Delaying sending the connect packet until send or receive\n"
            "(%u): Sending saved connect packet\n"
        }
        symbol = "flow_divert_connect_out_internal"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "(%u): Constrained is denied\n"
        }
        symbol = "flow_divert_check_no_constrained"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "(%u): Got %s from token\n"
            "(%u): Failed to add source proc info: %d\n"
            "(%u): failed to find the real proc record for %d\n"
            "(%u): Looking for process with UUID %s\n"
        }
        symbol = "flow_divert_create_connect_packet"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "(%u): Found multiple processes with UUID %s with different signing identifiers\n"
            "(%u): Failed to find a process with UUID %s\n"
        }
        symbol = "flow_divert_find_proc_by_uuid_callout"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "(%u): Found process %d with signing identifier %s\n"
        }
        symbol = "flow_divert_find_proc_by_uuid_filter"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "(%u): Signature of proc is invalid\n"
            "(%u): %s did not match\n"
            "(%u): %s matched\n"
            "(%u): failed to append the signing ID: %d\n"
            "(%u): failed to append the cdhash: %d\n"
            "(%u): failed to get the cdhash\n"
            "(%u): failed to append app audit token: %d\n"
        }
        symbol = "flow_divert_add_proc_info"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "(%u): Failed to append %s: %d\n"
        }
        symbol = "flow_divert_append_domain_name"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "(%u): Failed to copy the connect packet\n"
        }
        symbol = "flow_divert_send_connect_packet"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "(%u): provider is no longer accepting writes, cannot send data\n"
            "(%u): Using remote address from CFIL saved state: %p\n"
            "(%u): implicit connect\n"
            "(%u): app wrote %lu bytes\n"
            "(%u): mbuf_split failed: %d\n"
            "(%u): sbappendstream failed with pkt_data, send buffer size = %u, send_window = %u\n\n"
            "(%u): sbappendstream failed with remaining_data, send buffer size = %u, send_window = %u\n\n"
            "(%u): flow_divert_send_datagram_packet failed with error %d, send data size = %lu\n"
            "(%u): sbappendaddr failed. send buffer size = %u, send_window = %u, error = %d\n"
            "(%u): sbappendrecord failed. send buffer size = %u, send_window = %u\n"
            "(%u): flow_divert_send_datagram_packet failed with error %d, send data size = %lu, dropping the datagram\n"
        }
        symbol = "flow_divert_data_out"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "(%u): No valid group is available, cannot init flow divert\n"
            "(%u): Created\n"
            "(%u): pcb insert failed: %d\n"
            "(%u): Failed to create a unique hash\n"
        }
        symbol = "flow_divert_pcb_init_internal"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "(%u): Group %u already contains a PCB with hash %u\n"
            "(%u): Group %u is defunct, cannot insert\n"
        }
        symbol = "flow_divert_pcb_insert"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "(%u): Length of %u TLV (%u) is larger than remaining packet data (%lu)\n"
        }
        symbol = "flow_divert_packet_get_tlv"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "(%u): Failed to lookup group for control unit %u\n"
            "(%u): HMAC in token does not match computed HMAC\n"
        }
        symbol = "flow_divert_packet_verify_hmac"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "(%u): failed to append the type (%d)\n"
            "(%u): failed to append the length (%u)\n"
            "(%u): failed to append the value\n"
        }
        symbol = "flow_divert_packet_append_tlv"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "(%u): No active groups, flow divert cannot be used for this socket\n"
            "(%u): Cannot lookup group with invalid control unit (%u)\n"
            "(%u): No active non-in-process groups, flow divert cannot be used for this socket\n"
            "(%u): Group for control unit %u is NULL, flow divert cannot be used for this socket\n"
            "(%u): No active in-process groups, flow divert cannot be used for this socket\n"
            "(%u): Group for control unit %u not found, flow divert cannot be used for this socket\n"
            "(%u): Cannot access group for control unit %u, mismatched PID (%u != %u)\n"
        }
        symbol = "flow_divert_group_lookup"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "(%u): Destroying group %u\n"
        }
        symbol = "flow_divert_group_destroy"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "(%u): Closing\n"
        }
        symbol = "flow_divert_close"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "(%u): app read bytes, space = %d\n"
            "(%u): Sent a read notification\n"
            "(%u): failed to create a read notification packet: %d\n"
        }
        symbol = "flow_divert_rcvd"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "(%u): Can't send more\n"
        }
        symbol = "flow_divert_shutdown"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "(%u): Pre-connect read: sending saved connect packet\n"
        }
        symbol = "flow_divert_preconnect"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "(%u): failed to create a properties update packet: %d\n"
            "(%u): failed to add the traffic class: %d\n"
        }
        symbol = "flow_divert_ctloutput"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "(%u): Flow divert connect fail, unit mismatch %u != %u\n"
        }
        symbol = "flow_divert_kctl_connect"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "(%u): got a bad packet, length (%lu) < sizeof hdr (%lu)\n"
            "(%u): mbuf_copydata failed for the header: %d\n"
            "(%u): got an unknown message type: %d\n"
            "(%u): got a %s message from group %d for an unknown pcb: %u\n"
            "(%u): failed to get the key size: %d\n"
            "(%u): Invalid key size: %u\n"
            "(%u): Skipping (re)initialization of defunct group %u\n"
            "(%u): failed to get the token key: %d\n"
            "(%u): group %u order is %u\n"
            "(%u): Invalid prefix count (%d) or an error occurred while reading the prefix count: %d\n"
            "(%u): Failed to get the length of the signing identifier at offset %d: %d\n"
            "(%u): Overflow while incrementing number of bytes\n"
            "(%u): No signing identifiers\n"
            "(%u): Overflow while computing the number of nodes\n"
            "(%u): Overflow while computing the number of maps\n"
            "(%u): Invalid bytes count (%lu), nodes count (%lu) or maps count (%lu)\n"
            "(%u): Nodes count = %lu, child maps count = %lu, bytes_count = %lu\n"
            "(%u): Trie memory size (%lu) is too big (maximum is %u)\n"
            "(%u): Failed to allocate %lu bytes of memory for the signing ID trie\n"
            "(%u): Failed to get the length of the signing identifier at offset %d while building: %d\n"
            "(%u): Failed to read the signing identifier at offset %d: %d\n"
            "(%u): No place to put signing ID for insertion\n"
            "(%u): Ran out of trie nodes while splitting an existing node\n"
            "(%u): Ran out of child maps while splitting an existing node\n"
            "(%u): Ran out of trie nodes while inserting a new leaf\n"
            "(%u): Ran out of bytes while inserting a new leaf\n"
            "(%u): Ran out of child maps while inserting a new leaf\n"
            "(%u): flow_divert_packet_init failed: %d, cannot send flow states\n"
            "(%u): flow_divert_handle_flow_states_request: group send queue is not empty\n"
            "(%u): Failed to add a flow state: %d\n"
            "(%u): flow_divert_handle_flow_states_request: ctl_enqueuembuf returned an error: %d\n"
            "(%u): failed to get the connect result: %d\n"
            "(%u): received connect result %u\n"
            "(%u): failed to get the send window: %d\n"
            "(%u): No control unit provided in the connect result\n"
            "(%u): No local address provided\n"
            "(%u): No remote address provided\n"
            "(%u): No output if index provided\n"
            "(%u): No application data provided in connect result\n"
            "(%u): socket is not attached any more, ignoring connect result\n"
            "(%u): TCP socket is not in the connecting state, ignoring connect result\n"
            "(%u): Got %u bytes of app data from the connect result\n"
            "(%u): Failed to copy %u bytes of application data from the connect result packet\n"
            "(%u): Failed to allocate a buffer of size %u to hold the application data from the connect result\n"
            "(%u): Connect result contains an invalid control unit: %u\n"
            "(%u): sending connect result\n"
            "(%u): failed to create a connect result packet: %d\n"
            "(%u): Next control unit is the same as the current control unit, disabling flow divert\n"
            "(%u): No more valid control units, disabling flow divert\n"
            "(%u): Group for control unit %u does not exist\n"
            "(%u): Moving from %u to %u\n"
            "(%u): Failed to send the connect packet to %u, disabling flow divert\n"
            "(%u): Skipped all flow divert services, disabling flow divert\n"
            "(%u): Failed to connect using the socket's original protocol: %d\n"
            "(%u): Failed to copy the mbuf chain in the socket's send buffer\n"
            "(%u): Failed to send queued TCP data using the socket's original protocol: %d\n"
            "(%u): Failed to get the remote address from the buffer\n"
            "(%u): Buffered record does not contain any data\n"
            "(%u): Buffered data does not have a packet header\n"
            "(%u): Failed to send queued UDP data using the socket's original protocol: %d\n"
            "(%u): failed to get the close error: %d\n"
            "(%u): failed to get the close how flag: %d\n"
            "(%u): close received, how = %d\n"
            "(%u): socket is not attached any more, ignoring close from provider\n"
            "(%u): socket is not attached any more, ignoring inbound data\n"
            "(%u): Receive buffer is full, will send read notification when app reads some data\n"
            "(%u): Remote address is invalid\n"
            "(%u): app cannot receive any more data, dropping %lu bytes of data\n"
            "(%u): socket has an unsupported type: %d\n"
            "(%u): received %lu bytes of data\n"
            "(%u): failed to dup the socket address.\n"
            "(%u): failed to append %lu bytes of data: %d\n"
            "(%u): failed to get the read count: %d\n"
            "(%u): received a read notification for %u bytes\n"
            "(%u): socket is not attached any more, ignoring read notification\n"
            "(%u): received a properties update\n"
            "(%u): No output if index provided in properties update\n"
            "(%u): No application data provided in properties update\n"
            "(%u): socket is not attached any more, ignoring properties update\n"
            "(%u): Failed to copy %u bytes of application data from the properties update packet\n"
            "(%u): Failed to allocate a buffer of size %u to hold the application data from the properties update\n"
        }
        symbol = "flow_divert_kctl_send"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "(%u): failed to scope to %d because inp_bindif returned %d\n"
            "(%u): failed to derive a new local address from %d because in_pcbladdr returned %d\n"
        }
        symbol = "flow_divert_scope"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "(%u): trying ctl_enqueuembuf again\n"
            "(%u): flow_divert_kctl_rcvd: ctl_enqueuembuf returned an error: %d\n"
        }
        symbol = "flow_divert_kctl_rcvd"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s:%u sysctl net.inet.tcp.mptcp_preferred_version: %d -> %d)"
        }
        symbol = "sysctl_mptcp_version_check"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s - %lx: mismatched address ids %d %d \n"
            "%s - %lx: dup SYN_ACK %d %d \n"
        }
        symbol = "mptcp_set_raddr_rand"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s - %lx: skt_unit is still 0\n"
            "%s - %lx: Couldn\\'t find proc for uuid %s\n"
            "%s - %lx: Couldn\\'t find proc for pid %u\n"
            "%s - %lx: asked symptoms about pid %u, taskprio %u, prio %u, err %d\n"
        }
        symbol = "mptcp_ask_symptoms"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s - %lx: unable to create subflow socket error %d\n"
            "%s - %lx: necp_client_register_socket_flow failed with error %d\n"
            "%s - %lx: state changed during unlock: %u flags %#x\n"
            "%s - %lx: so_set_effective_pid failed with error %d\n"
            "%s - %lx: so_set_effective_uuid failed with error %d\n"
            "%s - %lx: sopt %s val %d interim record removed\n"
        }
        symbol = "mptcp_subflow_socreate"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s - %lx: Cell should be set (count is %u), but it's zero!\n"
            "%s - %lx: Setting cellicon failed with %d\n"
            "%s - %lx: successfully set the cellicon\n"
        }
        symbol = "mptcp_set_cellicon"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "%s - %lx: copyout failed: %d\n"
            "%s - %lx:error from in_getconninfo %d\n"
            "%s - %lx: Asking for too many ifindex: %u subcount %u, mpts? %s\n"
        }
        symbol = "mptcp_getconninfo"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s - %lx: Wrong ADD_ADDR length %u\n"
            "%s - %lx: ADD_ADDR length for v4 but version is %u\n"
            "%s - %lx: ADD_ADDR length for v6 but version is %u\n"
            "%s - %lx: ADD_ADDR invalid addr: %x\n"
            "%s - %lx: ADD_ADDRv6 invalid addr: %s\n"
            "%s - %lx: Received ADD_ADDRv0\n"
        }
        symbol = "mptcp_do_add_addr_opt_v0"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s - %lx: Received ADD_ADDR with echo bit\n"
            "%s - %lx: ADD_ADDR addr: %x invalid HMAC\n"
            "%s - %lx: ADD_ADDR addr: %s invalid HMAC\n"
            "%s - %lx: Received ADD_ADDRv1\n"
        }
        symbol = "mptcp_do_add_addr_opt_v1"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "ah_schedule %s: error %d\n"
        }
        symbol = "ah_schedule"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "ah4_calccksum: invalid IP option (type=%02x)\n"
            "ah4_calccksum: invalid IP option (type=%02x len=%02x)\n"
        }
        symbol = "ah4_calccksum"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "ah_hmac_mature: no key is given.\n"
            "ah_hmac_mature: unsupported algorithm.\n"
            "ah_hmac_mature: invalid key length %d.\n"
        }
        symbol = "ah_hmac_mature"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "ah_none_mature: protocol and algorithm mismatch.\n"
        }
        symbol = "ah_none_mature"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "IPv6 AH input: AH with IPv6 jumbogram is not supported.\n"
            "IPv6 AH input: no key association found for spi %u\n"
            "IPv6 AH input: non-mature/dying SA found for spi %u; "
            "IPv6 AH input: unsupported authentication algorithm for spi %u\n"
            "sum length too short in IPv6 AH input (%u, should be at least %u): %s\n"
            "sum length mismatch in IPv6 AH input (%d should be %u): %s\n"
            "replay packet in IPv6 AH input: %s %s\n"
            "IPv6 AH input: couldn\\'t alloc temporary region for cksum\n"
            "checksum mismatch in IPv6 AH input: %s %s\n"
            "authentication failed in IPv6 AH input: %s %s\n"
            "ipsec tunnel protocol mismatch in IPv6 AH input: %s\n"
        }
        symbol = "ah6_input"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "ah6_output: first mbuf too short\n"
            "ah6_output: md is not in chain\n"
            "ip6_output: AH with IPv6 jumbogram is not supported\n"
            "ah6_output: internal error: sav->replay is null: SPI=%u\n"
            "ah6_output: unsupported algorithm: SPI=%u\n"
        }
        symbol = "ah6_output"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "esp_schedule %s: unsupported key length %d: needs %d to %d bits\n"
            "esp_schedule %s: implicit IV not allowed\n"
            "esp_schedule %s: error %d\n"
        }
        symbol = "esp_schedule"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "esp_cbc_mature: algorithm incompatible with 4 octets IV length\n"
            "esp_descbc_mature: no key is given.\n"
            "esp_descbc_mature: unsupported algorithm.\n"
            "esp_descbc_mature: invalid key length %d.\n"
            "esp_descbc_mature: weak key was passed.\n"
        }
        symbol = "esp_descbc_mature"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "esp_cbc_decrypt %s: unsupported ivlen %d\n"
            "esp_cbc_encrypt %s: unsupported ivlen/blocklen: %d %d\n"
            "esp_cbc_decrypt %s: bad len %d/%u\n"
            "esp_cbc_decrypt %s: payload length must be multiple of %d\n"
        }
        symbol = "esp_cbc_decrypt"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "esp_cbc_encrypt %s: unsupported ivlen %d\n"
            "esp_cbc_encrypt %s: bad len %d/%u\n"
            "esp_cbc_encrypt %s: payload length must be multiple of %u\n"
        }
        symbol = "esp_cbc_encrypt"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "esp_cbc_mature: algorithm incompatible with esp-old\n"
            "esp_cbc_mature: algorithm incompatible with derived\n"
            "esp_cbc_mature: no key is given.\n"
            "esp_cbc_mature: unsupported algorithm.\n"
            "esp_cbc_mature %s: invalid key length %d.\n"
            "esp_cbc_mature %s: weak key was passed.\n"
        }
        symbol = "esp_cbc_mature"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "esp_gcm_mature: algorithm incompatible with esp-old\n"
            "esp_gcm_mature: algorithm incompatible with derived\n"
            "esp_gcm_mature: no key is given.\n"
            "esp_gcm_mature: unsupported algorithm.\n"
            "esp_gcm_mature %s: invalid key length %d.\n"
            "esp_gcm_mature %s: invalid algo %d.\n"
        }
        symbol = "esp_gcm_mature"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "19 {curProtocol: 80 spi: 0x%X, espSeq: %u, PayloadProtocol: 100, localPort: %hu, remotePort: %hu, tcpSeq: %u, tcpLen: %hu}"
        }
        symbol = "esp_input_log"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "esp4_output: first mbuf too short\n"
        }
        symbol = "esp4_output"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "esp6_output: first mbuf too short\n"
        }
        symbol = "esp6_output"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "esp_cbc_encrypt %s: payload length must be multiple of %d\n"
        }
        symbol = "esp_cbc_encrypt_aes"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: unsupported ivlen %d\n"
            "%s: IIV and GMAC-only not supported together\n"
        }
        symbol = "esp_gcm_schedule"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s: gcm reset failure\n"
            "%s: iv generation failure\n"
            "%s: iv set failure\n"
            "%s: bad len %d/%u\n"
            "%s: packet encryption ESP header AAD failure\n"
            "%s: packet encryption IV AAD failure\n"
            "%s: failed to encrypt\n"
            "%s: failed to add data to AAD\n"
            "%s: not enough mbufs %d %d, SPI 0x%08x"
        }
        symbol = "esp_gcm_encrypt_aes"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s: failed to set IV\n"
            "%s: packet decryption ESP header AAD failure\n"
            "%s: packet decryption IV AAD failure\n"
            "%s: failed to decrypt\n"
        }
        symbol = "esp_gcm_decrypt_aes"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s:%d ChaChaPoly chacha20poly1305_verify failed %d, SPI 0x%08x"
        }
        symbol = "esp_chachapoly_decrypt_finalize"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s:%d ChaChaPoly Packet too short %d < %u, SPI 0x%08x"
            "%s:%d not enough mbufs %d %d, SPI 0x%08x"
        }
        symbol = "esp_chachapoly_decrypt"
        caller = "?"
    }
    new {
        args = 3
        anchors {
            "ipsec4_set_policy: invalid direction=%u\n"
        }
        symbol = "ipsec4_set_policy"
        caller = "?"
    }
    new {
        args = 3
        anchors {
            "ipsec6_set_policy: invalid direction=%u\n"
        }
        symbol = "ipsec6_set_policy"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "ipsec_hdrsiz: unknown protocol %u\n"
            "ipsec_hdrsiz: unknown AF %d in IPsec tunnel SA\n"
        }
        symbol = "ipsec_hdrsiz"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "replay counter made %d cycle. %s\n"
        }
        symbol = "ipsec_updatereplay"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "ipsec4 interface kpipe output: source buffer shorter than ip header, %u\n"
            "ipsec4 interface kpipe output: failed to find outbound sav\n"
            "ipsec4 interface kpipe output: sah is NULL\n"
            "ipsec tunnel mode not supported in kpipe mode, SPI=%x\n"
            "sadb flag %x not supported in kpipe mode, SPI=%x\n"
            "ipsec4 interface kpipe output: buflet size shorter than hlen %u, SPI=%x\n"
            "AH not supported in kpipe mode\n"
            "unknown ipsec protocol %d\n"
        }
        symbol = "ipsec4_interface_kpipe_output"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "ipsec6 interface kpipe output: source buffer shorter than ipv6 header, %u\n"
            "ipsec6 interface kpipe output: failed to find outbound sav\n"
            "ipsec6 interface kpipe output: sah is NULL\n"
            "ipsec6 interface kpipe outputbuflet size shorter than hlen %u, SPI=%x\n"
        }
        symbol = "ipsec6_interface_kpipe_output"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "ipsec6_tunnel_validate pkthdr %d off %d ip6hdr %zu"
            "ipsec6_tunnel_validate invalid nxt(%u) protocol"
        }
        symbol = "ipsec6_tunnel_validate"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "nat keepalive: invalid address family %u\n"
        }
        symbol = "ipsec_send_natt_keepalive"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: ifnet_get_local_ports_extended(%s) failed %d"
        }
        symbol = "ipsec_get_local_ports"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: unknown ipsec protocol %d\n"
            "%s: IPsec with IPv6 jumbogram is not supported\n"
        }
        symbol = "ipsec6_update_routecache_and_output"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "ipsec6_output_trans: unknown ipsec protocol %d\n"
            "ipsec6_output_trans: IPsec with IPv6 jumbogram is not supported\n"
        }
        symbol = "ipsec6_output_trans_internal"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "ipsec6_output_tunnel: unsupported inner family, spi=%u\n"
            "ipsec6_output_tunnel: unknown ipsec protocol %d\n"
            "ipsec6_output_tunnel: IPsec with IPv6 jumbogram is not supported\n"
        }
        symbol = "ipsec6_output_tunnel_internal"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "ipsec: monitoring sleep wake"
        }
        symbol = "ipsec_monitor_sleep_wake"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "ENOBUFS in icmp6_error %d\n"
        }
        symbol = "icmp6_error_flag"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "ICMP6 redirect sent from %s rejected; must be from linklocal\n"
            "ICMP6 redirect sent from %s rejected; hlim=%d (must be 255)\n"
            "ICMP6 redirect rejected; no route with inet6 gateway found for redirect dst: %s\n"
            "ICMP6 redirect rejected; not equal to gw-for-src=%s (must be same): %s\n"
            "ICMP6 redirect rejected; no route found for redirect dst: %s\n"
            "ICMP6 redirect rejected; redirect dst must be unicast: %s\n"
            "ICMP6 redirect rejected; neither router case nor onlink case: %s\n"
            "icmp6_redirect_input: invalid ND option, rejected: %s\n"
            "icmp6_redirect_input: lladdrlen mismatch for %s (if %d, icmp6 packet %d): %s\n"
        }
        symbol = "icmp6_redirect_input"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Could not configure CLAT46 address on interface %s.\n"
        }
        symbol = "in6ctl_clat46start"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "eventhandler_invoke(\"in6_event\")"
        }
        symbol = "in6_event_callback"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s: IID derived from HW interface.\n"
            "%s: IID from alterate HW interface %s.\n"
            "%s: borrowed IID from %s\n"
            "%s: IID from PRNG.\n"
            "%s: IID: %02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x\n"
        }
        symbol = "in6_select_iid_from_all_hw"
        caller = "?"
    }
    new {
        args = 3
        anchors {
            "%s src %s dst %s ifscope %d is_direct %d select_srcif %d"
            "%s %s->%s ifscope %d->%d ifa_if %s ro_if %s"
            "%s %s->%s ifscope %d->%d ifa_if %s"
            "%s %s->%s ifscope %d ifa_if %s"
            "%s %s->%s ifscope %d ifa_if NULL"
            "%s->%s ifscope %d ro_if %s != ifa_if %s (cached route cleared)"
            "%s->%s ifscope %d ro_if %s (no ifa_if found)"
            "%s %s->%s ifscope %d ifa_if %s ro_if %s (error=%d)"
        }
        symbol = "selectroute"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s: unable to insert route to %s:%s, flags=0x%x, due to existing ND6 route %s->%s flags=0x%x, attempting to delete\n"
        }
        symbol = "in6_addroute"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: ignore v2 query on ifp %s\n"
            "%s: input v2 query on ifp %s\n"
            "%s: GS query throttled\n"
            "%s: process v2 group query on ifp %s\n"
            "%s: v2 general query response scheduled in T+%d seconds on ifp %s\n"
        }
        symbol = "mld_v2_input_query"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Reinit'd ND information for interface %s\n"
        }
        symbol = "nd6_ifattach"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s: timer scheduled in T+%llus.%lluu (demand %d)\n"
            "%s: timer scheduled in T+%llus.%lluu with %llus.%lluu leeway (demand %d)\n"
            "%s: fast timer scheduled in T+%llus.%lluu (demand %d)\n"
            "%s: not scheduling timer: timers %d, fast_timer %d, T+%llus.%lluu\n"
            "%s: not scheduling timer: timers %d, fast_timer %d, T+%llus.%lluu with %llus.%lluu leeway\n"
        }
        symbol = "nd6_sched_timeout"
        caller = "?"
    }
    new {
        args = 5
        anchors {
            "%s: route %s on %s%d gateway address not AF_LINK\n"
            "%s: route %s on %s%d sdl_alen == 0\n"
        }
        symbol = "nd6_lookup_ipv6"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "nd6_ns_input: invalid hlim (%d) from %s to %s on %s\n"
            "nd6_ns_input: bad DAD packet (wrong ip6 dst)\n"
            "nd6_ns_input: NS packet from non-neighbor\n"
            "nd6_ns_input: bad NS target (multicast)\n"
            "nd6_ns_input: invalid ND option, ignored\n"
            "nd6_ns_input: bad DAD packet (link-layer address option)\n"
            "nd6_ns_input: lladdrlen mismatch for %s (if %d, NS packet %d)\n"
            "nd6_ns_input: duplicate IP6 address %s\n"
            "nd6_ns_input: src=%s\n"
            "nd6_ns_input: dst=%s\n"
            "nd6_ns_input: tgt=%s\n"
        }
        symbol = "nd6_ns_input"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "nd6_ns_output: source can't be determined: dst=%s, error=%d\n"
            "nd6_ns_output: no preferred source available: dst=%s\n"
            "nd6_ns_output: preferred source available is optimistic: dst=%s\n"
        }
        symbol = "nd6_ns_output"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "nd6_na_input: on ND6ALT interface!\n"
            "nd6_na_input: invalid hlim (%d) from %s to %s on %s\n"
            "nd6_na_input: invalid target address %s\n"
            "nd6_na_input: a solicited adv is multicasted\n"
            "nd6_na_input: invalid ND option, ignored\n"
            "nd6_na_input: lladdrlen mismatch for %s (if %d, NA packet %d)\n"
        }
        symbol = "nd6_na_input"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "nd6_na_output: source can't be determined: dst=%s, error=%d\n"
        }
        symbol = "nd6_na_output"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s: host route to %s\n"
            "%s: Successfully deleted host route to %s for interface %s.\n"
            "%s: Failed to delete host route to %s for interface %s with error :%d.\n"
        }
        symbol = "nd6_alt_node_absent"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s: sending unsolicited NA\n"
        }
        symbol = "nd6_unsol_na_output"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "%s: ignoring duplicate NA on replicated interface %s\n"
            "%s: ignoring duplicate NA on %s [DAD not in progress]\n"
            "%s: ignoring duplicate NA on %s [eh_src != tgtlladdr]\n"
            "%s: no DAD structure for %s on %s.\n"
            "%s: duplicate IPv6 address %s [processing NA on %s]\n"
        }
        symbol = "nd6_dad_na_input"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "%s: sending NS who has %s on ALL\n"
            "%s: sending NS who has %s on ALL (except %s)\n"
            "%s: Sending cloned NS who has %s, originally on %s\n"
        }
        symbol = "nd6_prproxy_ns_output"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "nd6_rs_input: invalid hlim (%d) from %s to %s on %s\n"
            "nd6_rs_input: RS packet from non-neighbor\n"
            "nd6_rs_input: invalid ND option, ignored\n"
            "nd6_rs_input: lladdrlen mismatch for %s (if %d, RS packet %d)\n"
        }
        symbol = "nd6_rs_input"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "nd6_ra_input: invalid hlim (%d) from %s to %s on %s\n"
            "nd6_ra_input: src %s is not link-local\n"
            "nd6_ra_input: invalid ND option, ignored\n"
            "RA with a lower CurHopLimit sent from %s on %s (current = %d, received = %d). Ignored.\n"
            "%s: invalid option len %d for route information option, ignored\n"
            "%s: invalid prefix length %d in the route information option, ignored\n"
            "%s: invalid prefix len %d is OOB for route information option, with total option length of %d. Ignored.\n"
            "%s: using reserved preference mask, ignored\n"
            "%s: received RA with route opt, prefix %s/%u pref %u lifetime %u\n"
            "nd6_ra_input: invalid option len %d for prefix information option, ignored\n"
            "nd6_ra_input: invalid prefix len %d for prefix information option, ignored\n"
            "%s: invalid prefix %s, ignored\n"
            "nd6_ra_input: no SLAAC on prefix %s [not RFC 4193]\n"
            "%s: no SLAAC on prefix %s [6to4]\n"
            "nd6_ra_input: bogus mtu option mtu=%d sent from %s, ignoring\n"
            "nd6_ra_input: bogus mtu mtu=%d sent from %s; exceeds maxmtu %d, ignoring\n"
            "nd6_ra_input: mtu option mtu=%d sent from %s; maxmtu unknown, ignoring\n"
            "nd6_ra_input: lladdrlen mismatch for %s (if %d, RA packet %d)\n"
        }
        symbol = "nd6_ra_input"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "prelist_update: failed to make the prefix %s/%d on-link on %s (errno=%d)\n"
            "prelist_update: nd6_prelist_add failed for %s/%d on %s errno=%d, returnpr=0x%llx\n"
            "prelist_update: failed to create a temporary address, errno=%d\n"
        }
        symbol = "prelist_update"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s: is now the default interface (was %s)\n"
            "No default interface set\n"
            "%s: scoped %s/%d on %s has no matching unscoped prefix\n"
            "%s: failed to make %s/%d scoped onlink on %s, errno=%d\n"
            "%s: error promoting %s/%d to %s from %s\n"
            "%s: %s/%d promoted, previously on %s\n"
        }
        symbol = "nd6_setdefaultiface"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "protocol family mismatched %d != %d\n."
        }
        symbol = "key_gettunnel"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "key_checksa_present: invalid sav->state (state: %d SA: %d)\n"
        }
        symbol = "key_checksa_present"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "register custom ipsec: invalid address\n"
            "register custom ipsec: address family mismatched\n"
            "register custom ipsec: address struct size mismatched\n"
            "register custom ipsec: invalid ipsec token\n"
            "register custom esp: invalid address length\n"
            "register custom esp: invalid proto %u\n"
            "register custom esp: SA exists\n"
        }
        symbol = "key_reserve_custom_ipsec"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "key_setsadbaddr: bad prefix length %zu"
        }
        symbol = "key_setsadbaddr"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "key_parse: upper layer protocol mismatched.\n"
            "key_parse: address family mismatched.\n"
            "key_parse: address struct size mismatched.\n"
            "key_parse: unsupported address family.\n"
            "key_parse: illegal prefixlen.\n"
        }
        symbol = "key_validate_address_ext_pair"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "key_getsaddbaddr: mhp is NULL\n"
            "key_getsaddbaddr: ext_len(%zu) < sizeof(struct sadb_address) + sizeof(struct sockaddr)\n"
            "key_getsaddbaddr: ext_len(%zu) < sizeof(struct sadb_address) + sa->sa_len(%u)\n"
        }
        symbol = "key_getsaddbaddr"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "key_checkspidup: address family mismatched.\n"
        }
        symbol = "key_checkspidup"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "key_mature: illegal range of SPI %u.\n"
            "key_mature: invalid flag (derived) given to old-esp.\n"
            "key_mature: invalid flag (derived) given to AH SA.\n"
            "key_mature: protocol and algorithm mismated.\n"
            "key_mature: Invalid satype.\n"
            "key_mature: unknown authentication algorithm.\n"
            "key_mature: invalid AH key length %d (%d-%d allowed)\n"
            "key_mature: no satisfy algorithm for AH\n"
            "key_mature: unknown encryption algorithm.\n"
            "key_mature: invalid ESP key length %d (%d-%d allowed)\n"
            "key_mature: no satisfy algorithm for ESP\n"
        }
        symbol = "key_mature"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "key_getnewspid: to allocate policy id is failed.\n"
        }
        symbol = "key_getnewspid"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "key_setdumpsastats: length too nbug: %u"
            "key_setsadbsastat: length is too big: %zu\n"
        }
        symbol = "key_setdumpsastats"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "key_send_delsp: length too big: %d"
        }
        symbol = "key_delsp_for_ipsec_if"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s:%d set net_mpklog_enabled to %d"
        }
        symbol = "sysctl_net_mpklog_enabled"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "%s:%d set net_mpklog_type to %u (%s)"
        }
        symbol = "sysctl_net_mpklog_type"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "ktrace: manually setting owning process"
        }
        symbol = "ktrace_set_owning_pid"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "ktrace: promoting background tool"
        }
        symbol = "ktrace_reset_internal"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "ktrace: changing state from %d to %d, owned by %s[%d]"
        }
        symbol = "ktrace_set_owning_proc"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "ERROR: Must provide a login name for a new persona!"
            "ERROR: Invalid type: %d"
            "ERROR: too many active personas!"
        }
        symbol = "persona_alloc"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "build_userspace_exit_reason: failed to allocate exit reason\n"
            "build_userspace_exit_reason: exit reason with namespace %u, nonzero payload but zero length\n"
            "build_userspace_exit_reason: failed to allocate signal reason buffer\n"
            "build_userspace_exit_reason: failed to allocate space for reason string\n"
            "build_userspace_exit_reason: failed to copy in payload data with error %d\n"
            "build_userspace_exit_reason: failed to allocate space for payload data\n"
        }
        symbol = "build_userspace_exit_reason"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "memorystatus: WARNING %s [%d] is receiving an entitled debugging memory limit. This is intended only for debugging and can result in unstable device behavior."
        }
        symbol = "memorystatus_act_on_entitled_developer_task_limit"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "memorystatus_list_add(): adding pid %d with priority %d.\n"
        }
        symbol = "memorystatus_add"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "memorystatus: setting %s(%d) to priority %d, inserting at %s\n"
        }
        symbol = "memstat_update_priority_locked"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "memorystatus: changing (%s) pid %d: priority %d, user_data 0x%llx\n"
            "memorystatus_update: effective change specified for pid %d, but change already occurred.\n"
        }
        symbol = "memorystatus_set_priority"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "memorystatus_list_remove: removing pid %d\n"
        }
        symbol = "memorystatus_remove"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "memorystatus: Denying dirty-tracking opt-in for managed %s [%d]\n"
            "%s [%d] enrolled in ActivityTracking tracked %d / idle-exit %d / defer %d / dirty %d"
        }
        symbol = "memorystatus_dirty_track"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "memorystatus_dirty_set(): %d %d 0x%x 0x%x\n"
        }
        symbol = "memorystatus_dirty_set"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "memorystatus_dirty_clear(): %d 0x%x 0x%x\n"
        }
        symbol = "memorystatus_dirty_clear"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "memorystatus_on_ledger_footprint_exceeded: failed to warn %s [%d] (exiting, or no handler registered?).\n"
            "task_exceeded footprint: failed to allocate jetsam reason\n"
            "task_exceeded_footprint: failed to kill the current task (exiting?).\n"
        }
        symbol = "memorystatus_on_ledger_footprint_exceeded"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "memorystatus_allowed_vm_map_fork: corpse for pid %d blocked by jetsam).\n"
            "memorystatus disallowed vm_map_fork %lld  %lld\n"
        }
        symbol = "memorystatus_allowed_vm_map_fork"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "%lu.%03d memorystatus: killing_top_process_elevated%d pid %d [%s] (%s %d) %lluKB - memorystatus_available_pages: %llu\n"
        }
        symbol = "memorystatus_kill_elevated_process"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "jetsam: new idle delay interval has invalid value.\n"
        }
        symbol = "sysctl_jetsam_set_sysprocs_idle_delay_time"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "memorystatus_perform_idle_demotion()\n"
            "memorystatus_perform_idle_demotion() found %s [%d]\n"
            "memorystatus_perform_idle_demotion() found stuck process %d [%s], moving to JETSAM_PRIORITY_AGING_BAND1_STUCK\n"
        }
        symbol = "memorystatus_perform_idle_demotion"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "memorystatus: new limit on pid %d (%dMB %s)\n"
            "memorystatus: error (%d) setting memlimit in ledger for %s [%d]\n"
        }
        symbol = "_memstat_write_memlimit_to_ledger_locked"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "memorystatus: setting memlimit for %s [%d], Active(%dMB %s), Inactive(%dMB, %s)\n"
        }
        symbol = "memstat_set_memlimits_locked"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "memorystatus: jetsam is approaching JETSAM_PRIORITY_FOREGROUND\n"
            "memorystatus: purging kernel memory caches\n"
            "memorystatus: recovered %llu pages from pmap\n"
            "memorystatus: purging all corpses\n"
            "memorystatus: no corpses to purge\n"
            "memorystatus: reclaiming all deferred user memory\n"
            "memorystatus: trimming kernel zone allocator\n"
        }
        symbol = "memstat_approaching_fg_band"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "kill_idle_exit_proc: failed to allocate jetsam reason\n"
            "memorystatus: killing_idle_process pid %d [%s] jetsam_reason->osr_code: %llu\n"
        }
        symbol = "memorystatus_idle_exit_from_VM"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "%lu.%03d memorystatus: killing_specific_process pid %d [%s] (%s %d) %lluKB - memorystatus_available_pages: %llu\n"
        }
        symbol = "memorystatus_kill_process_sync"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "memorystatus_init_jetsam_snapshot_stats: host_statistics64 failed with %d\n"
        }
        symbol = "memorystatus_init_snapshot_vmstats"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "memorystatus: WARNING snapshot buffer is full, count %d\n"
            "memorystatus_update_jetsam_snapshot_entry_locked: failed to update pid %d, priority %d, count %d\n"
        }
        symbol = "memorystatus_update_jetsam_snapshot_entry_locked"
        caller = "?"
    }
    new {
        args = 2
        anchors {
            "memorystatus_get_priority_list: returning %lu for size\n"
        }
        symbol = "memorystatus_cmd_get_priority_list"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "memorystatus_get_jetsam_snapshot: returned inputsize (%ld), snapshot_size(%ld), listcount(%ld)\n"
            "memorystatus_get_on_demand_snapshot: returned inputsize (%ld), snapshot_size(%ld), listcount(%ld)\n"
            "memorystatus_get_at_boot_snapshot: returned inputsize (%ld), snapshot_size(%ld), listcount(%d)\n"
        }
        symbol = "memorystatus_cmd_get_jetsam_snapshot"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "memorystatus: process %s [%d] opted in to both Management and ActivityTracking\n"
        }
        symbol = "memorystatus_set_process_is_managed"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "memorystatus_bg_pressure_eligible: pid %d, state 0x%x\n"
        }
        symbol = "memorystatus_update_vm_pressure"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "mbuf_allocpacket %d"
        }
        symbol = "mbuf_allocpacket"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "eventhandler_invoke(\"protoctl_event\")"
        }
        symbol = "protoctl_event_callback"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "sendit_x: internalize_user_msg_x error %d\n"
            "sendit_x: mbuf_packet_from_uio error %d\n"
            "sendit_x: sockargs error %d\n"
            "sendit_x: sosend_list error %d\n"
            "mbuf_packet_from_uio: mbuf_allocpacket %zu error %d"
            "mbuf_packet_from_uio: len %d error %d"
        }
        symbol = "sendit_x"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "TRACKER - %s:%d No tracker attribute of type %d found in parameters\n"
            "TRACKER - %s:%d Wrong size for tracker attribute type %d size %zu <got size %zu>\n"
            "TRACKER - %s:%d Exceeded max size (%zu) - tracker attribute type %d size %zu\n"
            "TRACKER - %s:%d Failed to get value for tracker attribute type %d size %zu\n"
        }
        symbol = "tracker_retrieve_attribute"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "TRACKER - %s:%d Missing remote address\n"
            "TRACKER - %s:%d Invalid address family <%d>\n"
        }
        symbol = "fill_hash_entry"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "TRACKER - %s:%d %s - %s <%s> len %d <%s> len %d <flags %X> %x%x%x%x-%x%x%x%x-%x%x%x%x-%x%x%x%x (hash 0x%X hashsize %d)\n"
        }
        symbol = "tracker_entry_log"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "SOFLOW - %s:%d <pid %d so %llx> ifflagsp set to 0x%X\n"
            "SOFLOW - %s:%d <pid %d so %llx> Collected NSTAT counts: rxpackets %llu rxbytes %llu txpackets %llu txbytes %llu\n"
            "SOFLOW - %s:%d <pid %d so %llx> Collected NSTAT metadata: eupid %llu epid %d euuid %x%x%x%x-%x%x%x%x-%x%x%x%x-%x%x%x%x outifp %d properties 0x%X lport %d fport %d laddr %s faddr %s rcvbufsize %u rcvbufused %u traffic_class %u\n"
        }
        symbol = "soflow_nstat_provider_request_vals"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "eventhandler_deregister event_type=ifnet_event"
            "eventhandler_deregister event_type=protoctl_event"
        }
        symbol = "fsw_uninit"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "EXT_PANICLOG: instance is NULL\n"
            "EXT_PANICLOG: init failed\n"
            "EXT_PANICLOG: Handle alloc failed\n"
        }
        symbol = "__ZN20IOExtensiblePaniclog14createWithUUIDEPhPKcj29ext_paniclog_create_options_tPPS_"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "PMRD: %s(%s, %x)\n"
        }
        symbol = "__ZN14IOPMrootDomain30changePowerStateWithOverrideToEmj"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "IRQ exception taken while SP1 selected"
        }
        symbol = "fleh_irq_sp1"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "FIQ exception taken while SP1 selected"
        }
        symbol = "fleh_fiq_sp1"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Asynchronous exception taken while SP1 selected"
        }
        symbol = "fleh_serror_sp1"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "Preemption count negative on thread %p"
        }
        symbol = "preempt_underflow"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "MDSCR.KDE was set"
        }
        symbol = "_update_mdscr"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "JOP Hash Mismatch Detected (PC, CPSR, or LR corruption)"
            "Signed thread state manipulated with interrupts enabled"
        }
        symbol = "_ml_check_signed_state"
        caller = "?"
    }
    new {
        args = 1
        anchors {
            "Thread state corruption detected (PE mode == 0)"
        }
        symbol = "_ml_auth_thread_state_invalid_cpsr"
        caller = "?"
    }
    new {
        args = 0
        anchors {
            "os_cpu_in_cksum_mbuf: out of data\n"
        }
        symbol = "_os_cpu_in_cksum_mbuf"
        caller = "?"
    }
}